From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: hopeless-ponderer <hopelessponderer1123@gmail.com>
Date: Sun, 30 May 2021 21:22:37 -0700
Subject: [PATCH] ported Delphi bot code from mare_nostrum branch

---
 .../public/simulation/ai/delphi/_delphibot.js |   30 +-
 .../simulation/ai/delphi/attackManager.js     |   72 +-
 .../public/simulation/ai/delphi/attackPlan.js |  188 +--
 .../simulation/ai/delphi/baseManager.js       |  144 +--
 .../simulation/ai/delphi/buildManager.js      |   37 +-
 .../public/simulation/ai/delphi/chatHelper.js |   34 +-
 .../public/simulation/ai/delphi/config.js     |   17 +-
 .../public/simulation/ai/delphi/data.json     |    8 +-
 .../simulation/ai/delphi/defenseArmy.js       |   52 +-
 .../simulation/ai/delphi/defenseManager.js    |   81 +-
 .../simulation/ai/delphi/diplomacyManager.js  |   46 +-
 .../simulation/ai/delphi/entityExtend.js      |   74 +-
 .../simulation/ai/delphi/garrisonManager.js   |   38 +-
 .../simulation/ai/delphi/headquarters.js      | 1008 +++++++++++------
 .../public/simulation/ai/delphi/mapModule.js  |   68 +-
 .../simulation/ai/delphi/navalManager.js      |   96 +-
 .../mods/public/simulation/ai/delphi/queue.js |   40 +-
 .../simulation/ai/delphi/queueManager.js      |   56 +-
 .../public/simulation/ai/delphi/queueplan.js  |   16 +-
 .../simulation/ai/delphi/queueplanBuilding.js |  111 +-
 .../simulation/ai/delphi/queueplanResearch.js |   20 +-
 .../simulation/ai/delphi/queueplanTraining.js |   20 +-
 .../simulation/ai/delphi/researchManager.js   |   40 +-
 .../simulation/ai/delphi/startingStrategy.js  |   59 +-
 .../simulation/ai/delphi/tradeManager.js      |  120 +-
 .../simulation/ai/delphi/transportPlan.js     |   48 +-
 .../simulation/ai/delphi/victoryManager.js    |   52 +-
 .../public/simulation/ai/delphi/worker.js     |   88 +-
 28 files changed, 1516 insertions(+), 1147 deletions(-)

diff --git a/binaries/data/mods/public/simulation/ai/delphi/_delphibot.js b/binaries/data/mods/public/simulation/ai/delphi/_delphibot.js
index 4b03d01099..fe25323d24 100644
--- a/binaries/data/mods/public/simulation/ai/delphi/_delphibot.js
+++ b/binaries/data/mods/public/simulation/ai/delphi/_delphibot.js
@@ -1,8 +1,8 @@
 Engine.IncludeModule("common-api");
 
-var PETRA = {};
+var DELPHI = {};
 
-PETRA.PetraBot = function(settings)
+DELPHI.DelphiBot = function(settings)
 {
 	API3.BaseAI.call(this, settings);
 
@@ -16,14 +16,14 @@ PETRA.PetraBot = function(settings)
 		"transports": 1	// transport plans start at 1 because 0 might be used as none
 	};
 
-	this.Config = new PETRA.Config(settings.difficulty, settings.behavior);
+	this.Config = new DELPHI.Config(settings.difficulty, settings.behavior);
 
 	this.savedEvents = {};
 };
 
-PETRA.PetraBot.prototype = Object.create(API3.BaseAI.prototype);
+DELPHI.DelphiBot.prototype = Object.create(API3.BaseAI.prototype);
 
-PETRA.PetraBot.prototype.CustomInit = function(gameState)
+DELPHI.DelphiBot.prototype.CustomInit = function(gameState)
 {
 	if (this.isDeserialized)
 	{
@@ -51,11 +51,11 @@ PETRA.PetraBot.prototype.CustomInit = function(gameState)
 
 		this.Config.Deserialize(this.data.config);
 
-		this.queueManager = new PETRA.QueueManager(this.Config, {});
+		this.queueManager = new DELPHI.QueueManager(this.Config, {});
 		this.queueManager.Deserialize(gameState, this.data.queueManager);
 		this.queues = this.queueManager.queues;
 
-		this.HQ = new PETRA.HQ(this.Config);
+		this.HQ = new DELPHI.HQ(this.Config);
 		this.HQ.init(gameState, this.queues);
 		this.HQ.Deserialize(gameState, this.data.HQ);
 
@@ -73,11 +73,11 @@ PETRA.PetraBot.prototype.CustomInit = function(gameState)
 		// this.queues can only be modified by the queue manager or things will go awry.
 		this.queues = {};
 		for (let i in this.Config.priorities)
-			this.queues[i] = new PETRA.Queue();
+			this.queues[i] = new DELPHI.Queue();
 
-		this.queueManager = new PETRA.QueueManager(this.Config, this.queues);
+		this.queueManager = new DELPHI.QueueManager(this.Config, this.queues);
 
-		this.HQ = new PETRA.HQ(this.Config);
+		this.HQ = new DELPHI.HQ(this.Config);
 
 		this.HQ.init(gameState, this.queues);
 
@@ -86,14 +86,14 @@ PETRA.PetraBot.prototype.CustomInit = function(gameState)
 	}
 };
 
-PETRA.PetraBot.prototype.OnUpdate = function(sharedScript)
+DELPHI.DelphiBot.prototype.OnUpdate = function(sharedScript)
 {
 	if (this.gameFinished)
 		return;
 
 	for (let i in this.events)
 	{
-		if (i == "AIMetadata")   // not used inside petra
+		if (i == "AIMetadata")   // not used inside delphi
 			continue;
 		if(this.savedEvents[i] !== undefined)
 			this.savedEvents[i] = this.savedEvents[i].concat(this.events[i]);
@@ -105,7 +105,7 @@ PETRA.PetraBot.prototype.OnUpdate = function(sharedScript)
 	this.elapsedTime = this.gameState.getTimeElapsed() / 1000;
 	if (!this.playedTurn || (this.turn + this.player) % 8 == 5)
 	{
-		Engine.ProfileStart("PetraBot bot (player " + this.player +")");
+		Engine.ProfileStart("DelphiBot bot (player " + this.player +")");
 
 		this.playedTurn++;
 
@@ -128,7 +128,7 @@ PETRA.PetraBot.prototype.OnUpdate = function(sharedScript)
 	this.turn++;
 };
 
-PETRA.PetraBot.prototype.Serialize = function()
+DELPHI.DelphiBot.prototype.Serialize = function()
 {
 	let savedEvents = {};
 	for (let key in this.savedEvents)
@@ -159,7 +159,7 @@ PETRA.PetraBot.prototype.Serialize = function()
 	};
 };
 
-PETRA.PetraBot.prototype.Deserialize = function(data, sharedScript)
+DELPHI.DelphiBot.prototype.Deserialize = function(data, sharedScript)
 {
 	this.isDeserialized = true;
 	this.data = data;
diff --git a/binaries/data/mods/public/simulation/ai/delphi/attackManager.js b/binaries/data/mods/public/simulation/ai/delphi/attackManager.js
index f92d940937..f009d50ee1 100644
--- a/binaries/data/mods/public/simulation/ai/delphi/attackManager.js
+++ b/binaries/data/mods/public/simulation/ai/delphi/attackManager.js
@@ -1,7 +1,7 @@
 /**
  * Attack Manager
  */
-PETRA.AttackManager = function(Config)
+DELPHI.AttackManager = function(Config)
 {
 	this.Config = Config;
 
@@ -20,13 +20,13 @@ PETRA.AttackManager = function(Config)
 };
 
 /** More initialisation for stuff that needs the gameState */
-PETRA.AttackManager.prototype.init = function(gameState)
+DELPHI.AttackManager.prototype.init = function(gameState)
 {
 	this.outOfPlan = gameState.getOwnUnits().filter(API3.Filters.byMetadata(PlayerID, "plan", -1));
 	this.outOfPlan.registerUpdates();
 };
 
-PETRA.AttackManager.prototype.setRushes = function(allowed)
+DELPHI.AttackManager.prototype.setRushes = function(allowed)
 {
 	if (this.Config.personality.aggressive > this.Config.personalityCut.strong && allowed > 2)
 	{
@@ -45,7 +45,7 @@ PETRA.AttackManager.prototype.setRushes = function(allowed)
 	}
 };
 
-PETRA.AttackManager.prototype.checkEvents = function(gameState, events)
+DELPHI.AttackManager.prototype.checkEvents = function(gameState, events)
 {
 	for (let evt of events.PlayerDefeated)
 		this.defeated[evt.playerId] = true;
@@ -100,7 +100,7 @@ PETRA.AttackManager.prototype.checkEvents = function(gameState, events)
 		break;  // take only the first attack request into account
 	}
 	if (targetPlayer !== undefined)
-		PETRA.chatAnswerRequestAttack(gameState, targetPlayer, answer, other);
+		DELPHI.chatAnswerRequestAttack(gameState, targetPlayer, answer, other);
 
 	for (let evt of events.EntityRenamed)	// take care of packing units in bombing attacks
 	{
@@ -123,7 +123,7 @@ PETRA.AttackManager.prototype.checkEvents = function(gameState, events)
 /**
  * Check for any structure in range from within our territory, and bomb it
  */
-PETRA.AttackManager.prototype.assignBombers = function(gameState)
+DELPHI.AttackManager.prototype.assignBombers = function(gameState)
 {
 	// First some cleaning of current bombing attacks
 	for (let [targetId, unitIds] of this.bombingAttacks)
@@ -177,10 +177,10 @@ PETRA.AttackManager.prototype.assignBombers = function(gameState)
 
 		let range = ent.attackRange("Ranged").max;
 		let entPos = ent.position();
-		let access = PETRA.getLandAccess(gameState, ent);
+		let access = DELPHI.getLandAccess(gameState, ent);
 		for (let struct of gameState.getEnemyStructures().values())
 		{
-			if (!ent.canAttackTarget(struct, PETRA.allowCapture(gameState, ent, struct)))
+			if (!ent.canAttackTarget(struct, DELPHI.allowCapture(gameState, ent, struct)))
 				continue;
 
 			let structPos = struct.position();
@@ -235,7 +235,7 @@ PETRA.AttackManager.prototype.assignBombers = function(gameState)
  * Some functions are run every turn
  * Others once in a while
  */
-PETRA.AttackManager.prototype.update = function(gameState, queues, events)
+DELPHI.AttackManager.prototype.update = function(gameState, queues, events)
 {
 	if (this.Config.debug > 2 && gameState.ai.elapsedTime > this.debugTime + 60)
 	{
@@ -262,7 +262,7 @@ PETRA.AttackManager.prototype.update = function(gameState, queues, events)
 			attack.checkEvents(gameState, events);
 
 			if (attack.isStarted())
-				API3.warn("Petra problem in attackManager: attack in preparation has already started ???");
+				API3.warn("Delphi problem in attackManager: attack in preparation has already started ???");
 
 			let updateStep = attack.updatePreparation(gameState);
 			// now we're gonna check if the preparation time is over
@@ -286,7 +286,7 @@ PETRA.AttackManager.prototype.update = function(gameState, queues, events)
 					if (this.Config.debug > 1)
 						API3.warn("Attack Manager: Starting " + attack.getType() + " plan " + attack.getName());
 					if (this.Config.chat)
-						PETRA.chatLaunchAttack(gameState, attack.targetPlayer, attack.getType());
+						DELPHI.chatLaunchAttack(gameState, attack.targetPlayer, attack.getType());
 					this.startedAttacks[attackType].push(attack);
 				}
 				else
@@ -325,7 +325,7 @@ PETRA.AttackManager.prototype.update = function(gameState, queues, events)
 		{
 			// we have a barracks and we want to rush, rush.
 			let data = { "targetSize": this.rushSize[this.rushNumber] };
-			let attackPlan = new PETRA.AttackPlan(gameState, this.Config, this.totalNumber, "Rush", data);
+			let attackPlan = new DELPHI.AttackPlan(gameState, this.Config, this.totalNumber, "Rush", data);
 			if (!attackPlan.failed)
 			{
 				if (this.Config.debug > 1)
@@ -345,7 +345,7 @@ PETRA.AttackManager.prototype.update = function(gameState, queues, events)
 			!gameState.ai.HQ.baseManagers[1])	// if we have no base ... nothing else to do than attack
 		{
 			let type = this.attackNumber < 2 || this.startedAttacks.HugeAttack.length > 0 ? "Attack" : "HugeAttack";
-			let attackPlan = new PETRA.AttackPlan(gameState, this.Config, this.totalNumber, type);
+			let attackPlan = new DELPHI.AttackPlan(gameState, this.Config, this.totalNumber, type);
 			if (attackPlan.failed)
 				this.attackPlansEncounteredWater = true; // hack
 			else
@@ -381,7 +381,7 @@ PETRA.AttackManager.prototype.update = function(gameState, queues, events)
 		this.assignBombers(gameState);
 };
 
-PETRA.AttackManager.prototype.getPlan = function(planName)
+DELPHI.AttackManager.prototype.getPlan = function(planName)
 {
 	for (let attackType in this.upcomingAttacks)
 	{
@@ -398,21 +398,21 @@ PETRA.AttackManager.prototype.getPlan = function(planName)
 	return undefined;
 };
 
-PETRA.AttackManager.prototype.pausePlan = function(planName)
+DELPHI.AttackManager.prototype.pausePlan = function(planName)
 {
 	let attack = this.getPlan(planName);
 	if (attack)
 		attack.setPaused(true);
 };
 
-PETRA.AttackManager.prototype.unpausePlan = function(planName)
+DELPHI.AttackManager.prototype.unpausePlan = function(planName)
 {
 	let attack = this.getPlan(planName);
 	if (attack)
 		attack.setPaused(false);
 };
 
-PETRA.AttackManager.prototype.pauseAllPlans = function()
+DELPHI.AttackManager.prototype.pauseAllPlans = function()
 {
 	for (let attackType in this.upcomingAttacks)
 		for (let attack of this.upcomingAttacks[attackType])
@@ -423,7 +423,7 @@ PETRA.AttackManager.prototype.pauseAllPlans = function()
 			attack.setPaused(true);
 };
 
-PETRA.AttackManager.prototype.unpauseAllPlans = function()
+DELPHI.AttackManager.prototype.unpauseAllPlans = function()
 {
 	for (let attackType in this.upcomingAttacks)
 		for (let attack of this.upcomingAttacks[attackType])
@@ -434,7 +434,7 @@ PETRA.AttackManager.prototype.unpauseAllPlans = function()
 			attack.setPaused(false);
 };
 
-PETRA.AttackManager.prototype.getAttackInPreparation = function(type)
+DELPHI.AttackManager.prototype.getAttackInPreparation = function(type)
 {
 	return this.upcomingAttacks[type].length ? this.upcomingAttacks[type][0] : undefined;
 };
@@ -444,7 +444,7 @@ PETRA.AttackManager.prototype.getAttackInPreparation = function(type)
  * attack.targetPlayer is undefined and in that case, we keep track of the chosen target
  * for future attacks.
  */
-PETRA.AttackManager.prototype.getEnemyPlayer = function(gameState, attack)
+DELPHI.AttackManager.prototype.getEnemyPlayer = function(gameState, attack)
 {
 	let enemyPlayer;
 
@@ -500,14 +500,14 @@ PETRA.AttackManager.prototype.getEnemyPlayer = function(gameState, attack)
 			if (ourcc.owner() != PlayerID)
 				continue;
 			let ourPos = ourcc.position();
-			let access = PETRA.getLandAccess(gameState, ourcc);
+			let access = DELPHI.getLandAccess(gameState, ourcc);
 			for (let enemycc of ccEnts.values())
 			{
 				if (veto[enemycc.owner()])
 					continue;
 				if (!gameState.isPlayerEnemy(enemycc.owner()))
 					continue;
-				if (access != PETRA.getLandAccess(gameState, enemycc))
+				if (access != DELPHI.getLandAccess(gameState, enemycc))
 					continue;
 				let dist = API3.SquareVectorDistance(ourPos, enemycc.position());
 				if (distmin && dist > distmin)
@@ -558,7 +558,7 @@ PETRA.AttackManager.prototype.getEnemyPlayer = function(gameState, attack)
  * Target the player with the most advanced wonder.
  * TODO currently the first built wonder is kept, should chek on the minimum wonderDuration left instead.
  */
-PETRA.AttackManager.prototype.getWonderEnemyPlayer = function(gameState, attack)
+DELPHI.AttackManager.prototype.getWonderEnemyPlayer = function(gameState, attack)
 {
 	let enemyPlayer;
 	let enemyWonder;
@@ -590,7 +590,7 @@ PETRA.AttackManager.prototype.getWonderEnemyPlayer = function(gameState, attack)
 /**
  * Target the player with the most relics (including gaia).
  */
-PETRA.AttackManager.prototype.getRelicEnemyPlayer = function(gameState, attack)
+DELPHI.AttackManager.prototype.getRelicEnemyPlayer = function(gameState, attack)
 {
 	let enemyPlayer;
 	let allRelics = gameState.updatingGlobalCollection("allRelics", API3.Filters.byClass("Relic"));
@@ -618,7 +618,7 @@ PETRA.AttackManager.prototype.getRelicEnemyPlayer = function(gameState, attack)
 };
 
 /** f.e. if we have changed diplomacy with another player. */
-PETRA.AttackManager.prototype.cancelAttacksAgainstPlayer = function(gameState, player)
+DELPHI.AttackManager.prototype.cancelAttacksAgainstPlayer = function(gameState, player)
 {
 	for (let attackType in this.upcomingAttacks)
 		for (let attack of this.upcomingAttacks[attackType])
@@ -637,10 +637,10 @@ PETRA.AttackManager.prototype.cancelAttacksAgainstPlayer = function(gameState, p
 		}
 };
 
-PETRA.AttackManager.prototype.raidTargetEntity = function(gameState, ent)
+DELPHI.AttackManager.prototype.raidTargetEntity = function(gameState, ent)
 {
 	let data = { "target": ent };
-	let attackPlan = new PETRA.AttackPlan(gameState, this.Config, this.totalNumber, "Raid", data);
+	let attackPlan = new DELPHI.AttackPlan(gameState, this.Config, this.totalNumber, "Raid", data);
 	if (attackPlan.failed)
 		return null;
 	if (this.Config.debug > 1)
@@ -655,7 +655,7 @@ PETRA.AttackManager.prototype.raidTargetEntity = function(gameState, ent)
 /**
  * Return the number of units from any of our attacking armies around this position
  */
-PETRA.AttackManager.prototype.numAttackingUnitsAround = function(pos, dist)
+DELPHI.AttackManager.prototype.numAttackingUnitsAround = function(pos, dist)
 {
 	let num = 0;
 	for (let attackType in this.startedAttacks)
@@ -675,7 +675,7 @@ PETRA.AttackManager.prototype.numAttackingUnitsAround = function(pos, dist)
  * data.armyID: transform only the defense army ID into a new attack
  * data.uniqueTarget: the attack will stop when the target is destroyed or captured
  */
-PETRA.AttackManager.prototype.switchDefenseToAttack = function(gameState, target, data)
+DELPHI.AttackManager.prototype.switchDefenseToAttack = function(gameState, target, data)
 {
 	if (!target || !target.position())
 		return false;
@@ -687,14 +687,14 @@ PETRA.AttackManager.prototype.switchDefenseToAttack = function(gameState, target
 	let attackData = data.uniqueTarget ? { "uniqueTargetId": target.id() } : undefined;
 	let pos = target.position();
 	let attackType = "Attack";
-	let attackPlan = new PETRA.AttackPlan(gameState, this.Config, this.totalNumber, attackType, attackData);
+	let attackPlan = new DELPHI.AttackPlan(gameState, this.Config, this.totalNumber, attackType, attackData);
 	if (attackPlan.failed)
 		return false;
 	this.totalNumber++;
 	attackPlan.init(gameState);
 	this.startedAttacks[attackType].push(attackPlan);
 
-	let targetAccess = PETRA.getLandAccess(gameState, target);
+	let targetAccess = DELPHI.getLandAccess(gameState, target);
 	for (let army of gameState.ai.HQ.defenseManager.armies)
 	{
 		if (data.range)
@@ -714,7 +714,7 @@ PETRA.AttackManager.prototype.switchDefenseToAttack = function(gameState, target
 			army.removeOwn(gameState, unitId);
 			let unit = gameState.getEntityById(unitId);
 			let accessOk = unit.getMetadata(PlayerID, "transport") !== undefined ||
-			               unit.position() && PETRA.getLandAccess(gameState, unit) == targetAccess;
+			               unit.position() && DELPHI.getLandAccess(gameState, unit) == targetAccess;
 			if (unit && accessOk && attackPlan.isAvailableUnit(gameState, unit))
 			{
 				unit.setMetadata(PlayerID, "plan", attackPlan.name);
@@ -737,7 +737,7 @@ PETRA.AttackManager.prototype.switchDefenseToAttack = function(gameState, target
 	return true;
 };
 
-PETRA.AttackManager.prototype.Serialize = function()
+DELPHI.AttackManager.prototype.Serialize = function()
 {
 	let properties = {
 		"totalNumber": this.totalNumber,
@@ -770,7 +770,7 @@ PETRA.AttackManager.prototype.Serialize = function()
 	return { "properties": properties, "upcomingAttacks": upcomingAttacks, "startedAttacks": startedAttacks };
 };
 
-PETRA.AttackManager.prototype.Deserialize = function(gameState, data)
+DELPHI.AttackManager.prototype.Deserialize = function(gameState, data)
 {
 	for (let key in data.properties)
 		this[key] = data.properties[key];
@@ -781,7 +781,7 @@ PETRA.AttackManager.prototype.Deserialize = function(gameState, data)
 		this.upcomingAttacks[key] = [];
 		for (let dataAttack of data.upcomingAttacks[key])
 		{
-			let attack = new PETRA.AttackPlan(gameState, this.Config, dataAttack.properties.name);
+			let attack = new DELPHI.AttackPlan(gameState, this.Config, dataAttack.properties.name);
 			attack.Deserialize(gameState, dataAttack);
 			attack.init(gameState);
 			this.upcomingAttacks[key].push(attack);
@@ -794,7 +794,7 @@ PETRA.AttackManager.prototype.Deserialize = function(gameState, data)
 		this.startedAttacks[key] = [];
 		for (let dataAttack of data.startedAttacks[key])
 		{
-			let attack = new PETRA.AttackPlan(gameState, this.Config, dataAttack.properties.name);
+			let attack = new DELPHI.AttackPlan(gameState, this.Config, dataAttack.properties.name);
 			attack.Deserialize(gameState, dataAttack);
 			attack.init(gameState);
 			this.startedAttacks[key].push(attack);
diff --git a/binaries/data/mods/public/simulation/ai/delphi/attackPlan.js b/binaries/data/mods/public/simulation/ai/delphi/attackPlan.js
index 6f6f0723ce..ff0bba5003 100644
--- a/binaries/data/mods/public/simulation/ai/delphi/attackPlan.js
+++ b/binaries/data/mods/public/simulation/ai/delphi/attackPlan.js
@@ -5,7 +5,7 @@
  * It also handles the actual attack, though much work is needed on that.
  */
 
-PETRA.AttackPlan = function(gameState, Config, uniqueID, type, data)
+DELPHI.AttackPlan = function(gameState, Config, uniqueID, type, data)
 {
 	this.Config = Config;
 	this.name = uniqueID;
@@ -36,7 +36,7 @@ PETRA.AttackPlan = function(gameState, Config, uniqueID, type, data)
 	{
 		if (!base.anchor || !base.anchor.position())
 			continue;
-		let access = PETRA.getLandAccess(gameState, base.anchor);
+		let access = DELPHI.getLandAccess(gameState, base.anchor);
 		if (!rallyPoint)
 		{
 			rallyPoint = base.anchor.position();
@@ -51,7 +51,7 @@ PETRA.AttackPlan = function(gameState, Config, uniqueID, type, data)
 		{
 			if (!ent.position())
 				continue;
-			let access = PETRA.getLandAccess(gameState, ent);
+			let access = DELPHI.getLandAccess(gameState, ent);
 			rallyPoint = ent.position();
 			rallyAccess = access;
 			allAccesses[access] = rallyPoint;
@@ -73,7 +73,7 @@ PETRA.AttackPlan = function(gameState, Config, uniqueID, type, data)
 				continue;
 			if (!structure.position())
 				continue;
-			let access = PETRA.getLandAccess(gameState, structure);
+			let access = DELPHI.getLandAccess(gameState, structure);
 			if (access in allAccesses)
 			{
 				this.overseas = 0;
@@ -87,7 +87,7 @@ PETRA.AttackPlan = function(gameState, Config, uniqueID, type, data)
 				{
 					if (this.target)
 					{
-						API3.warn("Petra: " + this.type + " " + this.name + " has an inaccessible target " +
+						API3.warn("Delphi: " + this.type + " " + this.name + " has an inaccessible target " +
 						          this.target.templateName() + " indices " + rallyAccess + " " + access);
 						this.failed = true;
 						return false;
@@ -152,7 +152,9 @@ PETRA.AttackPlan = function(gameState, Config, uniqueID, type, data)
 			"interests": [["strength", 3]] };
 		this.unitStat.ChampMeleeFastMoving = { "priority": 1, "minSize": 3, "targetSize": 15, "batchSize": 3, "classes": ["FastMoving+Melee+Champion"],
 			"interests": [["strength", 2]] };
-		this.unitStat.Hero = { "priority": 1, "minSize": 0, "targetSize": 1, "batchSize": 1, "classes": ["Hero"],
+		this.unitStat.ChampMeleeElephant   = { "priority": 1, "minSize": 0, "targetSize": 5, "batchSize": 1, "classes": ["Elephant", "Melee", "Champion"],
+			"interests": [["strength", 2]] };
+		this.unitStat.Hero                = { "priority": 1, "minSize": 0, "targetSize":  1, "batchSize": 1, "classes": ["Hero"],
 			"interests": [["strength", 2]] };
 		this.neededShips = 5;
 	}
@@ -227,7 +229,7 @@ PETRA.AttackPlan = function(gameState, Config, uniqueID, type, data)
 	return true;
 };
 
-PETRA.AttackPlan.prototype.init = function(gameState)
+DELPHI.AttackPlan.prototype.init = function(gameState)
 {
 	this.queue = gameState.ai.queues["plan_" + this.name];
 	this.queueChamp = gameState.ai.queues["plan_" + this.name +"_champ"];
@@ -250,27 +252,27 @@ PETRA.AttackPlan.prototype.init = function(gameState)
 	}
 };
 
-PETRA.AttackPlan.prototype.getName = function()
+DELPHI.AttackPlan.prototype.getName = function()
 {
 	return this.name;
 };
 
-PETRA.AttackPlan.prototype.getType = function()
+DELPHI.AttackPlan.prototype.getType = function()
 {
 	return this.type;
 };
 
-PETRA.AttackPlan.prototype.isStarted = function()
+DELPHI.AttackPlan.prototype.isStarted = function()
 {
 	return this.state !== "unexecuted" && this.state !== "completing";
 };
 
-PETRA.AttackPlan.prototype.isPaused = function()
+DELPHI.AttackPlan.prototype.isPaused = function()
 {
 	return this.paused;
 };
 
-PETRA.AttackPlan.prototype.setPaused = function(boolValue)
+DELPHI.AttackPlan.prototype.setPaused = function(boolValue)
 {
 	this.paused = boolValue;
 };
@@ -279,7 +281,7 @@ PETRA.AttackPlan.prototype.setPaused = function(boolValue)
  * Returns true if the attack can be executed at the current time
  * Basically it checks we have enough units.
  */
-PETRA.AttackPlan.prototype.canStart = function()
+DELPHI.AttackPlan.prototype.canStart = function()
 {
 	if (!this.canBuildUnits)
 		return true;
@@ -291,7 +293,7 @@ PETRA.AttackPlan.prototype.canStart = function()
 	return true;
 };
 
-PETRA.AttackPlan.prototype.mustStart = function()
+DELPHI.AttackPlan.prototype.mustStart = function()
 {
 	if (this.isPaused())
 		return false;
@@ -321,7 +323,7 @@ PETRA.AttackPlan.prototype.mustStart = function()
 	return false;
 };
 
-PETRA.AttackPlan.prototype.forceStart = function()
+DELPHI.AttackPlan.prototype.forceStart = function()
 {
 	for (let unitCat in this.unitStat)
 	{
@@ -332,14 +334,14 @@ PETRA.AttackPlan.prototype.forceStart = function()
 	this.forced = true;
 };
 
-PETRA.AttackPlan.prototype.emptyQueues = function()
+DELPHI.AttackPlan.prototype.emptyQueues = function()
 {
 	this.queue.empty();
 	this.queueChamp.empty();
 	this.queueSiege.empty();
 };
 
-PETRA.AttackPlan.prototype.removeQueues = function(gameState)
+DELPHI.AttackPlan.prototype.removeQueues = function(gameState)
 {
 	gameState.ai.queueManager.removeQueue("plan_" + this.name);
 	gameState.ai.queueManager.removeQueue("plan_" + this.name + "_champ");
@@ -347,7 +349,7 @@ PETRA.AttackPlan.prototype.removeQueues = function(gameState)
 };
 
 /** Adds a build order. If resetQueue is true, this will reset the queue. */
-PETRA.AttackPlan.prototype.addBuildOrder = function(gameState, name, unitStats, resetQueue)
+DELPHI.AttackPlan.prototype.addBuildOrder = function(gameState, name, unitStats, resetQueue)
 {
 	if (!this.isStarted())
 	{
@@ -362,13 +364,13 @@ PETRA.AttackPlan.prototype.addBuildOrder = function(gameState, name, unitStats,
 	}
 };
 
-PETRA.AttackPlan.prototype.addSiegeUnits = function(gameState)
+DELPHI.AttackPlan.prototype.addSiegeUnits = function(gameState)
 {
 	if (this.siegeState == 2 || this.state !== "unexecuted")
 		return false;
 
 	let civ = gameState.getPlayerCiv();
-	let classes = [["Siege", "Melee"], ["Siege", "Ranged"], ["Elephant", "Melee"]];
+	let classes = [[ "Siege", "Melee"], ["Siege", "Ranged"]];
 	let hasTrainer = [false, false, false];
 	for (let ent of gameState.getOwnTrainingFacilities().values())
 	{
@@ -414,7 +416,7 @@ PETRA.AttackPlan.prototype.addSiegeUnits = function(gameState)
 };
 
 /** Three returns possible: 1 is "keep going", 0 is "failed plan", 2 is "start". */
-PETRA.AttackPlan.prototype.updatePreparation = function(gameState)
+DELPHI.AttackPlan.prototype.updatePreparation = function(gameState)
 {
 	// the completing step is used to return resources and regroup the units
 	// so we check that we have no more forced order before starting the attack
@@ -566,8 +568,8 @@ PETRA.AttackPlan.prototype.updatePreparation = function(gameState)
 		ent.setMetadata(PlayerID, "subrole", "completing");
 		let queued = false;
 		if (ent.resourceCarrying() && ent.resourceCarrying().length)
-			queued = PETRA.returnResources(gameState, ent);
-		let index = PETRA.getLandAccess(gameState, ent);
+			queued = DELPHI.returnResources(gameState, ent);
+		let index = DELPHI.getLandAccess(gameState, ent);
 		if (index == rallyIndex)
 			ent.moveToRange(rallyPoint[0], rallyPoint[1], 0, 15, queued);
 		else
@@ -579,7 +581,7 @@ PETRA.AttackPlan.prototype.updatePreparation = function(gameState)
 	return	1;
 };
 
-PETRA.AttackPlan.prototype.trainMoreUnits = function(gameState)
+DELPHI.AttackPlan.prototype.trainMoreUnits = function(gameState)
 {
 	// let's sort by training advancement, ie 'current size / target size'
 	// count the number of queued units too.
@@ -625,7 +627,7 @@ PETRA.AttackPlan.prototype.trainMoreUnits = function(gameState)
 	{
 		// find the actual queue we want
 		let queue = this.queue;
-		if (MatchesClassList(firstOrder[3].classes, ["Siege", "Elephant+Melee+Champion"]))
+		if (MatchesClassList(firstOrder[3].classes, ["Siege"]))
 			queue = this.queueSiege;
 		else if (firstOrder[3].classes.indexOf("Hero") != -1)
 			queue = this.queueSiege;
@@ -652,7 +654,7 @@ PETRA.AttackPlan.prototype.trainMoreUnits = function(gameState)
 				let specialData = "Plan_" + this.name + "_" + firstOrder[4];
 				let data = { "plan": this.name, "special": specialData, "base": 0 };
 				data.role = gameState.getTemplate(template).hasClass("CitizenSoldier") ? "worker" : "attack";
-				let trainingPlan = new PETRA.TrainingPlan(gameState, template, data, max, max);
+				let trainingPlan = new DELPHI.TrainingPlan(gameState, template, data, max, max);
 				if (trainingPlan.template)
 					queue.addPlan(trainingPlan);
 				else if (this.Config.debug > 1)
@@ -663,7 +665,7 @@ PETRA.AttackPlan.prototype.trainMoreUnits = function(gameState)
 	}
 };
 
-PETRA.AttackPlan.prototype.assignUnits = function(gameState)
+DELPHI.AttackPlan.prototype.assignUnits = function(gameState)
 {
 	let plan = this.name;
 	let added = false;
@@ -739,8 +741,8 @@ PETRA.AttackPlan.prototype.assignUnits = function(gameState)
 			numbase[baseID] = numbase[baseID] ? ++numbase[baseID] : 1;
 		else
 		{
-			API3.warn("Petra problem ent without base ");
-			PETRA.dumpEntity(ent);
+			API3.warn("Delphi problem ent without base ");
+			DELPHI.dumpEntity(ent);
 			continue;
 		}
 		if (num++ < keep || numbase[baseID] < 5)
@@ -754,7 +756,7 @@ PETRA.AttackPlan.prototype.assignUnits = function(gameState)
 	return added;
 };
 
-PETRA.AttackPlan.prototype.isAvailableUnit = function(gameState, ent)
+DELPHI.AttackPlan.prototype.isAvailableUnit = function(gameState, ent)
 {
 	if (!ent.position())
 		return false;
@@ -767,7 +769,7 @@ PETRA.AttackPlan.prototype.isAvailableUnit = function(gameState, ent)
 };
 
 /** Reassign one (at each turn) FastMoving unit to fasten raid preparation. */
-PETRA.AttackPlan.prototype.reassignFastUnit = function(gameState)
+DELPHI.AttackPlan.prototype.reassignFastUnit = function(gameState)
 {
 	for (let ent of this.unitCollection.values())
 	{
@@ -783,7 +785,7 @@ PETRA.AttackPlan.prototype.reassignFastUnit = function(gameState)
 	}
 };
 
-PETRA.AttackPlan.prototype.chooseTarget = function(gameState)
+DELPHI.AttackPlan.prototype.chooseTarget = function(gameState)
 {
 	if (this.targetPlayer === undefined)
 	{
@@ -808,7 +810,7 @@ PETRA.AttackPlan.prototype.chooseTarget = function(gameState)
 	this.targetPos = this.target.position();
 	// redefine a new rally point for this target if we have a base on the same land
 	// find a new one on the pseudo-nearest base (dist weighted by the size of the island)
-	let targetIndex = PETRA.getLandAccess(gameState, this.target);
+	let targetIndex = DELPHI.getLandAccess(gameState, this.target);
 	let rallyIndex = gameState.ai.accessibility.getAccessValue(this.rallyPoint);
 	if (targetIndex != rallyIndex)
 	{
@@ -856,7 +858,7 @@ PETRA.AttackPlan.prototype.chooseTarget = function(gameState)
 			}
 			else
 			{
-				API3.warn("Petra: " + this.type + " " + this.name + " has an inaccessible target" +
+				API3.warn("Delphi: " + this.type + " " + this.name + " has an inaccessible target" +
 				          " with indices " + rallyIndex + " " + targetIndex + " from " + this.target.templateName());
 				return false;
 			}
@@ -870,7 +872,7 @@ PETRA.AttackPlan.prototype.chooseTarget = function(gameState)
 /**
  * sameLand true means that we look for a target for which we do not need to take a transport
  */
-PETRA.AttackPlan.prototype.getNearestTarget = function(gameState, position, sameLand)
+DELPHI.AttackPlan.prototype.getNearestTarget = function(gameState, position, sameLand)
 {
 	this.isBlocked = false;
 	// Temporary variables needed by isValidTarget
@@ -942,7 +944,7 @@ PETRA.AttackPlan.prototype.getNearestTarget = function(gameState, position, same
  * Default target finder aims for conquest critical targets
  * We must apply the *same* selection (isValidTarget) as done in getNearestTarget
  */
-PETRA.AttackPlan.prototype.defaultTargetFinder = function(gameState, playerEnemy)
+DELPHI.AttackPlan.prototype.defaultTargetFinder = function(gameState, playerEnemy)
 {
 	let targets = new API3.EntityCollection(gameState.sharedScript);
 	if (gameState.getVictoryConditions().has("wonder"))
@@ -975,17 +977,17 @@ PETRA.AttackPlan.prototype.defaultTargetFinder = function(gameState, playerEnemy
 	return targets;
 };
 
-PETRA.AttackPlan.prototype.isValidTarget = function(ent)
+DELPHI.AttackPlan.prototype.isValidTarget = function(ent)
 {
 	if (!ent.position())
 		return false;
-	if (this.sameLand && PETRA.getLandAccess(this.gameState, ent) != this.sameLand)
+	if (this.sameLand && DELPHI.getLandAccess(this.gameState, ent) != this.sameLand)
 		return false;
 	return !ent.decaying() || ent.getDefaultArrow() || ent.isGarrisonHolder() && ent.garrisoned().length;
 };
 
 /** Rush target finder aims at isolated non-defended buildings */
-PETRA.AttackPlan.prototype.rushTargetFinder = function(gameState, playerEnemy)
+DELPHI.AttackPlan.prototype.rushTargetFinder = function(gameState, playerEnemy)
 {
 	let targets = new API3.EntityCollection(gameState.sharedScript);
 	let buildings;
@@ -1041,7 +1043,7 @@ PETRA.AttackPlan.prototype.rushTargetFinder = function(gameState, playerEnemy)
 };
 
 /** Raid target finder aims at destructing foundations from which our defenseManager has attacked the builders */
-PETRA.AttackPlan.prototype.raidTargetFinder = function(gameState)
+DELPHI.AttackPlan.prototype.raidTargetFinder = function(gameState)
 {
 	let targets = new API3.EntityCollection(gameState.sharedScript);
 	for (let targetId of gameState.ai.HQ.defenseManager.targetList)
@@ -1058,9 +1060,9 @@ PETRA.AttackPlan.prototype.raidTargetFinder = function(gameState)
  * otherwise we may be blocked by walls and try to react accordingly
  * This is done only when attacker and target are on the same land
  */
-PETRA.AttackPlan.prototype.checkTargetObstruction = function(gameState, target, position)
+DELPHI.AttackPlan.prototype.checkTargetObstruction = function(gameState, target, position)
 {
-	if (PETRA.getLandAccess(gameState, target) != gameState.ai.accessibility.getAccessValue(position))
+	if (DELPHI.getLandAccess(gameState, target) != gameState.ai.accessibility.getAccessValue(position))
 		return target;
 
 	let targetPos = target.position();
@@ -1164,10 +1166,10 @@ PETRA.AttackPlan.prototype.checkTargetObstruction = function(gameState, target,
 	return target;
 };
 
-PETRA.AttackPlan.prototype.getPathToTarget = function(gameState, fixedRallyPoint = false)
+DELPHI.AttackPlan.prototype.getPathToTarget = function(gameState, fixedRallyPoint = false)
 {
 	let startAccess = gameState.ai.accessibility.getAccessValue(this.rallyPoint);
-	let endAccess = PETRA.getLandAccess(gameState, this.target);
+	let endAccess = DELPHI.getLandAccess(gameState, this.target);
 	if (startAccess != endAccess)
 		return false;
 
@@ -1190,7 +1192,7 @@ PETRA.AttackPlan.prototype.getPathToTarget = function(gameState, fixedRallyPoint
 };
 
 /** Set rally point at the border of our territory */
-PETRA.AttackPlan.prototype.setRallyPoint = function(gameState)
+DELPHI.AttackPlan.prototype.setRallyPoint = function(gameState)
 {
 	for (let i = 0; i < this.path.length; ++i)
 	{
@@ -1217,7 +1219,7 @@ PETRA.AttackPlan.prototype.setRallyPoint = function(gameState)
  * Executes the attack plan, after this is executed the update function will be run every turn
  * If we're here, it's because we have enough units.
  */
-PETRA.AttackPlan.prototype.StartAttack = function(gameState)
+DELPHI.AttackPlan.prototype.StartAttack = function(gameState)
 {
 	if (this.Config.debug > 1)
 		API3.warn("start attack " + this.name + " with type " + this.type);
@@ -1239,7 +1241,7 @@ PETRA.AttackPlan.prototype.StartAttack = function(gameState)
 	}
 
 	let rallyAccess = gameState.ai.accessibility.getAccessValue(this.rallyPoint);
-	let targetAccess = PETRA.getLandAccess(gameState, this.target);
+	let targetAccess = DELPHI.getLandAccess(gameState, this.target);
 	if (rallyAccess == targetAccess)
 	{
 		if (!this.path)
@@ -1265,7 +1267,7 @@ PETRA.AttackPlan.prototype.StartAttack = function(gameState)
 };
 
 /** Runs every turn after the attack is executed */
-PETRA.AttackPlan.prototype.update = function(gameState, events)
+DELPHI.AttackPlan.prototype.update = function(gameState, events)
 {
 	if (!this.unitCollection.hasEntities())
 		return 0;
@@ -1330,24 +1332,24 @@ PETRA.AttackPlan.prototype.update = function(gameState, events)
 				attackedByStructure[evt.target] = true;
 				continue;
 			}
-			if (PETRA.isSiegeUnit(ourUnit))
+			if (DELPHI.isSiegeUnit(ourUnit))
 			{	// if our siege units are attacked, we'll send some units to deal with enemies.
 				let collec = this.unitCollection.filter(API3.Filters.not(API3.Filters.byClass("Siege"))).filterNearest(ourUnit.position(), 5);
 				for (let ent of collec.values())
 				{
-					if (PETRA.isSiegeUnit(ent))	// needed as mauryan elephants are not filtered out
+					if (DELPHI.isSiegeUnit(ent))	// needed as mauryan elephants are not filtered out
 						continue;
 
-					let allowCapture = PETRA.allowCapture(gameState, ent, attacker);
+					let allowCapture = DELPHI.allowCapture(gameState, ent, attacker);
 					if (!ent.canAttackTarget(attacker, allowCapture))
 						continue;
 					ent.attack(attacker.id(), allowCapture);
 					ent.setMetadata(PlayerID, "lastAttackPlanUpdateTime", time);
 				}
 				// And if this attacker is a non-ranged siege unit and our unit also, attack it
-				if (PETRA.isSiegeUnit(attacker) && attacker.hasClass("Melee") && ourUnit.hasClass("Melee") && ourUnit.canAttackTarget(attacker, PETRA.allowCapture(gameState, ourUnit, attacker)))
+				if (DELPHI.isSiegeUnit(attacker) && attacker.hasClass("Melee") && ourUnit.hasClass("Melee") && ourUnit.canAttackTarget(attacker, DELPHI.allowCapture(gameState, ourUnit, attacker)))
 				{
-					ourUnit.attack(attacker.id(), PETRA.allowCapture(gameState, ourUnit, attacker));
+					ourUnit.attack(attacker.id(), DELPHI.allowCapture(gameState, ourUnit, attacker));
 					ourUnit.setMetadata(PlayerID, "lastAttackPlanUpdateTime", time);
 				}
 			}
@@ -1359,12 +1361,12 @@ PETRA.AttackPlan.prototype.update = function(gameState, events)
 					// TODO check that the attacker is from behind the wall
 					continue;
 				}
-				else if (PETRA.isSiegeUnit(attacker))
+				else if (DELPHI.isSiegeUnit(attacker))
 				{	// if our unit is attacked by a siege unit, we'll send some melee units to help it.
 					let collec = this.unitCollection.filter(API3.Filters.byClass("Melee")).filterNearest(ourUnit.position(), 5);
 					for (let ent of collec.values())
 					{
-						let allowCapture = PETRA.allowCapture(gameState, ent, attacker);
+						let allowCapture = DELPHI.allowCapture(gameState, ent, attacker);
 						if (!ent.canAttackTarget(attacker, allowCapture))
 							continue;
 						ent.attack(attacker.id(), allowCapture);
@@ -1377,8 +1379,8 @@ PETRA.AttackPlan.prototype.update = function(gameState, events)
 					let collec = this.unitCollection.filterNearest(ourUnit.position(), 2);
 					for (let ent of collec.values())
 					{
-						let allowCapture = PETRA.allowCapture(gameState, ent, attacker);
-						if (PETRA.isSiegeUnit(ent) || !ent.canAttackTarget(attacker, allowCapture))
+						let allowCapture = DELPHI.allowCapture(gameState, ent, attacker);
+						if (DELPHI.isSiegeUnit(ent) || !ent.canAttackTarget(attacker, allowCapture))
 							continue;
 						let orderData = ent.unitAIOrderData();
 						if (orderData && orderData.length && orderData[0].target)
@@ -1406,7 +1408,7 @@ PETRA.AttackPlan.prototype.update = function(gameState, events)
 								continue;
 						}
 					}
-					let allowCapture = PETRA.allowCapture(gameState, ourUnit, attacker);
+					let allowCapture = DELPHI.allowCapture(gameState, ourUnit, attacker);
 					if (ourUnit.canAttackTarget(attacker, allowCapture))
 					{
 						ourUnit.attack(attacker.id(), allowCapture);
@@ -1434,7 +1436,7 @@ PETRA.AttackPlan.prototype.update = function(gameState, events)
 				continue;
 			if (!(targetId in unitTargets))
 			{
-				if (PETRA.isSiegeUnit(target) || target.hasClass("Hero"))
+				if (DELPHI.isSiegeUnit(target) || target.hasClass("Hero"))
 					unitTargets[targetId] = -8;
 				else if (target.hasClasses(["Champion", "Ship"]))
 					unitTargets[targetId] = -5;
@@ -1495,7 +1497,7 @@ PETRA.AttackPlan.prototype.update = function(gameState, events)
 			// update the order if needed
 			let needsUpdate = false;
 			let maybeUpdate = false;
-			let siegeUnit = PETRA.isSiegeUnit(ent);
+			let siegeUnit = DELPHI.isSiegeUnit(ent);
 			if (ent.isIdle())
 				needsUpdate = true;
 			else if (siegeUnit && targetId)
@@ -1557,18 +1559,18 @@ PETRA.AttackPlan.prototype.update = function(gameState, events)
 			else if (ent.hasClass("FastMoving"))
 				range += 30;
 			range *= range;
-			let entAccess = PETRA.getLandAccess(gameState, ent);
+			let entAccess = DELPHI.getLandAccess(gameState, ent);
 			// Checking for gates if we're a siege unit.
 			if (siegeUnit)
 			{
 				let mStruct = enemyStructures.filter(enemy => {
-					if (!enemy.position() || !ent.canAttackTarget(enemy, PETRA.allowCapture(gameState, ent, enemy)))
+					if (!enemy.position() || !ent.canAttackTarget(enemy, DELPHI.allowCapture(gameState, ent, enemy)))
 						return false;
 					if (API3.SquareVectorDistance(enemy.position(), ent.position()) > range)
 						return false;
 					if (enemy.foundationProgress() == 0)
 						return false;
-					if (PETRA.getLandAccess(gameState, enemy) != entAccess)
+					if (DELPHI.getLandAccess(gameState, enemy) != entAccess)
 						return false;
 					return true;
 				}).toEntityArray();
@@ -1592,11 +1594,11 @@ PETRA.AttackPlan.prototype.update = function(gameState, events)
 						return valb - vala;
 					});
 					if (mStruct[0].hasClass("Gate"))
-						ent.attack(mStruct[0].id(), PETRA.allowCapture(gameState, ent, mStruct[0]));
+						ent.attack(mStruct[0].id(), DELPHI.allowCapture(gameState, ent, mStruct[0]));
 					else
 					{
 						let rand = randIntExclusive(0, mStruct.length * 0.2);
-						ent.attack(mStruct[rand].id(), PETRA.allowCapture(gameState, ent, mStruct[rand]));
+						ent.attack(mStruct[rand].id(), DELPHI.allowCapture(gameState, ent, mStruct[rand]));
 					}
 				}
 				else
@@ -1614,7 +1616,7 @@ PETRA.AttackPlan.prototype.update = function(gameState, events)
 			{
 				const nearby = !ent.hasClasses(["FastMoving", "Ranged"]);
 				let mUnit = enemyUnits.filter(enemy => {
-					if (!enemy.position() || !ent.canAttackTarget(enemy, PETRA.allowCapture(gameState, ent, enemy)))
+					if (!enemy.position() || !ent.canAttackTarget(enemy, DELPHI.allowCapture(gameState, ent, enemy)))
 						return false;
 					if (enemy.hasClass("Animal"))
 						return false;
@@ -1623,7 +1625,7 @@ PETRA.AttackPlan.prototype.update = function(gameState, events)
 					let dist = API3.SquareVectorDistance(enemy.position(), ent.position());
 					if (dist > range)
 						return false;
-					if (PETRA.getLandAccess(gameState, enemy) != entAccess)
+					if (DELPHI.getLandAccess(gameState, enemy) != entAccess)
 						return false;
 					// if already too much units targeting this enemy, let's continue towards our main target
 					if (veto[enemy.id()] && API3.SquareVectorDistance(this.targetPos, ent.position()) > 2500)
@@ -1654,7 +1656,7 @@ PETRA.AttackPlan.prototype.update = function(gameState, events)
 						return valb - vala;
 					});
 					let rand = randIntExclusive(0, mUnit.length * 0.1);
-					ent.attack(mUnit[rand].id(), PETRA.allowCapture(gameState, ent, mUnit[rand]));
+					ent.attack(mUnit[rand].id(), DELPHI.allowCapture(gameState, ent, mUnit[rand]));
 				}
 				// This may prove dangerous as we may be blocked by something we
 				// cannot attack. See similar behaviour at #5741.
@@ -1679,11 +1681,11 @@ PETRA.AttackPlan.prototype.update = function(gameState, events)
 					let mStruct = enemyStructures.filter(enemy => {
 						if (this.isBlocked && enemy.id() != this.target.id())
 							return false;
-						if (!enemy.position() || !ent.canAttackTarget(enemy, PETRA.allowCapture(gameState, ent, enemy)))
+						if (!enemy.position() || !ent.canAttackTarget(enemy, DELPHI.allowCapture(gameState, ent, enemy)))
 							return false;
 						if (API3.SquareVectorDistance(enemy.position(), ent.position()) > range)
 							return false;
-						if (PETRA.getLandAccess(gameState, enemy) != entAccess)
+						if (DELPHI.getLandAccess(gameState, enemy) != entAccess)
 							return false;
 						return true;
 					}, this).toEntityArray();
@@ -1707,7 +1709,7 @@ PETRA.AttackPlan.prototype.update = function(gameState, events)
 						else
 						{
 							let rand = randIntExclusive(0, mStruct.length * 0.2);
-							ent.attack(mStruct[rand].id(), PETRA.allowCapture(gameState, ent, mStruct[rand]));
+							ent.attack(mStruct[rand].id(), DELPHI.allowCapture(gameState, ent, mStruct[rand]));
 						}
 					}
 					else if (needsUpdate)  // really nothing   let's try to help our nearest unit
@@ -1727,12 +1729,12 @@ PETRA.AttackPlan.prototype.update = function(gameState, events)
 							if (dist > distmin)
 								return;
 							distmin = dist;
-							if (!ent.canAttackTarget(target, PETRA.allowCapture(gameState, ent, target)))
+							if (!ent.canAttackTarget(target, DELPHI.allowCapture(gameState, ent, target)))
 								return;
 							attacker = target;
 						});
 						if (attacker)
-							ent.attack(attacker.id(), PETRA.allowCapture(gameState, ent, attacker));
+							ent.attack(attacker.id(), DELPHI.allowCapture(gameState, ent, attacker));
 					}
 				}
 			}
@@ -1750,7 +1752,7 @@ PETRA.AttackPlan.prototype.update = function(gameState, events)
 	return this.unitCollection.length;
 };
 
-PETRA.AttackPlan.prototype.UpdateTransporting = function(gameState, events)
+DELPHI.AttackPlan.prototype.UpdateTransporting = function(gameState, events)
 {
 	let done = true;
 	for (let ent of this.unitCollection.values())
@@ -1784,7 +1786,7 @@ PETRA.AttackPlan.prototype.UpdateTransporting = function(gameState, events)
 			if (ent.getMetadata(PlayerID, "transport") !== undefined)
 				continue;
 
-			let allowCapture = PETRA.allowCapture(gameState, ent, attacker);
+			let allowCapture = DELPHI.allowCapture(gameState, ent, attacker);
 			if (!ent.isIdle() || !ent.canAttackTarget(attacker, allowCapture))
 				continue;
 			ent.attack(attacker.id(), allowCapture);
@@ -1793,7 +1795,7 @@ PETRA.AttackPlan.prototype.UpdateTransporting = function(gameState, events)
 	}
 };
 
-PETRA.AttackPlan.prototype.UpdateWalking = function(gameState, events)
+DELPHI.AttackPlan.prototype.UpdateWalking = function(gameState, events)
 {
 	// we're marching towards the target
 	// Let's check if any of our unit has been attacked.
@@ -1896,7 +1898,7 @@ PETRA.AttackPlan.prototype.UpdateWalking = function(gameState, events)
 	return true;
 };
 
-PETRA.AttackPlan.prototype.UpdateTarget = function(gameState)
+DELPHI.AttackPlan.prototype.UpdateTarget = function(gameState)
 {
 	// First update the target position in case it's a unit (and check if it has garrisoned)
 	if (this.target && this.target.hasClass("Unit"))
@@ -1904,7 +1906,7 @@ PETRA.AttackPlan.prototype.UpdateTarget = function(gameState)
 		this.targetPos = this.target.position();
 		if (!this.targetPos)
 		{
-			let holder = PETRA.getHolder(gameState, this.target);
+			let holder = DELPHI.getHolder(gameState, this.target);
 			if (holder && gameState.isPlayerEnemy(holder.owner()))
 			{
 				this.target = holder;
@@ -1949,7 +1951,7 @@ PETRA.AttackPlan.prototype.UpdateTarget = function(gameState)
 					if (!attack.target || !gameState.getEntityById(attack.target.id()) ||
 					    !gameState.isPlayerEnemy(attack.target.owner()))
 						continue;
-					if (accessIndex != PETRA.getLandAccess(gameState, attack.target))
+					if (accessIndex != DELPHI.getLandAccess(gameState, attack.target))
 						continue;
 					if (attack.target.owner() == 0 && attack.targetPlayer != 0)	// looks like it has resigned
 						continue;
@@ -1984,7 +1986,7 @@ PETRA.AttackPlan.prototype.UpdateTarget = function(gameState)
 };
 
 /** reset any units */
-PETRA.AttackPlan.prototype.Abort = function(gameState)
+DELPHI.AttackPlan.prototype.Abort = function(gameState)
 {
 	this.unitCollection.unregister();
 	if (this.unitCollection.hasEntities())
@@ -2005,7 +2007,7 @@ PETRA.AttackPlan.prototype.Abort = function(gameState)
 			{
 				if (!base.anchor || !base.anchor.position())
 					continue;
-				if (PETRA.getLandAccess(gameState, base.anchor) != access)
+				if (DELPHI.getLandAccess(gameState, base.anchor) != access)
 					continue;
 				let newdist = API3.SquareVectorDistance(this.position, base.anchor.position());
 				if (newdist > dist)
@@ -2031,7 +2033,7 @@ PETRA.AttackPlan.prototype.Abort = function(gameState)
 	this.removeQueues(gameState);
 };
 
-PETRA.AttackPlan.prototype.removeUnit = function(ent, update)
+DELPHI.AttackPlan.prototype.removeUnit = function(ent, update)
 {
 	if (ent.getMetadata(PlayerID, "role") == "attack")
 	{
@@ -2046,7 +2048,7 @@ PETRA.AttackPlan.prototype.removeUnit = function(ent, update)
 		this.unitCollection.updateEnt(ent);
 };
 
-PETRA.AttackPlan.prototype.checkEvents = function(gameState, events)
+DELPHI.AttackPlan.prototype.checkEvents = function(gameState, events)
 {
 	for (let evt of events.EntityRenamed)
 	{
@@ -2082,7 +2084,7 @@ PETRA.AttackPlan.prototype.checkEvents = function(gameState, events)
 			continue;
 		if (!gameState.isPlayerEnemy(ent.owner()))
 			continue;
-		let access = PETRA.getLandAccess(gameState, ent);
+		let access = DELPHI.getLandAccess(gameState, ent);
 		for (let base of gameState.ai.HQ.baseManagers)
 		{
 			if (!base.anchor || !base.anchor.position())
@@ -2095,7 +2097,7 @@ PETRA.AttackPlan.prototype.checkEvents = function(gameState, events)
 	}
 };
 
-PETRA.AttackPlan.prototype.waitingForTransport = function()
+DELPHI.AttackPlan.prototype.waitingForTransport = function()
 {
 	for (let ent of this.unitCollection.values())
 		if (ent.getMetadata(PlayerID, "transport") !== undefined)
@@ -2103,15 +2105,15 @@ PETRA.AttackPlan.prototype.waitingForTransport = function()
 	return false;
 };
 
-PETRA.AttackPlan.prototype.hasSiegeUnits = function()
+DELPHI.AttackPlan.prototype.hasSiegeUnits = function()
 {
 	for (let ent of this.unitCollection.values())
-		if (PETRA.isSiegeUnit(ent))
+		if (DELPHI.isSiegeUnit(ent))
 			return true;
 	return false;
 };
 
-PETRA.AttackPlan.prototype.hasForceOrder = function(data, value)
+DELPHI.AttackPlan.prototype.hasForceOrder = function(data, value)
 {
 	for (let ent of this.unitCollection.values())
 	{
@@ -2129,15 +2131,15 @@ PETRA.AttackPlan.prototype.hasForceOrder = function(data, value)
  * The center position of this attack may be in an inaccessible area. So we use the access
  * of the unit nearest to this center position.
  */
-PETRA.AttackPlan.prototype.getAttackAccess = function(gameState)
+DELPHI.AttackPlan.prototype.getAttackAccess = function(gameState)
 {
 	for (let ent of this.unitCollection.filterNearest(this.position, 1).values())
-		return PETRA.getLandAccess(gameState, ent);
+		return DELPHI.getLandAccess(gameState, ent);
 
 	return 0;
 };
 
-PETRA.AttackPlan.prototype.debugAttack = function()
+DELPHI.AttackPlan.prototype.debugAttack = function()
 {
 	API3.warn("---------- attack " + this.name);
 	for (let unitCat in this.unitStat)
@@ -2148,7 +2150,7 @@ PETRA.AttackPlan.prototype.debugAttack = function()
 	API3.warn("------------------------------");
 };
 
-PETRA.AttackPlan.prototype.Serialize = function()
+DELPHI.AttackPlan.prototype.Serialize = function()
 {
 	let properties = {
 		"name": this.name,
@@ -2176,7 +2178,7 @@ PETRA.AttackPlan.prototype.Serialize = function()
 	return { "properties": properties };
 };
 
-PETRA.AttackPlan.prototype.Deserialize = function(gameState, data)
+DELPHI.AttackPlan.prototype.Deserialize = function(gameState, data)
 {
 	for (let key in data.properties)
 		this[key] = data.properties[key];
diff --git a/binaries/data/mods/public/simulation/ai/delphi/baseManager.js b/binaries/data/mods/public/simulation/ai/delphi/baseManager.js
index b7380f9cdf..24d8975896 100644
--- a/binaries/data/mods/public/simulation/ai/delphi/baseManager.js
+++ b/binaries/data/mods/public/simulation/ai/delphi/baseManager.js
@@ -10,7 +10,7 @@
  *  -updating whatever needs updating, keeping track of stuffs (rebuilding needs)
  */
 
-PETRA.BaseManager = function(gameState, Config)
+DELPHI.BaseManager = function(gameState, Config)
 {
 	this.Config = Config;
 	this.ID = gameState.ai.uniqueIDs.bases++;
@@ -34,13 +34,13 @@ PETRA.BaseManager = function(gameState, Config)
 	this.timeNextIdleCheck = 0;
 };
 
-PETRA.BaseManager.prototype.init = function(gameState, state)
+DELPHI.BaseManager.prototype.init = function(gameState, state)
 {
 	if (state == "unconstructed")
 		this.constructing = true;
 	else if (state != "captured")
 		this.neededDefenders = 0;
-	this.workerObject = new PETRA.Worker(this);
+	this.workerObject = new DELPHI.Worker(this);
 	// entitycollections
 	this.units = gameState.getOwnUnits().filter(API3.Filters.byMetadata(PlayerID, "base", this.ID));
 	this.workers = this.units.filter(API3.Filters.byMetadata(PlayerID, "role", "worker"));
@@ -63,7 +63,7 @@ PETRA.BaseManager.prototype.init = function(gameState, state)
 	}
 };
 
-PETRA.BaseManager.prototype.reset = function(gameState, state)
+DELPHI.BaseManager.prototype.reset = function(gameState, state)
 {
 	if (state == "unconstructed")
 		this.constructing = true;
@@ -76,7 +76,7 @@ PETRA.BaseManager.prototype.reset = function(gameState, state)
 		this.neededDefenders = 3 + 2 * (this.Config.difficulty - 3);
 };
 
-PETRA.BaseManager.prototype.assignEntity = function(gameState, ent)
+DELPHI.BaseManager.prototype.assignEntity = function(gameState, ent)
 {
 	ent.setMetadata(PlayerID, "base", this.ID);
 	this.units.updateEnt(ent);
@@ -86,10 +86,10 @@ PETRA.BaseManager.prototype.assignEntity = function(gameState, ent)
 		this.assignResourceToDropsite(gameState, ent);
 };
 
-PETRA.BaseManager.prototype.setAnchor = function(gameState, anchorEntity)
+DELPHI.BaseManager.prototype.setAnchor = function(gameState, anchorEntity)
 {
 	if (!anchorEntity.hasClass("CivCentre"))
-		API3.warn("Error: Petra base " + this.ID + " has been assigned " + ent.templateName() + " as anchor.");
+		API3.warn("Error: Delphi base " + this.ID + " has been assigned " + ent.templateName() + " as anchor.");
 	else
 	{
 		this.anchor = anchorEntity;
@@ -99,12 +99,12 @@ PETRA.BaseManager.prototype.setAnchor = function(gameState, anchorEntity)
 	}
 	anchorEntity.setMetadata(PlayerID, "base", this.ID);
 	this.buildings.updateEnt(anchorEntity);
-	this.accessIndex = PETRA.getLandAccess(gameState, anchorEntity);
+	this.accessIndex = DELPHI.getLandAccess(gameState, anchorEntity);
 	return true;
 };
 
 /* we lost our anchor. Let's reassign our units and buildings */
-PETRA.BaseManager.prototype.anchorLost = function(gameState, ent)
+DELPHI.BaseManager.prototype.anchorLost = function(gameState, ent)
 {
 	this.anchor = undefined;
 	this.anchorId = undefined;
@@ -113,17 +113,17 @@ PETRA.BaseManager.prototype.anchorLost = function(gameState, ent)
 };
 
 /** Set a building of an anchorless base */
-PETRA.BaseManager.prototype.setAnchorlessEntity = function(gameState, ent)
+DELPHI.BaseManager.prototype.setAnchorlessEntity = function(gameState, ent)
 {
 	if (!this.buildings.hasEntities())
 	{
-		if (!PETRA.getBuiltEntity(gameState, ent).resourceDropsiteTypes())
-			API3.warn("Error: Petra base " + this.ID + " has been assigned " + ent.templateName() + " as origin.");
-		this.accessIndex = PETRA.getLandAccess(gameState, ent);
+		if (!DELPHI.getBuiltEntity(gameState, ent).resourceDropsiteTypes())
+			API3.warn("Error: Delphi base " + this.ID + " has been assigned " + ent.templateName() + " as origin.");
+		this.accessIndex = DELPHI.getLandAccess(gameState, ent);
 	}
-	else if (this.accessIndex != PETRA.getLandAccess(gameState, ent))
-		API3.warn(" Error: Petra base " + this.ID + " with access " + this.accessIndex +
-		          " has been assigned " + ent.templateName() + " with access" + PETRA.getLandAccess(gameState, ent));
+	else if (this.accessIndex != DELPHI.getLandAccess(gameState, ent))
+		API3.warn(" Error: Delphi base " + this.ID + " with access " + this.accessIndex +
+		          " has been assigned " + ent.templateName() + " with access" + DELPHI.getLandAccess(gameState, ent));
 
 	ent.setMetadata(PlayerID, "base", this.ID);
 	this.buildings.updateEnt(ent);
@@ -134,7 +134,7 @@ PETRA.BaseManager.prototype.setAnchorlessEntity = function(gameState, ent)
  * Assign the resources around the dropsites of this basis in three areas according to distance, and sort them in each area.
  * Moving resources (animals) and buildable resources (fields) are treated elsewhere.
  */
-PETRA.BaseManager.prototype.assignResourceToDropsite = function(gameState, dropsite)
+DELPHI.BaseManager.prototype.assignResourceToDropsite = function(gameState, dropsite)
 {
 	if (this.dropsites[dropsite.id()])
 	{
@@ -149,7 +149,7 @@ PETRA.BaseManager.prototype.assignResourceToDropsite = function(gameState, drops
 	this.dropsites[dropsiteId] = true;
 
 	if (this.ID == gameState.ai.HQ.baseManagers[0].ID)
-		accessIndex = PETRA.getLandAccess(gameState, dropsite);
+		accessIndex = DELPHI.getLandAccess(gameState, dropsite);
 
 	let maxDistResourceSquare = this.maxDistResourceSquare;
 	for (let type of dropsite.resourceDropsiteTypes())
@@ -170,7 +170,7 @@ PETRA.BaseManager.prototype.assignResourceToDropsite = function(gameState, drops
 			if (supply.hasClasses(["Animal", "Field"]))
 				return;
 			// quick accessibility check
-			if (PETRA.getLandAccess(gameState, supply) != accessIndex)
+			if (DELPHI.getLandAccess(gameState, supply) != accessIndex)
 				return;
 
 			let dist = API3.SquareVectorDistance(supply.position(), dropsitePos);
@@ -216,7 +216,7 @@ PETRA.BaseManager.prototype.assignResourceToDropsite = function(gameState, drops
 };
 
 // completely remove the dropsite resources from our list.
-PETRA.BaseManager.prototype.removeDropsite = function(gameState, ent)
+DELPHI.BaseManager.prototype.removeDropsite = function(gameState, ent)
 {
 	if (!ent.id())
 		return;
@@ -244,10 +244,9 @@ PETRA.BaseManager.prototype.removeDropsite = function(gameState, ent)
 };
 
 /**
- * @return {Object} - The position of the best place to build a new dropsite for the specified resource,
- *			its quality and its template name.
+ * Returns the position of the best place to build a new dropsite for the specified resource
  */
-PETRA.BaseManager.prototype.findBestDropsiteAndLocation = function(gameState, resource)
+DELPHI.BaseManager.prototype.findBestDropsiteAndLocation = function(gameState, resource)
 {
 	let bestResult = {
 		"quality": 0,
@@ -267,7 +266,7 @@ PETRA.BaseManager.prototype.findBestDropsiteAndLocation = function(gameState, re
 /**
  * Returns the position of the best place to build a new dropsite for the specified resource and dropsite template.
  */
-PETRA.BaseManager.prototype.findBestDropsiteLocation = function(gameState, resource, templateName)
+DELPHI.BaseManager.prototype.findBestDropsiteLocation = function(gameState, resource, templateName)
 {
 	const template = gameState.getTemplate(gameState.applyCiv(templateName));
 
@@ -275,6 +274,7 @@ PETRA.BaseManager.prototype.findBestDropsiteLocation = function(gameState, resou
 	if (template.hasClasses(["CivCentre", "Dock"]))
 		return { "quality": 0, "pos": [0, 0] };
 
+	let template = gameState.getTemplate(gameState.applyCiv("structures/{civ}/storehouse"));
 	let halfSize = 0;
 	if (template.get("Footprint/Square"))
 		halfSize = Math.max(+template.get("Footprint/Square/@depth"), +template.get("Footprint/Square/@width")) / 2;
@@ -286,14 +286,10 @@ PETRA.BaseManager.prototype.findBestDropsiteLocation = function(gameState, resou
 	// Then checks for a good spot in the territory. If none, and town/city phase, checks outside
 	// The AI will currently not build a CC if it wouldn't connect with an existing CC.
 
-	let obstructions = PETRA.createObstructionMap(gameState, this.accessIndex, template);
+	let obstructions = DELPHI.createObstructionMap(gameState, this.accessIndex, template);
 
-	const dpEnts = gameState.getOwnStructures().filter(API3.Filters.isDropsite(resource)).toEntityArray();
-
-	// Foundations don't have the dropsite properties yet, so treat them separately.
-	for (const foundation of gameState.getOwnFoundations().toEntityArray())
-		if (PETRA.getBuiltEntity(gameState, foundation).isResourceDropsite(resource))
-			dpEnts.push(foundation);
+	let ccEnts = gameState.getOwnStructures().filter(API3.Filters.byClass("CivCentre")).toEntityArray();
+	let dpEnts = gameState.getOwnStructures().filter(API3.Filters.byClassesOr(["Storehouse", "Dock"])).toEntityArray();
 
 	let bestIdx;
 	let bestVal = 0;
@@ -303,18 +299,16 @@ PETRA.BaseManager.prototype.findBestDropsiteLocation = function(gameState, resou
 	let width = territoryMap.width;
 	let cellSize = territoryMap.cellSize;
 
-	const droppableResources = template.resourceDropsiteTypes();
-
 	for (let j of this.territoryIndices)
 	{
 		let i = territoryMap.getNonObstructedTile(j, radius, obstructions);
 		if (i < 0)  // no room around
 			continue;
 
-		// We add 3 times the needed resource and once others that can be dropped here.
-		let total = 2 * gameState.sharedScript.resourceMaps[resource].map[j];
-		for (const res in gameState.sharedScript.resourceMaps)
-			if (droppableResources.indexOf(res) != -1)
+		// we add 3 times the needed resource and once the others (except food)
+		let total = 2*gameState.sharedScript.resourceMaps[resource].map[j];
+		for (let res in gameState.sharedScript.resourceMaps)
+			if (res != "food")
 				total += gameState.sharedScript.resourceMaps[res].map[j];
 
 		total *= 0.7;   // Just a normalisation factor as the locateMap is limited to 255
@@ -340,6 +334,22 @@ PETRA.BaseManager.prototype.findBestDropsiteLocation = function(gameState, resou
 		if (total <= bestVal)
 			continue;
 
+		for (let cc of ccEnts)
+		{
+			let ccPos = cc.position();
+			if (!ccPos)
+				continue;
+			let dist = API3.SquareVectorDistance(ccPos, pos);
+			if (dist < 3600)
+			{
+				total = 0;
+				break;
+			}
+			else if (dist < 6400)
+				total *= (Math.sqrt(dist)-60)/20;
+		}
+		if (total <= bestVal)
+			continue;
 		if (gameState.ai.HQ.isDangerousLocation(gameState, pos, halfSize))
 			continue;
 		bestVal = total;
@@ -357,7 +367,7 @@ PETRA.BaseManager.prototype.findBestDropsiteLocation = function(gameState, resou
 	return { "quality": bestVal, "pos": [x, z] };
 };
 
-PETRA.BaseManager.prototype.getResourceLevel = function(gameState, type, nearbyOnly = false)
+DELPHI.BaseManager.prototype.getResourceLevel = function(gameState, type, nearbyOnly = false)
 {
 	let count = 0;
 	let check = {};
@@ -382,7 +392,7 @@ PETRA.BaseManager.prototype.getResourceLevel = function(gameState, type, nearbyO
 };
 
 /** check our resource levels and react accordingly */
-PETRA.BaseManager.prototype.checkResourceLevels = function(gameState, queues)
+DELPHI.BaseManager.prototype.checkResourceLevels = function(gameState, queues)
 {
 	for (let type of Resources.GetCodes())
 	{
@@ -399,7 +409,7 @@ PETRA.BaseManager.prototype.checkResourceLevels = function(gameState, queues)
 				{
 					if (count < 600)
 					{
-						queues.field.addPlan(new PETRA.ConstructionPlan(gameState, "structures/{civ}/field", { "favoredBase": this.ID }));
+						queues.field.addPlan(new DELPHI.ConstructionPlan(gameState, "structures/{civ}/field", { "favoredBase": this.ID }));
 						gameState.ai.HQ.needFarm = true;
 					}
 				}
@@ -410,11 +420,11 @@ PETRA.BaseManager.prototype.checkResourceLevels = function(gameState, queues)
 					if (gameState.ai.HQ.saveResources || gameState.ai.HQ.saveSpace || count > 300 || numFarms > 5)
 						goal = Math.max(goal-1, 1);
 					if (numFound + numQueue < goal)
-						queues.field.addPlan(new PETRA.ConstructionPlan(gameState, "structures/{civ}/field", { "favoredBase": this.ID }));
+						queues.field.addPlan(new DELPHI.ConstructionPlan(gameState, "structures/{civ}/field", { "favoredBase": this.ID }));
 				}
 				else if (gameState.ai.HQ.needCorral && !gameState.getOwnEntitiesByClass("Corral", true).hasEntities() &&
 				         !queues.corral.hasQueuedUnits() && gameState.ai.HQ.canBuild(gameState, "structures/{civ}/corral"))
-					queues.corral.addPlan(new PETRA.ConstructionPlan(gameState, "structures/{civ}/corral", { "favoredBase": this.ID }));
+					queues.corral.addPlan(new DELPHI.ConstructionPlan(gameState, "structures/{civ}/corral", { "favoredBase": this.ID }));
 				continue;
 			}
 			if (!gameState.getOwnEntitiesByClass("Corral", true).hasEntities() &&
@@ -423,7 +433,7 @@ PETRA.BaseManager.prototype.checkResourceLevels = function(gameState, queues)
 				let count = this.getResourceLevel(gameState, type, gameState.currentPhase() > 1);  // animals are not accounted
 				if (count < 900)
 				{
-					queues.corral.addPlan(new PETRA.ConstructionPlan(gameState, "structures/{civ}/corral", { "favoredBase": this.ID }));
+					queues.corral.addPlan(new DELPHI.ConstructionPlan(gameState, "structures/{civ}/corral", { "favoredBase": this.ID }));
 					gameState.ai.HQ.needCorral = true;
 				}
 			}
@@ -454,17 +464,17 @@ PETRA.BaseManager.prototype.checkResourceLevels = function(gameState, queues)
 			let ratio = this.gatherers[type].lost / total;
 			if (ratio > 0.15)
 			{
-				const newDP = this.findBestDropsiteAndLocation(gameState, type);
-				if (newDP.quality > 50 && gameState.ai.HQ.canBuild(gameState, newDP.templateName))
-					queues.dropsites.addPlan(new PETRA.ConstructionPlan(gameState, newDP.templateName, { "base": this.ID, "type": type }, newDP.pos));
+				let newDP = this.findBestDropsiteLocation(gameState, type);
+				if (newDP.quality > 50 && gameState.ai.HQ.canBuild(gameState, "structures/{civ}/storehouse"))
+					queues.dropsites.addPlan(new DELPHI.ConstructionPlan(gameState, "structures/{civ}/storehouse", { "base": this.ID, "type": type }, newDP.pos));
 				else if (!gameState.getOwnFoundations().filter(API3.Filters.byClass("CivCentre")).hasEntities() && !queues.civilCentre.hasQueuedUnits())
 				{
 					// No good dropsite, try to build a new base if no base already planned,
 					// and if not possible, be less strict on dropsite quality.
 					if ((!gameState.ai.HQ.canExpand || !gameState.ai.HQ.buildNewBase(gameState, queues, type)) &&
 					    newDP.quality > Math.min(25, 50*0.15/ratio) &&
-					    gameState.ai.HQ.canBuild(gameState, newDP.templateName))
-						queues.dropsites.addPlan(new PETRA.ConstructionPlan(gameState, newDP.templateName, { "base": this.ID, "type": type }, newDP.pos));
+					    gameState.ai.HQ.canBuild(gameState, "structures/{civ}/storehouse"))
+						queues.dropsites.addPlan(new DELPHI.ConstructionPlan(gameState, "structures/{civ}/storehouse", { "base": this.ID, "type": type }, newDP.pos));
 				}
 			}
 			this.gatherers[type].nextCheck = gameState.ai.playedTurn + 20;
@@ -478,7 +488,7 @@ PETRA.BaseManager.prototype.checkResourceLevels = function(gameState, queues)
 };
 
 /** Adds the estimated gather rates from this base to the currentRates */
-PETRA.BaseManager.prototype.addGatherRates = function(gameState, currentRates)
+DELPHI.BaseManager.prototype.addGatherRates = function(gameState, currentRates)
 {
 	for (let res in currentRates)
 	{
@@ -515,7 +525,7 @@ PETRA.BaseManager.prototype.addGatherRates = function(gameState, currentRates)
 	}
 };
 
-PETRA.BaseManager.prototype.assignRolelessUnits = function(gameState, roleless)
+DELPHI.BaseManager.prototype.assignRolelessUnits = function(gameState, roleless)
 {
 	if (!roleless)
 		roleless = this.units.filter(API3.Filters.not(API3.Filters.byHasMetadata(PlayerID, "role"))).values();
@@ -532,7 +542,7 @@ PETRA.BaseManager.prototype.assignRolelessUnits = function(gameState, roleless)
  * they can be reassigned by reassignIdleWorkers.
  * TODO: actually this probably should be in the HQ.
  */
-PETRA.BaseManager.prototype.setWorkersIdleByPriority = function(gameState)
+DELPHI.BaseManager.prototype.setWorkersIdleByPriority = function(gameState)
 {
 	this.timeNextIdleCheck = gameState.ai.elapsedTime + 8;
 	// change resource only towards one which is more needed, and if changing will not change this order
@@ -588,7 +598,7 @@ PETRA.BaseManager.prototype.setWorkersIdleByPriority = function(gameState)
  * and return remaining number of possible switches.
  * Prefer FemaleCitizen for food and CitizenSoldier for other resources.
  */
-PETRA.BaseManager.prototype.switchGatherer = function(gameState, from, to, number)
+DELPHI.BaseManager.prototype.switchGatherer = function(gameState, from, to, number)
 {
 	let num = number;
 	let only;
@@ -614,7 +624,7 @@ PETRA.BaseManager.prototype.switchGatherer = function(gameState, from, to, numbe
 	return num;
 };
 
-PETRA.BaseManager.prototype.reassignIdleWorkers = function(gameState, idleWorkers)
+DELPHI.BaseManager.prototype.reassignIdleWorkers = function(gameState, idleWorkers)
 {
 	// Search for idle workers, and tell them to gather resources based on demand
 	if (!idleWorkers)
@@ -654,19 +664,19 @@ PETRA.BaseManager.prototype.reassignIdleWorkers = function(gameState, idleWorker
 				}
 			}
 		}
-		else if (PETRA.isFastMoving(ent) && ent.canGather("food") && ent.canAttackClass("Animal"))
+		else if (DELPHI.isFastMoving(ent) && ent.canGather("food") && ent.canAttackClass("Animal"))
 			ent.setMetadata(PlayerID, "subrole", "hunter");
 		else if (ent.hasClass("FishingBoat"))
 			ent.setMetadata(PlayerID, "subrole", "fisher");
 	}
 };
 
-PETRA.BaseManager.prototype.workersBySubrole = function(gameState, subrole)
+DELPHI.BaseManager.prototype.workersBySubrole = function(gameState, subrole)
 {
 	return gameState.updatingCollection("subrole-" + subrole +"-base-" + this.ID, API3.Filters.byMetadata(PlayerID, "subrole", subrole), this.workers);
 };
 
-PETRA.BaseManager.prototype.gatherersByType = function(gameState, type)
+DELPHI.BaseManager.prototype.gatherersByType = function(gameState, type)
 {
 	return gameState.updatingCollection("workers-gathering-" + type +"-base-" + this.ID, API3.Filters.byMetadata(PlayerID, "gather-type", type), this.workersBySubrole(gameState, "gatherer"));
 };
@@ -675,7 +685,7 @@ PETRA.BaseManager.prototype.gatherersByType = function(gameState, type)
  * returns an entity collection of workers.
  * They are idled immediatly and their subrole set to idle.
  */
-PETRA.BaseManager.prototype.pickBuilders = function(gameState, workers, number)
+DELPHI.BaseManager.prototype.pickBuilders = function(gameState, workers, number)
 {
 	let availableWorkers = this.workers.filter(ent => {
 		if (!ent.position() || !ent.isBuilder())
@@ -718,7 +728,7 @@ PETRA.BaseManager.prototype.pickBuilders = function(gameState, workers, number)
  * try reassigning some other workers who are nearby
  * AI tries to use builders sensibly, not completely stopping its econ.
  */
-PETRA.BaseManager.prototype.assignToFoundations = function(gameState, noRepair)
+DELPHI.BaseManager.prototype.assignToFoundations = function(gameState, noRepair)
 {
 	let foundations = this.buildings.filter(API3.Filters.and(API3.Filters.isFoundation(), API3.Filters.not(API3.Filters.byClass("Field"))));
 
@@ -790,7 +800,7 @@ PETRA.BaseManager.prototype.assignToFoundations = function(gameState, noRepair)
 				continue;
 
 		// if our territory has shrinked since this foundation was positioned, do not build it
-		if (PETRA.isNotWorthBuilding(gameState, target))
+		if (DELPHI.isNotWorthBuilding(gameState, target))
 			continue;
 
 		let assigned = gameState.getOwnEntitiesByMetadata("target-foundation", target.id()).length;
@@ -945,7 +955,7 @@ PETRA.BaseManager.prototype.assignToFoundations = function(gameState, noRepair)
 };
 
 /** Return false when the base is not active (no workers on it) */
-PETRA.BaseManager.prototype.update = function(gameState, queues, events)
+DELPHI.BaseManager.prototype.update = function(gameState, queues, events)
 {
 	if (this.ID == gameState.ai.HQ.baseManagers[0].ID)	// base for unaffected units
 	{
@@ -955,17 +965,17 @@ PETRA.BaseManager.prototype.update = function(gameState, queues, events)
 		{
 			for (let ent of this.units.values())
 			{
-				let bestBase = PETRA.getBestBase(gameState, ent);
+				let bestBase = DELPHI.getBestBase(gameState, ent);
 				if (bestBase.ID != this.ID)
 					bestBase.assignEntity(gameState, ent);
 			}
 			for (let ent of this.buildings.values())
 			{
-				let bestBase = PETRA.getBestBase(gameState, ent);
+				let bestBase = DELPHI.getBestBase(gameState, ent);
 				if (!bestBase)
 				{
 					if (ent.hasClass("Dock"))
-						API3.warn("Petra: dock in baseManager[0]. It may be useful to do an anchorless base for " + ent.templateName());
+						API3.warn("Delphi: dock in baseManager[0]. It may be useful to do an anchorless base for " + ent.templateName());
 					continue;
 				}
 				if (ent.resourceDropsiteTypes())
@@ -995,7 +1005,7 @@ PETRA.BaseManager.prototype.update = function(gameState, queues, events)
 			// Reassign all remaining entities to its nearest base
 			for (let ent of this.units.values())
 			{
-				let base = PETRA.getBestBase(gameState, ent, false, this.ID);
+				let base = DELPHI.getBestBase(gameState, ent, false, this.ID);
 				base.assignEntity(gameState, ent);
 			}
 			return false;
@@ -1006,7 +1016,7 @@ PETRA.BaseManager.prototype.update = function(gameState, queues, events)
 		{
 			if (!ent.position())
 				continue;
-			let base = PETRA.getBestBase(gameState, ent);
+			let base = DELPHI.getBestBase(gameState, ent);
 			if (base.anchor)
 				reassignedBase = base;
 			break;
@@ -1080,7 +1090,7 @@ PETRA.BaseManager.prototype.update = function(gameState, queues, events)
 	return true;
 };
 
-PETRA.BaseManager.prototype.Serialize = function()
+DELPHI.BaseManager.prototype.Serialize = function()
 {
 	return {
 		"ID": this.ID,
@@ -1095,7 +1105,7 @@ PETRA.BaseManager.prototype.Serialize = function()
 	};
 };
 
-PETRA.BaseManager.prototype.Deserialize = function(gameState, data)
+DELPHI.BaseManager.prototype.Deserialize = function(gameState, data)
 {
 	for (let key in data)
 		this[key] = data[key];
diff --git a/binaries/data/mods/public/simulation/ai/delphi/buildManager.js b/binaries/data/mods/public/simulation/ai/delphi/buildManager.js
index 6e71233519..e87136fc8a 100644
--- a/binaries/data/mods/public/simulation/ai/delphi/buildManager.js
+++ b/binaries/data/mods/public/simulation/ai/delphi/buildManager.js
@@ -4,7 +4,7 @@
  * It also takes care of the structures we can't currently build and should not try to build endlessly.
  */
 
-PETRA.BuildManager = function()
+DELPHI.BuildManager = function()
 {
 	// List of buildings we have builders for, with number of possible builders.
 	this.builderCounters = new Map();
@@ -14,14 +14,14 @@ PETRA.BuildManager = function()
 };
 
 /** Initialization at start of game */
-PETRA.BuildManager.prototype.init = function(gameState)
+DELPHI.BuildManager.prototype.init = function(gameState)
 {
 	let civ = gameState.getPlayerCiv();
 	for (let ent of gameState.getOwnUnits().values())
 		this.incrementBuilderCounters(civ, ent, 1);
 };
 
-PETRA.BuildManager.prototype.incrementBuilderCounters = function(civ, ent, increment)
+DELPHI.BuildManager.prototype.incrementBuilderCounters = function(civ, ent, increment)
 {
 	for (let buildable of ent.buildableEntities(civ))
 	{
@@ -30,7 +30,7 @@ PETRA.BuildManager.prototype.incrementBuilderCounters = function(civ, ent, incre
 			let count = this.builderCounters.get(buildable) + increment;
 			if (count < 0)
 			{
-				API3.warn(" Petra error in incrementBuilderCounters for " + buildable + " with count < 0");
+				API3.warn(" Delphi error in incrementBuilderCounters for " + buildable + " with count < 0");
 				continue;
 			}
 			this.builderCounters.set(buildable, count);
@@ -38,12 +38,12 @@ PETRA.BuildManager.prototype.incrementBuilderCounters = function(civ, ent, incre
 		else if (increment > 0)
 			this.builderCounters.set(buildable, increment);
 		else
-			API3.warn(" Petra error in incrementBuilderCounters for " + buildable + " not yet set");
+			API3.warn(" Delphi error in incrementBuilderCounters for " + buildable + " not yet set");
 	}
 };
 
 /** Update the builders counters */
-PETRA.BuildManager.prototype.checkEvents = function(gameState, events)
+DELPHI.BuildManager.prototype.checkEvents = function(gameState, events)
 {
 	this.elapsedTime = gameState.ai.elapsedTime;
 	let civ = gameState.getPlayerCiv();
@@ -96,11 +96,7 @@ PETRA.BuildManager.prototype.checkEvents = function(gameState, events)
 	}
 };
 
-
-/**
- * Get the buildable structures passing a filter.
- */
-PETRA.BuildManager.prototype.findStructuresByFilter = function(gameState, filter)
+DELPHI.BuildManager.prototype.findStructuresByFilter = function(gameState, filter)
 {
 	const result = [];
 	for (let [templateName, count] of this.builderCounters)
@@ -120,31 +116,32 @@ PETRA.BuildManager.prototype.findStructuresByFilter = function(gameState, filter
  * Get the first buildable structure with a given class
  * TODO when several available, choose the best one
  */
-PETRA.BuildManager.prototype.findStructureWithClass = function(gameState, classes)
+DELPHI.BuildManager.prototype.findStructureWithClass = function(gameState, classes)
 {
 	return this.findStructuresByFilter(gameState, API3.Filters.byClasses(classes))[0];
 };
 
-PETRA.BuildManager.prototype.hasBuilder = function(template)
+DELPHI.BuildManager.prototype.hasBuilder = function(template)
 {
 	let numBuilders = this.builderCounters.get(template);
 	return numBuilders && numBuilders > 0;
 };
 
-PETRA.BuildManager.prototype.isUnbuildable = function(gameState, template)
+DELPHI.BuildManager.prototype.isUnbuildable = function(gameState, template)
 {
 	return this.unbuildables.has(template) && this.unbuildables.get(template).time > gameState.ai.elapsedTime;
 };
 
-PETRA.BuildManager.prototype.setBuildable = function(template)
+DELPHI.BuildManager.prototype.setBuildable = function(template)
 {
 	if (this.unbuildables.has(template))
 		this.unbuildables.delete(template);
 };
 
 /** Time is the duration in second that we will wait before checking again if it is buildable */
-PETRA.BuildManager.prototype.setUnbuildable = function(gameState, template, time = 90, reason = "room")
+DELPHI.BuildManager.prototype.setUnbuildable = function(gameState, template, time = 90, reason = "room")
 {
+	// TODO: debugger - remove
 	if (!this.unbuildables.has(template))
 		this.unbuildables.set(template, { "reason": reason, "time": gameState.ai.elapsedTime + time });
 	else
@@ -159,7 +156,7 @@ PETRA.BuildManager.prototype.setUnbuildable = function(gameState, template, time
 };
 
 /** Return the number of unbuildables due to missing room */
-PETRA.BuildManager.prototype.numberMissingRoom = function(gameState)
+DELPHI.BuildManager.prototype.numberMissingRoom = function(gameState)
 {
 	let num = 0;
 	for (let unbuildable of this.unbuildables.values())
@@ -169,14 +166,14 @@ PETRA.BuildManager.prototype.numberMissingRoom = function(gameState)
 };
 
 /** Reset the unbuildables due to missing room */
-PETRA.BuildManager.prototype.resetMissingRoom = function(gameState)
+DELPHI.BuildManager.prototype.resetMissingRoom = function(gameState)
 {
 	for (let [key, unbuildable] of this.unbuildables)
 		if (unbuildable.reason == "room")
 			this.unbuildables.delete(key);
 };
 
-PETRA.BuildManager.prototype.Serialize = function()
+DELPHI.BuildManager.prototype.Serialize = function()
 {
 	return {
 		"builderCounters": this.builderCounters,
@@ -184,7 +181,7 @@ PETRA.BuildManager.prototype.Serialize = function()
 	};
 };
 
-PETRA.BuildManager.prototype.Deserialize = function(data)
+DELPHI.BuildManager.prototype.Deserialize = function(data)
 {
 	for (let key in data)
 		this[key] = data[key];
diff --git a/binaries/data/mods/public/simulation/ai/delphi/chatHelper.js b/binaries/data/mods/public/simulation/ai/delphi/chatHelper.js
index 96710ae097..39fcc2ca63 100644
--- a/binaries/data/mods/public/simulation/ai/delphi/chatHelper.js
+++ b/binaries/data/mods/public/simulation/ai/delphi/chatHelper.js
@@ -1,4 +1,4 @@
-PETRA.launchAttackMessages = {
+DELPHI.launchAttackMessages = {
 	"hugeAttack": [
 		markForTranslation("I am starting a massive military campaign against %(_player_)s, come and join me."),
 		markForTranslation("I have set up a huge army to crush %(_player_)s. Join me and you will have your share of the loot.")
@@ -9,7 +9,7 @@ PETRA.launchAttackMessages = {
 	]
 };
 
-PETRA.answerRequestAttackMessages = {
+DELPHI.answerRequestAttackMessages = {
 	"join": [
 		markForTranslation("Let me regroup my army and I will then join you against %(_player_)s."),
 		markForTranslation("I am finishing preparations to attack %(_player_)s.")
@@ -23,24 +23,24 @@ PETRA.answerRequestAttackMessages = {
 	]
 };
 
-PETRA.sentTributeMessages = [
+DELPHI.sentTributeMessages = [
 	markForTranslation("Here is a gift for you, %(_player_)s. Make good use of it."),
 	markForTranslation("I see you are in a bad situation, %(_player_)s. I hope this helps."),
 	markForTranslation("I can help you this time, %(_player_)s, but you should manage your resources more carefully in the future.")
 ];
 
-PETRA.requestTributeMessages = [
+DELPHI.requestTributeMessages = [
 	markForTranslation("I am in need of %(resource)s, can you help? I will make it up to you."),
 	markForTranslation("I would participate more efficiently in our common war effort if you could provide me some %(resource)s."),
 	markForTranslation("If you can spare me some %(resource)s, I will be able to strengthen my army.")
 ];
 
-PETRA.newTradeRouteMessages = [
+DELPHI.newTradeRouteMessages = [
 	markForTranslation("I have set up a new route with %(_player_)s. Trading will be profitable for all of us."),
 	markForTranslation("A new trade route is set up with %(_player_)s. Take your share of the profits.")
 ];
 
-PETRA.newDiplomacyMessages = {
+DELPHI.newDiplomacyMessages = {
 	"ally": [
 		markForTranslation("%(_player_)s and I are now allies.")
 	],
@@ -52,7 +52,7 @@ PETRA.newDiplomacyMessages = {
 	]
 };
 
-PETRA.answerDiplomacyRequestMessages = {
+DELPHI.answerDiplomacyRequestMessages = {
 	"ally": {
 		"decline": [
 			markForTranslation("I cannot accept your offer to become allies, %(_player_)s.")
@@ -110,7 +110,7 @@ PETRA.answerDiplomacyRequestMessages = {
 	}
 };
 
-PETRA.sendDiplomacyRequestMessages = {
+DELPHI.sendDiplomacyRequestMessages = {
 	"ally": {
 		"sendRequest": [
 			markForTranslation("%(_player_)s, it would help both of our civilizations if we formed an alliance. If you become allies with me, I will respond in kind.")
@@ -132,7 +132,7 @@ PETRA.sendDiplomacyRequestMessages = {
 	}
 };
 
-PETRA.chatLaunchAttack = function(gameState, player, type)
+DELPHI.chatLaunchAttack = function(gameState, player, type)
 {
 	Engine.PostCommand(PlayerID, {
 		"type": "aichat",
@@ -143,7 +143,7 @@ PETRA.chatLaunchAttack = function(gameState, player, type)
 	});
 };
 
-PETRA.chatAnswerRequestAttack = function(gameState, player, answer, other)
+DELPHI.chatAnswerRequestAttack = function(gameState, player, answer, other)
 {
 	Engine.PostCommand(PlayerID, {
 		"type": "aichat",
@@ -154,7 +154,7 @@ PETRA.chatAnswerRequestAttack = function(gameState, player, answer, other)
 	});
 };
 
-PETRA.chatSentTribute = function(gameState, player)
+DELPHI.chatSentTribute = function(gameState, player)
 {
 	Engine.PostCommand(PlayerID, {
 		"type": "aichat",
@@ -165,7 +165,7 @@ PETRA.chatSentTribute = function(gameState, player)
 	});
 };
 
-PETRA.chatRequestTribute = function(gameState, resource)
+DELPHI.chatRequestTribute = function(gameState, resource)
 {
 	Engine.PostCommand(PlayerID, {
 		"type": "aichat",
@@ -176,7 +176,7 @@ PETRA.chatRequestTribute = function(gameState, resource)
 	});
 };
 
-PETRA.chatNewTradeRoute = function(gameState, player)
+DELPHI.chatNewTradeRoute = function(gameState, player)
 {
 	Engine.PostCommand(PlayerID, {
 		"type": "aichat",
@@ -187,7 +187,7 @@ PETRA.chatNewTradeRoute = function(gameState, player)
 	});
 };
 
-PETRA.chatNewPhase = function(gameState, phase, status)
+DELPHI.chatNewPhase = function(gameState, phase, status)
 {
 	Engine.PostCommand(PlayerID, {
 		"type": "aichat",
@@ -198,7 +198,7 @@ PETRA.chatNewPhase = function(gameState, phase, status)
 	});
 };
 
-PETRA.chatNewDiplomacy = function(gameState, player, newDiplomaticStance)
+DELPHI.chatNewDiplomacy = function(gameState, player, newDiplomaticStance)
 {
 	Engine.PostCommand(PlayerID, {
 		"type": "aichat",
@@ -209,7 +209,7 @@ PETRA.chatNewDiplomacy = function(gameState, player, newDiplomaticStance)
 	});
 };
 
-PETRA.chatAnswerRequestDiplomacy = function(gameState, player, requestType, response, requiredTribute)
+DELPHI.chatAnswerRequestDiplomacy = function(gameState, player, requestType, response, requiredTribute)
 {
 	Engine.PostCommand(PlayerID, {
 		"type": "aichat",
@@ -223,7 +223,7 @@ PETRA.chatAnswerRequestDiplomacy = function(gameState, player, requestType, resp
 	});
 };
 
-PETRA.chatNewRequestDiplomacy = function(gameState, player, requestType, status)
+DELPHI.chatNewRequestDiplomacy = function(gameState, player, requestType, status)
 {
 	Engine.PostCommand(PlayerID, {
 		"type": "aichat",
diff --git a/binaries/data/mods/public/simulation/ai/delphi/config.js b/binaries/data/mods/public/simulation/ai/delphi/config.js
index 6259a90050..760d7d95c0 100644
--- a/binaries/data/mods/public/simulation/ai/delphi/config.js
+++ b/binaries/data/mods/public/simulation/ai/delphi/config.js
@@ -1,4 +1,4 @@
-PETRA.Config = function(difficulty, behavior)
+DELPHI.Config = function(difficulty, behavior)
 {
 	// 0 is sandbox, 1 is very easy, 2 is easy, 3 is medium, 4 is hard and 5 is very hard.
 	this.difficulty = difficulty !== undefined ? difficulty : 3;
@@ -35,7 +35,7 @@ PETRA.Config = function(difficulty, behavior)
 		"workPhase4": 80,	// How many workers we want before aging to phase4 or higher.
 		"popForDock": 25,
 		"targetNumWorkers": 40,	// dummy, will be changed later
-		"targetNumTraders": 5,	// Target number of traders
+		"traderRatio": 0.1,		// fraction of traders among population
 		"targetNumFishers": 1,	// Target number of fishers per sea
 		"supportRatio": 0.35,	// fraction of support workers among the workforce
 		"provisionFields": 2
@@ -137,7 +137,7 @@ PETRA.Config = function(difficulty, behavior)
 		"defensive": 0.5
 	};
 
-	// See PETRA.QueueManager.prototype.wantedGatherRates()
+	// See DELPHI.QueueManager.prototype.wantedGatherRates()
 	this.queues =
 	{
 		"firstTurn": {
@@ -161,7 +161,7 @@ PETRA.Config = function(difficulty, behavior)
 	this.garrisonHealthLevel = { "low": 0.4, "medium": 0.55, "high": 0.7 };
 };
 
-PETRA.Config.prototype.setConfig = function(gameState)
+DELPHI.Config.prototype.setConfig = function(gameState)
 {
 	if (this.difficulty > 0)
 	{
@@ -188,7 +188,7 @@ PETRA.Config.prototype.setConfig = function(gameState)
 			"cooperative": randFloat(0, 1)
 		};
 	}
-	// Petra usually uses the continuous values of personality.aggressive and personality.defensive
+	// Delphi usually uses the continuous values of personality.aggressive and personality.defensive
 	// to define its behavior according to personality. But when discontinuous behavior is needed,
 	// it uses the following personalityCut which should be set such that:
 	// behavior="aggressive" => personality.aggressive > personalityCut.strong &&
@@ -246,7 +246,6 @@ PETRA.Config.prototype.setConfig = function(gameState)
 		this.Economy.targetNumWorkers = Math.max(1, Math.min(60, Math.floor(maxPop/2)));
 	else
 		this.Economy.targetNumWorkers = Math.max(1, Math.min(120, Math.floor(maxPop/3)));
-	this.Economy.targetNumTraders = 2 + this.difficulty;
 
 
 	if (gameState.getVictoryConditions().has("wonder"))
@@ -273,10 +272,10 @@ PETRA.Config.prototype.setConfig = function(gameState)
 
 	if (this.debug < 2)
 		return;
-	API3.warn(" >>>  Petra bot: personality = " + uneval(this.personality));
+	API3.warn(" >>>  Delphi bot: personality = " + uneval(this.personality));
 };
 
-PETRA.Config.prototype.Serialize = function()
+DELPHI.Config.prototype.Serialize = function()
 {
 	var data = {};
 	for (let key in this)
@@ -285,7 +284,7 @@ PETRA.Config.prototype.Serialize = function()
 	return data;
 };
 
-PETRA.Config.prototype.Deserialize = function(data)
+DELPHI.Config.prototype.Deserialize = function(data)
 {
 	for (let key in data)
 		this[key] = data[key];
diff --git a/binaries/data/mods/public/simulation/ai/delphi/data.json b/binaries/data/mods/public/simulation/ai/delphi/data.json
index d24e0d1692..f5fa68c8b0 100644
--- a/binaries/data/mods/public/simulation/ai/delphi/data.json
+++ b/binaries/data/mods/public/simulation/ai/delphi/data.json
@@ -1,7 +1,7 @@
 {
-  "name": "Petra Bot",
-  "description": "Petra is the default 0 A.D. AI bot. Please report issues to Wildfire Games (see the link in the main menu).\n\nThe AI's resource gathering rate and trade gain depend on the difficulty level (Sandbox 58%, Very Easy 44%, Easy 25%, Medium 0%, Hard +25%, Very Hard +56%). The easiest levels also have a slower research, training, and building rate. In addition, the Sandbox level does not expand nor attack.",
-  "moduleName" : "PETRA",
-  "constructor": "PetraBot",
+  "name": "Delphi Bot",
+  "description": "Delphi is a clone of Delphi Bot, the default 0ad AI.",
+  "moduleName" : "DELPHI",
+  "constructor": "DelphiBot",
   "useShared": true
 }
diff --git a/binaries/data/mods/public/simulation/ai/delphi/defenseArmy.js b/binaries/data/mods/public/simulation/ai/delphi/defenseArmy.js
index f32c64f329..293115338c 100644
--- a/binaries/data/mods/public/simulation/ai/delphi/defenseArmy.js
+++ b/binaries/data/mods/public/simulation/ai/delphi/defenseArmy.js
@@ -7,7 +7,7 @@
  * "capturing": army set to capture a gaia building or recover capture points to one of its own structures
  *            It must contain only one foe (the building to capture) and never be merged
  */
-PETRA.DefenseArmy = function(gameState, foeEntities, type)
+DELPHI.DefenseArmy = function(gameState, foeEntities, type)
 {
 	this.ID = gameState.ai.uniqueIDs.armies++;
 	this.type = type || "default";
@@ -48,7 +48,7 @@ PETRA.DefenseArmy = function(gameState, foeEntities, type)
  * won't recalculate our position but will dirty it.
  * force is true at army creation or when merging armies, so in this case we should add it even if far
  */
-PETRA.DefenseArmy.prototype.addFoe = function(gameState, enemyId, force)
+DELPHI.DefenseArmy.prototype.addFoe = function(gameState, enemyId, force)
 {
 	if (this.foeEntities.indexOf(enemyId) !== -1)
 		return false;
@@ -73,7 +73,7 @@ PETRA.DefenseArmy.prototype.addFoe = function(gameState, enemyId, force)
  * returns true if the entity was removed and false otherwise.
  * TODO: when there is a technology update, we should probably recompute the strengths, or weird stuffs will happen.
  */
-PETRA.DefenseArmy.prototype.removeFoe = function(gameState, enemyId, enemyEntity)
+DELPHI.DefenseArmy.prototype.removeFoe = function(gameState, enemyId, enemyEntity)
 {
 	let idx = this.foeEntities.indexOf(enemyId);
 	if (idx === -1)
@@ -100,7 +100,7 @@ PETRA.DefenseArmy.prototype.removeFoe = function(gameState, enemyId, enemyEntity
  * adds a defender but doesn't assign him yet.
  * force is true when merging armies, so in this case we should add it even if no position as it can be in a ship
  */
-PETRA.DefenseArmy.prototype.addOwn = function(gameState, id, force)
+DELPHI.DefenseArmy.prototype.addOwn = function(gameState, id, force)
 {
 	if (this.ownEntities.indexOf(id) !== -1)
 		return false;
@@ -125,7 +125,7 @@ PETRA.DefenseArmy.prototype.addOwn = function(gameState, id, force)
 	return true;
 };
 
-PETRA.DefenseArmy.prototype.removeOwn = function(gameState, id, Entity)
+DELPHI.DefenseArmy.prototype.removeOwn = function(gameState, id, Entity)
 {
 	let idx = this.ownEntities.indexOf(id);
 	if (idx === -1)
@@ -191,7 +191,7 @@ PETRA.DefenseArmy.prototype.removeOwn = function(gameState, id, Entity)
  * resets the army properly.
  * assumes we already cleared dead units.
  */
-PETRA.DefenseArmy.prototype.clear = function(gameState)
+DELPHI.DefenseArmy.prototype.clear = function(gameState)
 {
 	while (this.foeEntities.length > 0)
 		this.removeFoe(gameState, this.foeEntities[0]);
@@ -247,7 +247,7 @@ PETRA.DefenseArmy.prototype.clear = function(gameState)
 			let pos = struct.position();
 			if (!pos || !gameState.isPlayerMutualAlly(gameState.ai.HQ.territoryMap.getOwner(pos)))
 				continue;
-			if (PETRA.getLandAccess(gameState, struct) !== armyAccess)
+			if (DELPHI.getLandAccess(gameState, struct) !== armyAccess)
 				continue;
 			let defensiveStruct = struct.hasDefensiveFire();
 			if (defensiveFound && !defensiveStruct)
@@ -290,7 +290,7 @@ PETRA.DefenseArmy.prototype.clear = function(gameState)
 	this.recalculatePosition(gameState);
 };
 
-PETRA.DefenseArmy.prototype.assignUnit = function(gameState, entID)
+DELPHI.DefenseArmy.prototype.assignUnit = function(gameState, entID)
 {
 	// we'll assume this defender is ours already.
 	// we'll also override any previous assignment
@@ -300,7 +300,7 @@ PETRA.DefenseArmy.prototype.assignUnit = function(gameState, entID)
 		return false;
 
 	// try to return its resources, and if any, the attack order will be queued
-	let queued = PETRA.returnResources(gameState, ent);
+	let queued = DELPHI.returnResources(gameState, ent);
 
 	let idMin;
 	let distMin;
@@ -312,7 +312,7 @@ PETRA.DefenseArmy.prototype.assignUnit = function(gameState, entID)
 		if (!eEnt || !eEnt.position())	// probably can't happen.
 			continue;
 
-		if (!ent.canAttackTarget(eEnt, PETRA.allowCapture(gameState, ent, eEnt)))
+		if (!ent.canAttackTarget(eEnt, DELPHI.allowCapture(gameState, ent, eEnt)))
 			continue;
 
 		if (eEnt.hasClass("Unit") && eEnt.unitAIOrderData() && eEnt.unitAIOrderData().length &&
@@ -324,7 +324,7 @@ PETRA.DefenseArmy.prototype.assignUnit = function(gameState, entID)
 
 		// already enough units against it
 		if (this.assignedAgainst[id].length > 8 ||
-			this.assignedAgainst[id].length > 5 && !eEnt.hasClass("Hero") && !PETRA.isSiegeUnit(eEnt))
+			this.assignedAgainst[id].length > 5 && !eEnt.hasClass("Hero") && !DELPHI.isSiegeUnit(eEnt))
 			continue;
 
 		let dist = API3.SquareVectorDistance(ent.position(), eEnt.position());
@@ -350,7 +350,7 @@ PETRA.DefenseArmy.prototype.assignUnit = function(gameState, entID)
 	else
 		return false;
 
-	let ownIndex = PETRA.getLandAccess(gameState, ent);
+	let ownIndex = DELPHI.getLandAccess(gameState, ent);
 	let foeEnt = gameState.getEntityById(idFoe);
 	let foePosition = foeEnt.position();
 	let foeIndex = gameState.ai.accessibility.getAccessValue(foePosition);
@@ -358,19 +358,19 @@ PETRA.DefenseArmy.prototype.assignUnit = function(gameState, entID)
 	{
 		this.assignedTo[entID] = idFoe;
 		this.assignedAgainst[idFoe].push(entID);
-		ent.attack(idFoe, PETRA.allowCapture(gameState, ent, foeEnt), queued);
+		ent.attack(idFoe, DELPHI.allowCapture(gameState, ent, foeEnt), queued);
 	}
 	else
 		gameState.ai.HQ.navalManager.requireTransport(gameState, ent, ownIndex, foeIndex, foePosition);
 	return true;
 };
 
-PETRA.DefenseArmy.prototype.getType = function()
+DELPHI.DefenseArmy.prototype.getType = function()
 {
 	return this.type;
 };
 
-PETRA.DefenseArmy.prototype.getState = function()
+DELPHI.DefenseArmy.prototype.getState = function()
 {
 	if (!this.foeEntities.length)
 		return 0;
@@ -382,7 +382,7 @@ PETRA.DefenseArmy.prototype.getState = function()
  * assumes units are in only one army.
  * also assumes that all have been properly cleaned up (no dead units).
  */
-PETRA.DefenseArmy.prototype.merge = function(gameState, otherArmy)
+DELPHI.DefenseArmy.prototype.merge = function(gameState, otherArmy)
 {
 	// copy over all parameters.
 	for (let i in otherArmy.assignedAgainst)
@@ -407,7 +407,7 @@ PETRA.DefenseArmy.prototype.merge = function(gameState, otherArmy)
 	return true;
 };
 
-PETRA.DefenseArmy.prototype.needsDefenders = function(gameState)
+DELPHI.DefenseArmy.prototype.needsDefenders = function(gameState)
 {
 	let defenseRatio;
 	let territoryOwner = gameState.ai.HQ.territoryMap.getOwner(this.foePosition);
@@ -436,7 +436,7 @@ PETRA.DefenseArmy.prototype.needsDefenders = function(gameState)
 
 
 /** if not forced, will only recalculate if on a different turn. */
-PETRA.DefenseArmy.prototype.recalculatePosition = function(gameState, force)
+DELPHI.DefenseArmy.prototype.recalculatePosition = function(gameState, force)
 {
 	if (!force && this.positionLastUpdate === gameState.ai.elapsedTime)
 		return;
@@ -463,7 +463,7 @@ PETRA.DefenseArmy.prototype.recalculatePosition = function(gameState, force)
 	this.positionLastUpdate = gameState.ai.elapsedTime;
 };
 
-PETRA.DefenseArmy.prototype.recalculateStrengths = function(gameState)
+DELPHI.DefenseArmy.prototype.recalculateStrengths = function(gameState)
 {
 	this.ownStrength = 0;
 	this.foeStrength = 0;
@@ -475,7 +475,7 @@ PETRA.DefenseArmy.prototype.recalculateStrengths = function(gameState)
 };
 
 /** adds or remove the strength of the entity either to the enemy or to our units. */
-PETRA.DefenseArmy.prototype.evaluateStrength = function(ent, isOwn, remove)
+DELPHI.DefenseArmy.prototype.evaluateStrength = function(ent, isOwn, remove)
 {
 	if (!ent)
 		return;
@@ -489,7 +489,7 @@ PETRA.DefenseArmy.prototype.evaluateStrength = function(ent, isOwn, remove)
 			entStrength = 2;
 	}
 	else
-		entStrength = PETRA.getMaxStrength(ent, this.Config.debug, this.Config.DamageTypeImportance);
+		entStrength = DELPHI.getMaxStrength(ent, this.Config.debug, this.Config.DamageTypeImportance);
 
 	// TODO adapt the getMaxStrength function for animals.
 	// For the time being, just increase it for elephants as the returned value is too small.
@@ -505,7 +505,7 @@ PETRA.DefenseArmy.prototype.evaluateStrength = function(ent, isOwn, remove)
 		this.foeStrength += entStrength;
 };
 
-PETRA.DefenseArmy.prototype.checkEvents = function(gameState, events)
+DELPHI.DefenseArmy.prototype.checkEvents = function(gameState, events)
 {
 	// Warning the metadata is already cloned in shared.js. Futhermore, changes should be done before destroyEvents
 	// otherwise it would remove the old entity from this army list
@@ -561,7 +561,7 @@ PETRA.DefenseArmy.prototype.checkEvents = function(gameState, events)
 	}
 };
 
-PETRA.DefenseArmy.prototype.update = function(gameState)
+DELPHI.DefenseArmy.prototype.update = function(gameState)
 {
 	for (let entId of this.ownEntities)
 	{
@@ -574,7 +574,7 @@ PETRA.DefenseArmy.prototype.update = function(gameState)
 		else if (orderData.length && orderData[0].target && orderData[0].attackType && orderData[0].attackType === "Capture")
 		{
 			let target = gameState.getEntityById(orderData[0].target);
-			if (target && !PETRA.allowCapture(gameState, ent, target))
+			if (target && !DELPHI.allowCapture(gameState, ent, target))
 				ent.attack(orderData[0].target, false);
 		}
 	}
@@ -626,7 +626,7 @@ PETRA.DefenseArmy.prototype.update = function(gameState)
 	return breakaways;
 };
 
-PETRA.DefenseArmy.prototype.Serialize = function()
+DELPHI.DefenseArmy.prototype.Serialize = function()
 {
 	return {
 		"ID": this.ID,
@@ -642,7 +642,7 @@ PETRA.DefenseArmy.prototype.Serialize = function()
 	};
 };
 
-PETRA.DefenseArmy.prototype.Deserialize = function(data)
+DELPHI.DefenseArmy.prototype.Deserialize = function(data)
 {
 	for (let key in data)
 		this[key] = data[key];
diff --git a/binaries/data/mods/public/simulation/ai/delphi/defenseManager.js b/binaries/data/mods/public/simulation/ai/delphi/defenseManager.js
index 5397a418c3..f837a15358 100644
--- a/binaries/data/mods/public/simulation/ai/delphi/defenseManager.js
+++ b/binaries/data/mods/public/simulation/ai/delphi/defenseManager.js
@@ -1,4 +1,4 @@
-PETRA.DefenseManager = function(Config)
+DELPHI.DefenseManager = function(Config)
 {
 	// Array of "army" Objects.
 	this.armies = [];
@@ -14,7 +14,7 @@ PETRA.DefenseManager = function(Config)
 	this.attackedAllies = {};
 };
 
-PETRA.DefenseManager.prototype.update = function(gameState, events)
+DELPHI.DefenseManager.prototype.update = function(gameState, events)
 {
 	Engine.ProfileStart("Defense Manager");
 
@@ -65,7 +65,7 @@ PETRA.DefenseManager.prototype.update = function(gameState, events)
 	Engine.ProfileStop();
 };
 
-PETRA.DefenseManager.prototype.makeIntoArmy = function(gameState, entityID, type = "default")
+DELPHI.DefenseManager.prototype.makeIntoArmy = function(gameState, entityID, type = "default")
 {
 	if (type == "default")
 	{
@@ -76,12 +76,12 @@ PETRA.DefenseManager.prototype.makeIntoArmy = function(gameState, entityID, type
 	}
 
 	// Create a new army for it.
-	let army = new PETRA.DefenseArmy(gameState, [entityID], type);
+	let army = new DELPHI.DefenseArmy(gameState, [entityID], type);
 
 	this.armies.push(army);
 };
 
-PETRA.DefenseManager.prototype.getArmy = function(partOfArmy)
+DELPHI.DefenseManager.prototype.getArmy = function(partOfArmy)
 {
 	// Find the army corresponding to this ID partOfArmy.
 	for (let army of this.armies)
@@ -91,7 +91,7 @@ PETRA.DefenseManager.prototype.getArmy = function(partOfArmy)
 	return undefined;
 };
 
-PETRA.DefenseManager.prototype.isDangerous = function(gameState, entity)
+DELPHI.DefenseManager.prototype.isDangerous = function(gameState, entity)
 {
 	if (!entity.position())
 		return false;
@@ -157,9 +157,12 @@ PETRA.DefenseManager.prototype.isDangerous = function(gameState, entity)
 		let cooperation = this.GetCooperationLevel(cc.owner());
 		if (cooperation < 0.3 || cooperation < 0.6 && !!cc.foundationProgress())
 			continue;
-		if (API3.SquareVectorDistance(cc.position(), entity.position()) < dist2Min)
+		let ccPos = cc.position();
+		if (!ccPos)
+			continue;
+		if (API3.SquareVectorDistance(ccPos, entity.position()) < dist2Min)
 			return true;
-	}
+	}// end for cc of ccEnts.values()
 
 	for (let building of gameState.getOwnStructures().values())
 	{
@@ -199,7 +202,7 @@ PETRA.DefenseManager.prototype.isDangerous = function(gameState, entity)
 	return false;
 };
 
-PETRA.DefenseManager.prototype.checkEnemyUnits = function(gameState)
+DELPHI.DefenseManager.prototype.checkEnemyUnits = function(gameState)
 {
 	const nbPlayers = gameState.sharedScript.playersData.length;
 	let i = gameState.ai.playedTurn % nbPlayers;
@@ -275,7 +278,7 @@ PETRA.DefenseManager.prototype.checkEnemyUnits = function(gameState)
 	}
 };
 
-PETRA.DefenseManager.prototype.checkEnemyArmies = function(gameState)
+DELPHI.DefenseManager.prototype.checkEnemyArmies = function(gameState)
 {
 	for (let i = 0; i < this.armies.length; ++i)
 	{
@@ -388,7 +391,7 @@ PETRA.DefenseManager.prototype.checkEnemyArmies = function(gameState)
 	}
 };
 
-PETRA.DefenseManager.prototype.assignDefenders = function(gameState)
+DELPHI.DefenseManager.prototype.assignDefenders = function(gameState)
 {
 	if (!this.armies.length)
 		return;
@@ -407,11 +410,11 @@ PETRA.DefenseManager.prototype.assignDefenders = function(gameState)
 			let ent = gameState.getEntityById(entId);
 			if (!ent || !ent.position())
 				continue;
-			armyAccess = PETRA.getLandAccess(gameState, ent);
+			armyAccess = DELPHI.getLandAccess(gameState, ent);
 			break;
 		}
 		if (!armyAccess)
-			API3.warn(" Petra error: attacking army " + army.ID + " without access");
+			API3.warn(" Delphi error: attacking army " + army.ID + " without access");
 		army.recalculatePosition(gameState);
 		armiesNeeding.push({ "army": army, "access": armyAccess, "need": needsDef });
 	}
@@ -457,7 +460,7 @@ PETRA.DefenseManager.prototype.assignDefenders = function(gameState)
 				continue;
 			let aMin;
 			let distMin;
-			let access = ipass == 0 ? PETRA.getLandAccess(gameState, ent) : undefined;
+			let access = ipass == 0 ? DELPHI.getLandAccess(gameState, ent) : undefined;
 			for (let a = 0; a < armiesNeeding.length; ++a)
 			{
 				if (access && armiesNeeding[a].access != access)
@@ -466,7 +469,7 @@ PETRA.DefenseManager.prototype.assignDefenders = function(gameState)
 				// Do not assign defender if it cannot attack at least part of the attacking army.
 				if (!armiesNeeding[a].army.foeEntities.some(eEnt => {
 					let eEntID = gameState.getEntityById(eEnt);
-					return ent.canAttackTarget(eEntID, PETRA.allowCapture(gameState, ent, eEntID));
+					return ent.canAttackTarget(eEntID, DELPHI.allowCapture(gameState, ent, eEntID));
 					}))
 					continue;
 
@@ -489,7 +492,7 @@ PETRA.DefenseManager.prototype.assignDefenders = function(gameState)
 			else if (aMin === undefined)
 				continue;
 
-			armiesNeeding[aMin].need -= PETRA.getMaxStrength(ent, this.Config.debug, this.Config.DamageTypeImportance);
+			armiesNeeding[aMin].need -= DELPHI.getMaxStrength(ent, this.Config.debug, this.Config.DamageTypeImportance);
 			armiesNeeding[aMin].army.addOwn(gameState, potentialDefenders[i]);
 			armiesNeeding[aMin].army.assignUnit(gameState, potentialDefenders[i]);
 			potentialDefenders[i] = undefined;
@@ -508,7 +511,7 @@ PETRA.DefenseManager.prototype.assignDefenders = function(gameState)
 	gameState.ai.HQ.trainEmergencyUnits(gameState, armiesPos);
 };
 
-PETRA.DefenseManager.prototype.abortArmy = function(gameState, army)
+DELPHI.DefenseManager.prototype.abortArmy = function(gameState, army)
 {
 	army.clear(gameState);
 	for (let i = 0; i < this.armies.length; ++i)
@@ -526,7 +529,7 @@ PETRA.DefenseManager.prototype.abortArmy = function(gameState, army)
  * and if a ranged siege unit (not used for defense) is attacked, garrison it in the nearest fortress.
  * If our hero is attacked with regicide victory condition, the victoryManager will handle it.
  */
-PETRA.DefenseManager.prototype.checkEvents = function(gameState, events)
+DELPHI.DefenseManager.prototype.checkEvents = function(gameState, events)
 {
 	// Must be called every turn for all armies.
 	for (let army of this.armies)
@@ -697,7 +700,7 @@ PETRA.DefenseManager.prototype.checkEvents = function(gameState, events)
 					continue;
 				if (unitAIStateOrder == "REPAIR" && currentTarget.hasDefensiveFire())
 					continue;
-				if (unitAIStateOrder == "COMBAT" && !PETRA.isSiegeUnit(currentTarget) &&
+				if (unitAIStateOrder == "COMBAT" && !DELPHI.isSiegeUnit(currentTarget) &&
 				    gameState.ai.HQ.capturableTargets.has(orderData[0].target))
 				{
 					// Take the nearest unit also attacking this structure to help us.
@@ -711,7 +714,7 @@ PETRA.DefenseManager.prototype.checkEvents = function(gameState, events)
 						if (allAttacked[entId])
 							continue;
 						let ent = gameState.getEntityById(entId);
-						if (!ent || !ent.position() || !ent.canAttackTarget(attacker, PETRA.allowCapture(gameState, ent, attacker)))
+						if (!ent || !ent.position() || !ent.canAttackTarget(attacker, DELPHI.allowCapture(gameState, ent, attacker)))
 							continue;
 						// Check that the unit is still attacking the structure (since the last played turn).
 						let state = ent.unitAIState();
@@ -730,18 +733,18 @@ PETRA.DefenseManager.prototype.checkEvents = function(gameState, events)
 					if (minEnt)
 					{
 						capturableTarget.ents.delete(minEnt.id());
-						minEnt.attack(attacker.id(), PETRA.allowCapture(gameState, minEnt, attacker));
+						minEnt.attack(attacker.id(), DELPHI.allowCapture(gameState, minEnt, attacker));
 					}
 				}
 			}
-			let allowCapture = PETRA.allowCapture(gameState, target, attacker);
+			let allowCapture = DELPHI.allowCapture(gameState, target, attacker);
 			if (target.canAttackTarget(attacker, allowCapture))
 				target.attack(attacker.id(), allowCapture);
 		}
 	}
 };
 
-PETRA.DefenseManager.prototype.garrisonUnitsInside = function(gameState, target, data)
+DELPHI.DefenseManager.prototype.garrisonUnitsInside = function(gameState, target, data)
 {
 	if (target.hitpoints() < target.garrisonEjectHealth() * target.maxHitpoints())
 		return false;
@@ -758,7 +761,7 @@ PETRA.DefenseManager.prototype.garrisonUnitsInside = function(gameState, target,
 		if (dist >= range*range)
 			return false;
 	}
-	let access = PETRA.getLandAccess(gameState, target);
+	let access = DELPHI.getLandAccess(gameState, target);
 	let garrisonManager = gameState.ai.HQ.garrisonManager;
 	let garrisonArrowClasses = target.getGarrisonArrowClasses();
 	let typeGarrison = data.type || "protection";
@@ -767,7 +770,7 @@ PETRA.DefenseManager.prototype.garrisonUnitsInside = function(gameState, target,
 	{
 		// Should be kept in sync with garrisonManager to avoid garrisoning-ungarrisoning some units.
 		if (data.attacker)
-			allowMelee = data.attacker.hasClass("Structure") ? data.attacker.attackRange("Ranged") : !PETRA.isSiegeUnit(data.attacker);
+			allowMelee = data.attacker.hasClass("Structure") ? data.attacker.attackRange("Ranged") : !DELPHI.isSiegeUnit(data.attacker);
 		else
 			allowMelee = true;
 	}
@@ -790,7 +793,7 @@ PETRA.DefenseManager.prototype.garrisonUnitsInside = function(gameState, target,
 			if (typeGarrison != "decay" && subrole && (subrole == "completing" || subrole == "walking" || subrole == "attacking"))
 				return false;
 		}
-		if (PETRA.getLandAccess(gameState, ent) != access)
+		if (DELPHI.getLandAccess(gameState, ent) != access)
 			return false;
 		return true;
 	}).filterNearest(target.position());
@@ -816,11 +819,11 @@ PETRA.DefenseManager.prototype.garrisonUnitsInside = function(gameState, target,
 };
 
 /** Garrison a attacked siege ranged unit inside the nearest fortress. */
-PETRA.DefenseManager.prototype.garrisonSiegeUnit = function(gameState, unit)
+DELPHI.DefenseManager.prototype.garrisonSiegeUnit = function(gameState, unit)
 {
 	let distmin = Math.min();
 	let nearest;
-	let unitAccess = PETRA.getLandAccess(gameState, unit);
+	let unitAccess = DELPHI.getLandAccess(gameState, unit);
 	let garrisonManager = gameState.ai.HQ.garrisonManager;
 	for (let ent of gameState.getAllyStructures().values())
 	{
@@ -832,7 +835,7 @@ PETRA.DefenseManager.prototype.garrisonSiegeUnit = function(gameState, unit)
 			continue;
 		if (ent.hitpoints() < ent.garrisonEjectHealth() * ent.maxHitpoints())
 			continue;
-		if (PETRA.getLandAccess(gameState, ent) != unitAccess)
+		if (DELPHI.getLandAccess(gameState, ent) != unitAccess)
 			continue;
 		let dist = API3.SquareVectorDistance(ent.position(), unit.position());
 		if (dist > distmin)
@@ -850,11 +853,11 @@ PETRA.DefenseManager.prototype.garrisonSiegeUnit = function(gameState, unit)
  * If emergency is true, the unit will be garrisoned in the closest possible structure.
  * Otherwise, it will garrison in the closest healing structure.
  */
-PETRA.DefenseManager.prototype.garrisonAttackedUnit = function(gameState, unit, emergency = false)
+DELPHI.DefenseManager.prototype.garrisonAttackedUnit = function(gameState, unit, emergency = false)
 {
 	let distmin = Math.min();
 	let nearest;
-	let unitAccess = PETRA.getLandAccess(gameState, unit);
+	let unitAccess = DELPHI.getLandAccess(gameState, unit);
 	let garrisonManager = gameState.ai.HQ.garrisonManager;
 	for (let ent of gameState.getAllyStructures().values())
 	{
@@ -869,7 +872,7 @@ PETRA.DefenseManager.prototype.garrisonAttackedUnit = function(gameState, unit,
 			continue;
 		if (ent.hitpoints() < ent.garrisonEjectHealth() * ent.maxHitpoints())
 			continue;
-		if (PETRA.getLandAccess(gameState, ent) != unitAccess)
+		if (DELPHI.getLandAccess(gameState, ent) != unitAccess)
 			continue;
 		let dist = API3.SquareVectorDistance(ent.position(), unit.position());
 		if (dist > distmin)
@@ -895,7 +898,7 @@ PETRA.DefenseManager.prototype.garrisonAttackedUnit = function(gameState, unit,
 /**
  * Be more inclined to help an ally attacked by several enemies.
  */
-PETRA.DefenseManager.prototype.GetCooperationLevel = function(ally)
+DELPHI.DefenseManager.prototype.GetCooperationLevel = function(ally)
 {
 	let cooperation = this.Config.personality.cooperative;
 	if (this.attackedAllies[ally] && this.attackedAllies[ally] > 1)
@@ -906,7 +909,7 @@ PETRA.DefenseManager.prototype.GetCooperationLevel = function(ally)
 /**
  * Switch a defense army into an attack if needed.
  */
-PETRA.DefenseManager.prototype.switchToAttack = function(gameState, army)
+DELPHI.DefenseManager.prototype.switchToAttack = function(gameState, army)
 {
 	if (!army)
 		return;
@@ -915,12 +918,12 @@ PETRA.DefenseManager.prototype.switchToAttack = function(gameState, army)
 		let target = gameState.getEntityById(targetId);
 		if (!target || !target.position() || !gameState.isPlayerEnemy(target.owner()))
 			continue;
-		let targetAccess = PETRA.getLandAccess(gameState, target);
+		let targetAccess = DELPHI.getLandAccess(gameState, target);
 		let targetPos = target.position();
 		for (let entId of army.ownEntities)
 		{
 			let ent = gameState.getEntityById(entId);
-			if (!ent || !ent.position() || PETRA.getLandAccess(gameState, ent) != targetAccess)
+			if (!ent || !ent.position() || DELPHI.getLandAccess(gameState, ent) != targetAccess)
 				continue;
 			if (API3.SquareVectorDistance(targetPos, ent.position()) > 14400)
 				continue;
@@ -930,7 +933,7 @@ PETRA.DefenseManager.prototype.switchToAttack = function(gameState, army)
 	}
 };
 
-PETRA.DefenseManager.prototype.Serialize = function()
+DELPHI.DefenseManager.prototype.Serialize = function()
 {
 	let properties = {
 		"targetList": this.targetList,
@@ -947,7 +950,7 @@ PETRA.DefenseManager.prototype.Serialize = function()
 	return { "properties": properties, "armies": armies };
 };
 
-PETRA.DefenseManager.prototype.Deserialize = function(gameState, data)
+DELPHI.DefenseManager.prototype.Deserialize = function(gameState, data)
 {
 	for (let key in data.properties)
 		this[key] = data.properties[key];
@@ -955,7 +958,7 @@ PETRA.DefenseManager.prototype.Deserialize = function(gameState, data)
 	this.armies = [];
 	for (let dataArmy of data.armies)
 	{
-		let army = new PETRA.DefenseArmy(gameState, []);
+		let army = new DELPHI.DefenseArmy(gameState, []);
 		army.Deserialize(dataArmy);
 		this.armies.push(army);
 	}
diff --git a/binaries/data/mods/public/simulation/ai/delphi/diplomacyManager.js b/binaries/data/mods/public/simulation/ai/delphi/diplomacyManager.js
index f7e98d804e..9ac3337f5f 100644
--- a/binaries/data/mods/public/simulation/ai/delphi/diplomacyManager.js
+++ b/binaries/data/mods/public/simulation/ai/delphi/diplomacyManager.js
@@ -20,7 +20,7 @@
  * sent through AIInterface. It is expected that the other player will change their diplomacy stance to the stance
  * that we suggested within a period of time, or else the request will be deleted from this.sentDiplomacyRequests.
  */
-PETRA.DiplomacyManager = function(Config)
+DELPHI.DiplomacyManager = function(Config)
 {
 	this.Config = Config;
 	this.nextTributeUpdate = 90;
@@ -38,7 +38,7 @@ PETRA.DiplomacyManager = function(Config)
  * If there are any players that are allied/neutral with us but we are not allied/neutral with them,
  * treat this situation like an ally/neutral request.
  */
-PETRA.DiplomacyManager.prototype.init = function(gameState)
+DELPHI.DiplomacyManager.prototype.init = function(gameState)
 {
 	this.lastManStandingCheck(gameState);
 
@@ -60,7 +60,7 @@ PETRA.DiplomacyManager.prototype.init = function(gameState)
  * Check if any allied needs help (tribute) and sent it if we have enough resource
  * or ask for a tribute if we are in need and one ally can help
  */
-PETRA.DiplomacyManager.prototype.tributes = function(gameState)
+DELPHI.DiplomacyManager.prototype.tributes = function(gameState)
 {
 	this.nextTributeUpdate = gameState.ai.elapsedTime + 30;
 	let resTribCodes = Resources.GetTributableCodes();
@@ -104,7 +104,7 @@ PETRA.DiplomacyManager.prototype.tributes = function(gameState)
 					{
 						this.nextTributeRequest.set("all", gameState.ai.elapsedTime + 90);
 						this.nextTributeRequest.set(res, gameState.ai.elapsedTime + 240);
-						PETRA.chatRequestTribute(gameState, res);
+						DELPHI.chatRequestTribute(gameState, res);
 						if (this.Config.debug > 1)
 							API3.warn("Tribute on " + res + " requested to player " + i);
 						break;
@@ -117,12 +117,12 @@ PETRA.DiplomacyManager.prototype.tributes = function(gameState)
 		if (this.Config.debug > 1)
 			API3.warn("Tribute " + uneval(tribute) + " sent to player " + i);
 		if (this.Config.chat)
-			PETRA.chatSentTribute(gameState, i);
+			DELPHI.chatSentTribute(gameState, i);
 		Engine.PostCommand(PlayerID, { "type": "tribute", "player": i, "amounts": tribute });
 	}
 };
 
-PETRA.DiplomacyManager.prototype.checkEvents = function(gameState, events)
+DELPHI.DiplomacyManager.prototype.checkEvents = function(gameState, events)
 {
 	// Increase slowly the cooperative personality trait either when we receive tribute from our allies
 	// or if our allies attack enemies inside our territory
@@ -214,7 +214,7 @@ PETRA.DiplomacyManager.prototype.checkEvents = function(gameState, events)
 		{
 			let response = request !== undefined && (request.status === "declinedRequest" || request.status === "allianceBroken") ?
 				"decline" : "declineSuggestNeutral";
-			PETRA.chatAnswerRequestDiplomacy(gameState, evt.player, "ally", response);
+			DELPHI.chatAnswerRequestDiplomacy(gameState, evt.player, "ally", response);
 		}
 		else if (gameState.sharedScript.playersData[evt.player].isAlly[PlayerID] && gameState.isPlayerNeutral(evt.player))
 			this.handleDiplomacyRequest(gameState, evt.player, "ally");
@@ -270,7 +270,7 @@ PETRA.DiplomacyManager.prototype.checkEvents = function(gameState, events)
  * If the "Last Man Standing" option is enabled, check if the only remaining players are allies or neutral.
  * If so, turn against the strongest first, but be more likely to first turn against neutral players, if there are any.
  */
-PETRA.DiplomacyManager.prototype.lastManStandingCheck = function(gameState)
+DELPHI.DiplomacyManager.prototype.lastManStandingCheck = function(gameState)
 {
 	if (gameState.sharedScript.playersData[PlayerID].teamsLocked || gameState.isCeasefireActive() ||
 	    gameState.getAlliedVictory() && gameState.hasAllies())
@@ -351,7 +351,7 @@ PETRA.DiplomacyManager.prototype.lastManStandingCheck = function(gameState)
 		if (request && request.status !== "allianceBroken")
 		{
 			if (request.status === "waitingForTribute")
-				PETRA.chatAnswerRequestDiplomacy(gameState, player, request.requestType, "decline");
+				DELPHI.chatAnswerRequestDiplomacy(gameState, player, request.requestType, "decline");
 			request.status = request.status === "accepted" ? "allianceBroken" : "declinedRequest";
 		}
 		// If we had sent this player a diplomacy request, just rescind it
@@ -365,7 +365,7 @@ PETRA.DiplomacyManager.prototype.lastManStandingCheck = function(gameState)
  * Do not become allies with a player if the game would be over.
  * Overall, be reluctant to become allies with any one player, but be more likely to accept neutral requests.
  */
-PETRA.DiplomacyManager.prototype.handleDiplomacyRequest = function(gameState, player, requestType)
+DELPHI.DiplomacyManager.prototype.handleDiplomacyRequest = function(gameState, player, requestType)
 {
 	if (gameState.sharedScript.playersData[PlayerID].teamsLocked)
 		return;
@@ -426,10 +426,10 @@ PETRA.DiplomacyManager.prototype.handleDiplomacyRequest = function(gameState, pl
 			response = "decline";
 		}
 	}
-	PETRA.chatAnswerRequestDiplomacy(gameState, player, requestType, response, requiredTribute);
+	DELPHI.chatAnswerRequestDiplomacy(gameState, player, requestType, response, requiredTribute);
 };
 
-PETRA.DiplomacyManager.prototype.changePlayerDiplomacy = function(gameState, player, newDiplomaticStance)
+DELPHI.DiplomacyManager.prototype.changePlayerDiplomacy = function(gameState, player, newDiplomaticStance)
 {
 	if (gameState.isPlayerEnemy(player) && (newDiplomaticStance === "ally" || newDiplomaticStance === "neutral"))
 		gameState.ai.HQ.attackManager.cancelAttacksAgainstPlayer(gameState, player);
@@ -437,10 +437,10 @@ PETRA.DiplomacyManager.prototype.changePlayerDiplomacy = function(gameState, pla
 	if (this.Config.debug > 1)
 		API3.warn("diplomacy stance with player " + player + " is now " + newDiplomaticStance);
 	if (this.Config.chat)
-		PETRA.chatNewDiplomacy(gameState, player, newDiplomaticStance);
+		DELPHI.chatNewDiplomacy(gameState, player, newDiplomaticStance);
 };
 
-PETRA.DiplomacyManager.prototype.checkRequestedTributes = function(gameState)
+DELPHI.DiplomacyManager.prototype.checkRequestedTributes = function(gameState)
 {
 	for (let [player, data] of this.receivedDiplomacyRequests)
 		if (data.status === "waitingForTribute" && gameState.ai.elapsedTime > data.warnTime)
@@ -448,13 +448,13 @@ PETRA.DiplomacyManager.prototype.checkRequestedTributes = function(gameState)
 			if (data.sentWarning)
 			{
 				this.receivedDiplomacyRequests.delete(player);
-				PETRA.chatAnswerRequestDiplomacy(gameState, player, data.requestType, "decline");
+				DELPHI.chatAnswerRequestDiplomacy(gameState, player, data.requestType, "decline");
 			}
 			else
 			{
 				data.sentWarning = true;
 				data.warnTime = gameState.ai.elapsedTime + 60;
-				PETRA.chatAnswerRequestDiplomacy(gameState, player, data.requestType, "waitingForTribute", {
+				DELPHI.chatAnswerRequestDiplomacy(gameState, player, data.requestType, "waitingForTribute", {
 					"wanted": data.wanted,
 					"type": data.type
 				});
@@ -466,7 +466,7 @@ PETRA.DiplomacyManager.prototype.checkRequestedTributes = function(gameState)
  * Try to become allies with a player who has a lot of mutual enemies in common with us.
  * TODO: Possibly let human players demand tributes from AIs who send diplomacy requests.
  */
-PETRA.DiplomacyManager.prototype.sendDiplomacyRequest = function(gameState)
+DELPHI.DiplomacyManager.prototype.sendDiplomacyRequest = function(gameState)
 {
 	let player;
 	let max = 0;
@@ -505,21 +505,21 @@ PETRA.DiplomacyManager.prototype.sendDiplomacyRequest = function(gameState)
 	if (this.Config.debug > 0)
 		API3.warn("Sending diplomacy request to player " + player + " with " + requestType);
 	Engine.PostCommand(PlayerID, { "type": "diplomacy-request", "source": PlayerID, "player": player, "to": requestType });
-	PETRA.chatNewRequestDiplomacy(gameState, player, requestType, "sendRequest");
+	DELPHI.chatNewRequestDiplomacy(gameState, player, requestType, "sendRequest");
 };
 
-PETRA.DiplomacyManager.prototype.checkSentDiplomacyRequests = function(gameState)
+DELPHI.DiplomacyManager.prototype.checkSentDiplomacyRequests = function(gameState)
 {
 	for (let [player, data] of this.sentDiplomacyRequests)
 		if (gameState.ai.elapsedTime > data.timeSent + 60 && !gameState.ai.HQ.saveResources &&
 		    gameState.getPopulation() > 70)
 		{
-			PETRA.chatNewRequestDiplomacy(gameState, player, data.requestType, "requestExpired");
+			DELPHI.chatNewRequestDiplomacy(gameState, player, data.requestType, "requestExpired");
 			this.sentDiplomacyRequests.delete(player);
 		}
 };
 
-PETRA.DiplomacyManager.prototype.update = function(gameState, events)
+DELPHI.DiplomacyManager.prototype.update = function(gameState, events)
 {
 	this.checkEvents(gameState, events);
 
@@ -547,7 +547,7 @@ PETRA.DiplomacyManager.prototype.update = function(gameState, events)
 	this.checkSentDiplomacyRequests(gameState);
 };
 
-PETRA.DiplomacyManager.prototype.Serialize = function()
+DELPHI.DiplomacyManager.prototype.Serialize = function()
 {
 	return {
 		"nextTributeUpdate": this.nextTributeUpdate,
@@ -561,7 +561,7 @@ PETRA.DiplomacyManager.prototype.Serialize = function()
 	};
 };
 
-PETRA.DiplomacyManager.prototype.Deserialize = function(data)
+DELPHI.DiplomacyManager.prototype.Deserialize = function(data)
 {
 	for (let key in data)
 		this[key] = data[key];
diff --git a/binaries/data/mods/public/simulation/ai/delphi/entityExtend.js b/binaries/data/mods/public/simulation/ai/delphi/entityExtend.js
index c592d06179..7e7679c0ce 100644
--- a/binaries/data/mods/public/simulation/ai/delphi/entityExtend.js
+++ b/binaries/data/mods/public/simulation/ai/delphi/entityExtend.js
@@ -1,18 +1,18 @@
 /** returns true if this unit should be considered as a siege unit */
-PETRA.isSiegeUnit = function(ent)
+DELPHI.isSiegeUnit = function(ent)
 {
 	return ent.hasClasses(["Siege", "Elephant+Melee"]);
 };
 
 /** returns true if this unit should be considered as "fast". */
-PETRA.isFastMoving = function(ent)
+DELPHI.isFastMoving = function(ent)
 {
 	// TODO: use clever logic based on walkspeed comparisons.
 	return ent.hasClass("FastMoving");
 };
 
 /** returns some sort of DPS * health factor. If you specify a class, it'll use the modifiers against that class too. */
-PETRA.getMaxStrength = function(ent, debugLevel, DamageTypeImportance, againstClass)
+DELPHI.getMaxStrength = function(ent, debugLevel, DamageTypeImportance, againstClass)
 {
 	let strength = 0;
 	let attackTypes = ent.attackTypes();
@@ -34,7 +34,7 @@ PETRA.getMaxStrength = function(ent, debugLevel, DamageTypeImportance, againstCl
 			if (DamageTypeImportance[str])
 				strength += DamageTypeImportance[str] * val / damageTypes.length;
 			else if (debugLevel > 0)
-				API3.warn("Petra: " + str + " unknown attackStrength in getMaxStrength (please add " + str + "  to config.js).");
+				API3.warn("Delphi: " + str + " unknown attackStrength in getMaxStrength (please add " + str + "  to config.js).");
 		}
 
 		let attackRange = ent.attackRange(type);
@@ -54,7 +54,7 @@ PETRA.getMaxStrength = function(ent, debugLevel, DamageTypeImportance, againstCl
 				strength -= val / 100000;
 				break;
 			default:
-				API3.warn("Petra: " + str + " unknown attackTimes in getMaxStrength");
+				API3.warn("Delphi: " + str + " unknown attackTimes in getMaxStrength");
 			}
 		}
 	}
@@ -68,7 +68,7 @@ PETRA.getMaxStrength = function(ent, debugLevel, DamageTypeImportance, againstCl
 			if (DamageTypeImportance[str])
 				strength += DamageTypeImportance[str] * val / damageTypes.length;
 			else if (debugLevel > 0)
-				API3.warn("Petra: " + str + " unknown resistanceStrength in getMaxStrength (please add " + str + "  to config.js).");
+				API3.warn("Delphi: " + str + " unknown resistanceStrength in getMaxStrength (please add " + str + "  to config.js).");
 		}
 
 	// ToDo: Add support for StatusEffects and Capture.
@@ -77,19 +77,19 @@ PETRA.getMaxStrength = function(ent, debugLevel, DamageTypeImportance, againstCl
 };
 
 /** Get access and cache it (except for units as it can change) in metadata if not already done */
-PETRA.getLandAccess = function(gameState, ent)
+DELPHI.getLandAccess = function(gameState, ent)
 {
 	if (ent.hasClass("Unit"))
 	{
 		let pos = ent.position();
 		if (!pos)
 		{
-			let holder = PETRA.getHolder(gameState, ent);
+			let holder = DELPHI.getHolder(gameState, ent);
 			if (holder)
-				return PETRA.getLandAccess(gameState, holder);
+				return DELPHI.getLandAccess(gameState, holder);
 
-			API3.warn("Petra error: entity without position, but not garrisoned");
-			PETRA.dumpEntity(ent);
+			API3.warn("Delphi error: entity without position, but not garrisoned");
+			DELPHI.dumpEntity(ent);
 			return undefined;
 		}
 		return gameState.ai.accessibility.getAccessValue(pos);
@@ -125,7 +125,7 @@ PETRA.getLandAccess = function(gameState, ent)
 };
 
 /** Sea access always cached as it never changes */
-PETRA.getSeaAccess = function(gameState, ent)
+DELPHI.getSeaAccess = function(gameState, ent)
 {
 	let sea = ent.getMetadata(PlayerID, "sea");
 	if (!sea)
@@ -151,13 +151,13 @@ PETRA.getSeaAccess = function(gameState, ent)
 	return sea;
 };
 
-PETRA.setSeaAccess = function(gameState, ent)
+DELPHI.setSeaAccess = function(gameState, ent)
 {
-	PETRA.getSeaAccess(gameState, ent);
+	DELPHI.getSeaAccess(gameState, ent);
 };
 
 /** Decide if we should try to capture (returns true) or destroy (return false) */
-PETRA.allowCapture = function(gameState, ent, target)
+DELPHI.allowCapture = function(gameState, ent, target)
 {
 	if (!target.isCapturable() || !ent.canCapture(target))
 		return false;
@@ -177,7 +177,7 @@ PETRA.allowCapture = function(gameState, ent, target)
 	let capturableTargets = gameState.ai.HQ.capturableTargets;
 	if (!capturableTargets.has(target.id()))
 	{
-		capture = ent.captureStrength() * PETRA.getAttackBonus(ent, target, "Capture");
+		capture = ent.captureStrength() * DELPHI.getAttackBonus(ent, target, "Capture");
 		capturableTargets.set(target.id(), { "strength": capture, "ents": new Set([ent.id()]) });
 	}
 	else
@@ -185,7 +185,7 @@ PETRA.allowCapture = function(gameState, ent, target)
 		let capturable = capturableTargets.get(target.id());
 		if (!capturable.ents.has(ent.id()))
 		{
-			capturable.strength += ent.captureStrength() * PETRA.getAttackBonus(ent, target, "Capture");
+			capturable.strength += ent.captureStrength() * DELPHI.getAttackBonus(ent, target, "Capture");
 			capturable.ents.add(ent.id());
 		}
 		capture = capturable.strength;
@@ -197,7 +197,7 @@ PETRA.allowCapture = function(gameState, ent, target)
 	return capture > antiCapture + sumCapturePoints/80;
 };
 
-PETRA.getAttackBonus = function(ent, target, type)
+DELPHI.getAttackBonus = function(ent, target, type)
 {
 	let attackBonus = 1;
 	if (!ent.get("Attack/" + type) || !ent.get("Attack/" + type + "/Bonuses"))
@@ -215,7 +215,7 @@ PETRA.getAttackBonus = function(ent, target, type)
 };
 
 /** Makes the worker deposit the currently carried resources at the closest accessible dropsite */
-PETRA.returnResources = function(gameState, ent)
+DELPHI.returnResources = function(gameState, ent)
 {
 	if (!ent.resourceCarrying() || !ent.resourceCarrying().length || !ent.position())
 		return false;
@@ -224,7 +224,7 @@ PETRA.returnResources = function(gameState, ent)
 
 	let closestDropsite;
 	let distmin = Math.min();
-	let access = PETRA.getLandAccess(gameState, ent);
+	let access = DELPHI.getLandAccess(gameState, ent);
 	let dropsiteCollection = gameState.playerData.hasSharedDropsites ?
 	                         gameState.getAnyDropsites(resource) : gameState.getOwnDropsites(resource);
 	for (let dropsite of dropsiteCollection.values())
@@ -235,7 +235,7 @@ PETRA.returnResources = function(gameState, ent)
 		// owner !== PlayerID can only happen when hasSharedDropsites === true, so no need to test it again
 		if (owner !== PlayerID && (!dropsite.isSharedDropsite() || !gameState.isPlayerMutualAlly(owner)))
 			continue;
-		if (PETRA.getLandAccess(gameState, dropsite) != access)
+		if (DELPHI.getLandAccess(gameState, dropsite) != access)
 			continue;
 		let dist = API3.SquareVectorDistance(ent.position(), dropsite.position());
 		if (dist > distmin)
@@ -251,7 +251,7 @@ PETRA.returnResources = function(gameState, ent)
 };
 
 /** is supply full taking into account gatherers affected during this turn */
-PETRA.IsSupplyFull = function(gameState, ent)
+DELPHI.IsSupplyFull = function(gameState, ent)
 {
 	return ent.isFull() === true ||
 		ent.resourceSupplyNumGatherers() + gameState.ai.HQ.GetTCGatherer(ent.id()) >= ent.maxGatherers();
@@ -263,24 +263,24 @@ PETRA.IsSupplyFull = function(gameState, ent)
  * If nothing found, return the base[0] for units and undefined for structures.
  * If exclude is given, we exclude the base with ID = exclude.
  */
-PETRA.getBestBase = function(gameState, ent, onlyConstructedBase = false, exclude = false)
+DELPHI.getBestBase = function(gameState, ent, onlyConstructedBase = false, exclude = false)
 {
 	let pos = ent.position();
 	let accessIndex;
 	if (!pos)
 	{
-		let holder = PETRA.getHolder(gameState, ent);
+		let holder = DELPHI.getHolder(gameState, ent);
 		if (!holder || !holder.position())
 		{
-			API3.warn("Petra error: entity without position, but not garrisoned");
-			PETRA.dumpEntity(ent);
+			API3.warn("Delphi error: entity without position, but not garrisoned");
+			DELPHI.dumpEntity(ent);
 			return gameState.ai.HQ.baseManagers[0];
 		}
 		pos = holder.position();
-		accessIndex = PETRA.getLandAccess(gameState, holder);
+		accessIndex = DELPHI.getLandAccess(gameState, holder);
 	}
 	else
-		accessIndex = PETRA.getLandAccess(gameState, ent);
+		accessIndex = DELPHI.getLandAccess(gameState, ent);
 
 	let distmin = Math.min();
 	let dist;
@@ -323,7 +323,7 @@ PETRA.getBestBase = function(gameState, ent, onlyConstructedBase = false, exclud
 	return bestbase;
 };
 
-PETRA.getHolder = function(gameState, ent)
+DELPHI.getHolder = function(gameState, ent)
 {
 	for (let holder of gameState.getEntities().values())
 	{
@@ -334,7 +334,7 @@ PETRA.getHolder = function(gameState, ent)
 };
 
 /** return the template of the built foundation if a foundation, otherwise return the entity itself */
-PETRA.getBuiltEntity = function(gameState, ent)
+DELPHI.getBuiltEntity = function(gameState, ent)
 {
 	if (ent.foundationProgress() !== undefined)
 		return gameState.getBuiltTemplate(ent.templateName());
@@ -346,7 +346,7 @@ PETRA.getBuiltEntity = function(gameState, ent)
  * return true if it is not worth finishing this building (it would surely decay)
  * TODO implement the other conditions
  */
-PETRA.isNotWorthBuilding = function(gameState, ent)
+DELPHI.isNotWorthBuilding = function(gameState, ent)
 {
 	if (gameState.ai.HQ.territoryMap.getOwner(ent.position()) !== PlayerID)
 	{
@@ -360,7 +360,7 @@ PETRA.isNotWorthBuilding = function(gameState, ent)
 /**
  * Check if the straight line between the two positions crosses an enemy territory
  */
-PETRA.isLineInsideEnemyTerritory = function(gameState, pos1, pos2, step=70)
+DELPHI.isLineInsideEnemyTerritory = function(gameState, pos1, pos2, step=70)
 {
 	let n = Math.floor(Math.sqrt(API3.SquareVectorDistance(pos1, pos2))/step) + 1;
 	let stepx = (pos2[0] - pos1[0]) / n;
@@ -375,7 +375,7 @@ PETRA.isLineInsideEnemyTerritory = function(gameState, pos1, pos2, step=70)
 	return false;
 };
 
-PETRA.gatherTreasure = function(gameState, ent, water = false)
+DELPHI.gatherTreasure = function(gameState, ent, water = false)
 {
 	if (!gameState.ai.HQ.treasures.hasEntities())
 		return false;
@@ -385,16 +385,16 @@ PETRA.gatherTreasure = function(gameState, ent, water = false)
 		return false;
 	let treasureFound;
 	let distmin = Math.min();
-	let access = water ? PETRA.getSeaAccess(gameState, ent) : PETRA.getLandAccess(gameState, ent);
+	let access = water ? DELPHI.getSeaAccess(gameState, ent) : DELPHI.getLandAccess(gameState, ent);
 	for (let treasure of gameState.ai.HQ.treasures.values())
 	{
 		// let some time for the previous gatherer to reach the treasure before trying again
 		let lastGathered = treasure.getMetadata(PlayerID, "lastGathered");
 		if (lastGathered && gameState.ai.elapsedTime - lastGathered < 20)
 			continue;
-		if (!water && access != PETRA.getLandAccess(gameState, treasure))
+		if (!water && access != DELPHI.getLandAccess(gameState, treasure))
 			continue;
-		if (water && access != PETRA.getSeaAccess(gameState, treasure))
+		if (water && access != DELPHI.getSeaAccess(gameState, treasure))
 			continue;
 		let territoryOwner = gameState.ai.HQ.territoryMap.getOwner(treasure.position());
 		if (territoryOwner != 0 && !gameState.isPlayerAlly(territoryOwner))
@@ -415,7 +415,7 @@ PETRA.gatherTreasure = function(gameState, ent, water = false)
 	return true;
 };
 
-PETRA.dumpEntity = function(ent)
+DELPHI.dumpEntity = function(ent)
 {
 	if (!ent)
 		return;
diff --git a/binaries/data/mods/public/simulation/ai/delphi/garrisonManager.js b/binaries/data/mods/public/simulation/ai/delphi/garrisonManager.js
index a1333a9f05..3e182e2be3 100644
--- a/binaries/data/mods/public/simulation/ai/delphi/garrisonManager.js
+++ b/binaries/data/mods/public/simulation/ai/delphi/garrisonManager.js
@@ -6,14 +6,14 @@
  * Futhermore garrison units have a metadata garrisonType describing its reason (protection, transport, ...)
  */
 
-PETRA.GarrisonManager = function(Config)
+DELPHI.GarrisonManager = function(Config)
 {
 	this.Config = Config;
 	this.holders = new Map();
 	this.decayingStructures = new Map();
 };
 
-PETRA.GarrisonManager.prototype.update = function(gameState, events)
+DELPHI.GarrisonManager.prototype.update = function(gameState, events)
 {
 	// First check for possible upgrade of a structure
 	for (let evt of events.EntityRenamed)
@@ -106,10 +106,10 @@ PETRA.GarrisonManager.prototype.update = function(gameState, events)
 				{
 					if (gameState.ai.Config.debug > 0)
 					{
-						API3.warn("Petra garrison error: unit " + ent.id() + " (" + ent.genericName() +
+						API3.warn("Delphi garrison error: unit " + ent.id() + " (" + ent.genericName() +
 							  ") is expected to garrison in " + id + " (" + holder.genericName() +
 							  "), but has no such garrison order " + uneval(ent.unitAIOrderData()));
-						PETRA.dumpEntity(ent);
+						DELPHI.dumpEntity(ent);
 					}
 					list.splice(j--, 1);
 				}
@@ -145,7 +145,7 @@ PETRA.GarrisonManager.prototype.update = function(gameState, events)
 					continue;
 				if (ent.hasClass("Structure"))
 					around.defenseStructure = true;
-				else if (PETRA.isSiegeUnit(ent))
+				else if (DELPHI.isSiegeUnit(ent))
 				{
 					if (ent.attackTypes().indexOf("Melee") !== -1)
 						around.meleeSiege = true;
@@ -199,7 +199,7 @@ PETRA.GarrisonManager.prototype.update = function(gameState, events)
 };
 
 /** TODO should add the units garrisoned inside garrisoned units */
-PETRA.GarrisonManager.prototype.numberOfGarrisonedUnits = function(holder)
+DELPHI.GarrisonManager.prototype.numberOfGarrisonedSlots = function(holder)
 {
 	if (!this.holders.has(holder.id()))
 		return holder.garrisoned().length;
@@ -208,7 +208,7 @@ PETRA.GarrisonManager.prototype.numberOfGarrisonedUnits = function(holder)
 };
 
 /** TODO should add the units garrisoned inside garrisoned units */
-PETRA.GarrisonManager.prototype.numberOfGarrisonedSlots = function(holder)
+DELPHI.GarrisonManager.prototype.numberOfGarrisonedSlots = function(holder)
 {
 	if (!this.holders.has(holder.id()))
 		return holder.garrisonedSlots();
@@ -216,7 +216,7 @@ PETRA.GarrisonManager.prototype.numberOfGarrisonedSlots = function(holder)
 	return holder.garrisonedSlots() + this.holders.get(holder.id()).list.length;
 };
 
-PETRA.GarrisonManager.prototype.allowMelee = function(holder)
+DELPHI.GarrisonManager.prototype.allowMelee = function(holder)
 {
 	if (!this.holders.has(holder.id()))
 		return undefined;
@@ -225,7 +225,7 @@ PETRA.GarrisonManager.prototype.allowMelee = function(holder)
 };
 
 /** This is just a pre-garrison state, while the entity walk to the garrison holder */
-PETRA.GarrisonManager.prototype.garrison = function(gameState, ent, holder, type)
+DELPHI.GarrisonManager.prototype.garrison = function(gameState, ent, holder, type)
 {
 	if (this.numberOfGarrisonedSlots(holder) >= holder.garrisonMax() || !ent.canGarrison())
 		return;
@@ -256,7 +256,7 @@ PETRA.GarrisonManager.prototype.garrison = function(gameState, ent, holder, type
  This function is for internal use inside garrisonManager. From outside, you should also update
  the holder and then using cancelGarrison should be the preferred solution
  */
-PETRA.GarrisonManager.prototype.leaveGarrison = function(ent)
+DELPHI.GarrisonManager.prototype.leaveGarrison = function(ent)
 {
 	ent.setMetadata(PlayerID, "subrole", undefined);
 	if (ent.getMetadata(PlayerID, "plan") === -2)
@@ -267,7 +267,7 @@ PETRA.GarrisonManager.prototype.leaveGarrison = function(ent)
 };
 
 /** Cancel a pre-garrison state */
-PETRA.GarrisonManager.prototype.cancelGarrison = function(ent)
+DELPHI.GarrisonManager.prototype.cancelGarrison = function(ent)
 {
 	ent.stopMoving();
 	this.leaveGarrison(ent);
@@ -280,7 +280,7 @@ PETRA.GarrisonManager.prototype.cancelGarrison = function(ent)
 		list.splice(index, 1);
 };
 
-PETRA.GarrisonManager.prototype.keepGarrisoned = function(ent, holder, around)
+DELPHI.GarrisonManager.prototype.keepGarrisoned = function(ent, holder, around)
 {
 	switch (ent.getMetadata(PlayerID, "garrisonType"))
 	{
@@ -305,8 +305,8 @@ PETRA.GarrisonManager.prototype.keepGarrisoned = function(ent, holder, around)
 		if (ent.attackTypes() && ent.attackTypes().indexOf("Melee") !== -1)
 			return false;
 		if (around.unit)
-			return ent.hasClass("Support") || PETRA.isSiegeUnit(ent);	// only ranged siege here and below as melee siege already released above
-		if (PETRA.isSiegeUnit(ent))
+			return ent.hasClass("Support") || DELPHI.isSiegeUnit(ent);	// only ranged siege here and below as melee siege already released above
+		if (DELPHI.isSiegeUnit(ent))
 			return around.meleeSiege;
 		return holder.buffHeal() && ent.needsHeal();
 	case 'decay':
@@ -330,7 +330,7 @@ PETRA.GarrisonManager.prototype.keepGarrisoned = function(ent, holder, around)
 };
 
 /** Add this holder in the list managed by the garrisonManager */
-PETRA.GarrisonManager.prototype.registerHolder = function(gameState, holder)
+DELPHI.GarrisonManager.prototype.registerHolder = function(gameState, holder)
 {
 	if (this.holders.has(holder.id()))    // already registered
 		return;
@@ -343,7 +343,7 @@ PETRA.GarrisonManager.prototype.registerHolder = function(gameState, holder)
  * do it only for structures useful for defense, except if we are expanding (justCaptured=true)
  * in which case we also do it for structures useful for unit trainings (TODO only Barracks are done)
  */
-PETRA.GarrisonManager.prototype.addDecayingStructure = function(gameState, entId, justCaptured)
+DELPHI.GarrisonManager.prototype.addDecayingStructure = function(gameState, entId, justCaptured)
 {
 	if (this.decayingStructures.has(entId))
 		return true;
@@ -357,19 +357,19 @@ PETRA.GarrisonManager.prototype.addDecayingStructure = function(gameState, entId
 	return true;
 };
 
-PETRA.GarrisonManager.prototype.removeDecayingStructure = function(entId)
+DELPHI.GarrisonManager.prototype.removeDecayingStructure = function(entId)
 {
 	if (!this.decayingStructures.has(entId))
 		return;
 	this.decayingStructures.delete(entId);
 };
 
-PETRA.GarrisonManager.prototype.Serialize = function()
+DELPHI.GarrisonManager.prototype.Serialize = function()
 {
 	return { "holders": this.holders, "decayingStructures": this.decayingStructures };
 };
 
-PETRA.GarrisonManager.prototype.Deserialize = function(data)
+DELPHI.GarrisonManager.prototype.Deserialize = function(data)
 {
 	for (let key in data)
 		this[key] = data[key];
diff --git a/binaries/data/mods/public/simulation/ai/delphi/headquarters.js b/binaries/data/mods/public/simulation/ai/delphi/headquarters.js
index b53a2baaee..8ca9aa2aec 100644
--- a/binaries/data/mods/public/simulation/ai/delphi/headquarters.js
+++ b/binaries/data/mods/public/simulation/ai/delphi/headquarters.js
@@ -11,7 +11,7 @@
  *  -planning attacks -> attackManager
  *  -picking new CC locations.
  */
-PETRA.HQ = function(Config)
+DELPHI.HQ = function(Config)
 {
 	this.Config = Config;
 	this.phasing = 0;	// existing values: 0 means no, i > 0 means phasing towards phase i
@@ -36,31 +36,57 @@ PETRA.HQ = function(Config)
 	this.extraFortresses = Math.round(Math.max(Math.min(this.Config.difficulty - 1, 2), 0) * this.Config.personality.defensive);
 
 	this.baseManagers = [];
-	this.attackManager = new PETRA.AttackManager(this.Config);
-	this.buildManager = new PETRA.BuildManager();
-	this.defenseManager = new PETRA.DefenseManager(this.Config);
-	this.tradeManager = new PETRA.TradeManager(this.Config);
-	this.navalManager = new PETRA.NavalManager(this.Config);
-	this.researchManager = new PETRA.ResearchManager(this.Config);
-	this.diplomacyManager = new PETRA.DiplomacyManager(this.Config);
-	this.garrisonManager = new PETRA.GarrisonManager(this.Config);
-	this.victoryManager = new PETRA.VictoryManager(this.Config);
+	this.attackManager = new DELPHI.AttackManager(this.Config);
+	this.buildManager = new DELPHI.BuildManager();
+	this.defenseManager = new DELPHI.DefenseManager(this.Config);
+	this.tradeManager = new DELPHI.TradeManager(this.Config);
+	this.navalManager = new DELPHI.NavalManager(this.Config);
+	this.researchManager = new DELPHI.ResearchManager(this.Config);
+	this.diplomacyManager = new DELPHI.DiplomacyManager(this.Config);
+	this.garrisonManager = new DELPHI.GarrisonManager(this.Config);
+	this.victoryManager = new DELPHI.VictoryManager(this.Config);
 
 	this.capturableTargets = new Map();
 	this.capturableTargetsTime = 0;
 };
 
 /** More initialisation for stuff that needs the gameState */
-PETRA.HQ.prototype.init = function(gameState, queues)
+DELPHI.HQ.prototype.init = function(gameState, queues)
 {
-	this.territoryMap = PETRA.createTerritoryMap(gameState);
+	this.territoryMap = DELPHI.createTerritoryMap(gameState);
 	// initialize base map. Each pixel is a base ID, or 0 if not or not accessible
 	this.basesMap = new API3.Map(gameState.sharedScript, "territory");
 	// create borderMap: flag cells on the border of the map
 	// then this map will be completed with our frontier in updateTerritories
-	this.borderMap = PETRA.createBorderMap(gameState);
+	this.borderMap = DELPHI.createBorderMap(gameState);
 	// list of allowed regions
 	this.landRegions = {};
+	// cache of shoreline tiles for terrain maps
+	this.shoreTiles = (() => {
+		let tiles = [];
+		let waterValues = new Map();// counts size of water bodies
+		for (let i in gameState.ai.accessibility.map) {
+			if (gameState.ai.accessibility.map[i] === 201)
+			{
+				let landVal = gameState.ai.accessibility.landPassMap[i];
+				let waterVal = gameState.ai.accessibility.navalPassMap[i];
+				tiles.push({
+					'index': i,
+					'land': landVal,
+					'water': waterVal
+				});
+				if (waterValues.hasOwnProperty(waterVal))
+					waterValues[waterVal] += 1;
+				else
+					waterValues[waterVal] = 1;
+			}
+		}// end for i in gameState.ai.accessibility.map
+		for (let i in tiles) {
+			let tile = tiles[i];
+			tile['waterValue'] = waterValues[tile['water']];
+		}// end for i in tiles
+		return tiles;
+	})();
 	// try to determine if we have a water map
 	this.navalMap = false;
 	this.navalRegions = {};
@@ -74,13 +100,14 @@ PETRA.HQ.prototype.init = function(gameState, queues)
 /**
  * initialization needed after deserialization (only called when deserialization)
  */
-PETRA.HQ.prototype.postinit = function(gameState)
+DELPHI.HQ.prototype.postinit = function(gameState)
 {
 	// Rebuild the base maps from the territory indices of each base
 	this.basesMap = new API3.Map(gameState.sharedScript, "territory");
 	for (let base of this.baseManagers)
-		for (let j of base.territoryIndices)
-			this.basesMap.map[j] = base.ID;
+		if (base)
+			for (let j of base.territoryIndices)
+				this.basesMap.map[j] = base.ID;
 
 	for (let ent of gameState.getOwnEntities().values())
 	{
@@ -92,7 +119,8 @@ PETRA.HQ.prototype.postinit = function(gameState)
 		if (baseID === undefined)
 			continue;
 		let base = this.getBaseByID(baseID);
-		base.assignResourceToDropsite(gameState, ent);
+		if (base)
+			base.assignResourceToDropsite(gameState, ent);
 	}
 
 	this.updateTerritories(gameState);
@@ -108,12 +136,14 @@ PETRA.HQ.prototype.postinit = function(gameState)
  *              "captured"      => captured base with an anchor
  *              "anchorless"    => anchorless base, currently with dock
  */
-PETRA.HQ.prototype.createBase = function(gameState, ent, type)
+DELPHI.HQ.prototype.createBase = function(gameState, ent, type)
 {
-	let access = PETRA.getLandAccess(gameState, ent);
+	let access = DELPHI.getLandAccess(gameState, ent);
 	let newbase;
 	for (let base of this.baseManagers)
 	{
+		if (!base)
+			continue;
 		if (base.accessIndex != access)
 			continue;
 		if (type != "anchorless" && base.anchor)
@@ -147,7 +177,7 @@ PETRA.HQ.prototype.createBase = function(gameState, ent, type)
 
 	if (!newbase)
 	{
-		newbase = new PETRA.BaseManager(gameState, this.Config);
+		newbase = new DELPHI.BaseManager(gameState, this.Config);
 		newbase.init(gameState, type);
 		this.baseManagers.push(newbase);
 	}
@@ -167,7 +197,7 @@ PETRA.HQ.prototype.createBase = function(gameState, ent, type)
  * otherwise return undefined
  * for the moment, only the case land-sea-land is supported
  */
-PETRA.HQ.prototype.getSeaBetweenIndices = function(gameState, index1, index2)
+DELPHI.HQ.prototype.getSeaBetweenIndices = function(gameState, index1, index2)
 {
 	let path = gameState.ai.accessibility.getTrajectToIndex(index1, index2);
 	if (path && path.length == 3 && gameState.ai.accessibility.regionType[path[1]] == "water")
@@ -183,7 +213,7 @@ PETRA.HQ.prototype.getSeaBetweenIndices = function(gameState, index1, index2)
 };
 
 /** TODO check if the new anchorless bases should be added to addBase */
-PETRA.HQ.prototype.checkEvents = function(gameState, events)
+DELPHI.HQ.prototype.checkEvents = function(gameState, events)
 {
 	let addBase = false;
 
@@ -214,6 +244,8 @@ PETRA.HQ.prototype.checkEvents = function(gameState, events)
 			if (evt.metadata[PlayerID].base == -1 || evt.metadata[PlayerID].base == -2)
 				continue;
 			let base = this.getBaseByID(evt.metadata[PlayerID].base);
+			if (!base)
+				continue;
 			if (ent.resourceDropsiteTypes() && ent.hasClass("Structure"))
 				base.removeDropsite(gameState, ent);
 			if (evt.metadata[PlayerID].baseAnchor && evt.metadata[PlayerID].baseAnchor === true)
@@ -227,7 +259,7 @@ PETRA.HQ.prototype.checkEvents = function(gameState, events)
 		if (!ent || ent.owner() != PlayerID || ent.getMetadata(PlayerID, "base") === undefined)
 			continue;
 		let base = this.getBaseByID(ent.getMetadata(PlayerID, "base"));
-		if (!base.anchorId || base.anchorId != evt.entity)
+		if (!base || !base.anchorId || base.anchorId != evt.entity)
 			continue;
 		base.anchorId = evt.newentity;
 		base.anchor = ent;
@@ -284,6 +316,8 @@ PETRA.HQ.prototype.checkEvents = function(gameState, events)
 		if (ent.getMetadata(PlayerID, "base") === undefined)
 			continue;
 		let base = this.getBaseByID(ent.getMetadata(PlayerID, "base"));
+		if (!base)
+			continue;
 		base.buildings.updateEnt(ent);
 		if (ent.resourceDropsiteTypes())
 			base.assignResourceToDropsite(gameState, ent);
@@ -304,6 +338,8 @@ PETRA.HQ.prototype.checkEvents = function(gameState, events)
 			if (!ent || ent.getMetadata(PlayerID, "base") === undefined)
 				continue;
 			let base = this.getBaseByID(ent.getMetadata(PlayerID, "base"));
+			if (!base)
+				continue;
 			if (ent.resourceDropsiteTypes() && ent.hasClass("Structure"))
 				base.removeDropsite(gameState, ent);
 			if (ent.getMetadata(PlayerID, "baseAnchor") === true)
@@ -317,7 +353,7 @@ PETRA.HQ.prototype.checkEvents = function(gameState, events)
 			continue;
 		if (ent.hasClass("Unit"))
 		{
-			PETRA.getBestBase(gameState, ent).assignEntity(gameState, ent);
+			DELPHI.getBestBase(gameState, ent).assignEntity(gameState, ent);
 			ent.setMetadata(PlayerID, "role", undefined);
 			ent.setMetadata(PlayerID, "subrole", undefined);
 			ent.setMetadata(PlayerID, "plan", undefined);
@@ -333,7 +369,7 @@ PETRA.HQ.prototype.checkEvents = function(gameState, events)
 				ent.setMetadata(PlayerID, "subrole", "idle");
 			}
 			if (ent.hasClass("Ship"))
-				PETRA.setSeaAccess(gameState, ent);
+				DELPHI.setSeaAccess(gameState, ent);
 			if (!ent.hasClasses(["Support", "Ship"]) && ent.attackTypes() !== undefined)
 				ent.setMetadata(PlayerID, "plan", -1);
 			continue;
@@ -357,7 +393,7 @@ PETRA.HQ.prototype.checkEvents = function(gameState, events)
 			if (!ent.decaying() && ent.resourceDropsiteTypes())
 				base = this.createBase(gameState, ent, "anchorless");
 			else
-				base = PETRA.getBestBase(gameState, ent) || this.baseManagers[0];
+				base = DELPHI.getBestBase(gameState, ent) || this.baseManagers[0];
 			base.assignEntity(gameState, ent);
 			if (ent.decaying())
 			{
@@ -423,7 +459,7 @@ PETRA.HQ.prototype.checkEvents = function(gameState, events)
 				let base;
 				if (ent.getMetadata(PlayerID, "base") === undefined)
 				{
-					base = PETRA.getBestBase(gameState, ent);
+					base = DELPHI.getBestBase(gameState, ent);
 					base.assignEntity(gameState, ent);
 				}
 				else
@@ -438,12 +474,12 @@ PETRA.HQ.prototype.checkEvents = function(gameState, events)
 					continue;
 				let dropsites = gameState.getOwnDropsites(type.generic);
 				let pos = ent.position();
-				let access = PETRA.getLandAccess(gameState, ent);
+				let access = DELPHI.getLandAccess(gameState, ent);
 				let distmin = Math.min();
 				let goal;
 				for (let dropsite of dropsites.values())
 				{
-					if (!dropsite.position() || PETRA.getLandAccess(gameState, dropsite) != access)
+					if (!dropsite.position() || DELPHI.getLandAccess(gameState, dropsite) != access)
 						continue;
 					let dist = API3.SquareVectorDistance(pos, dropsite.position());
 					if (dist > distmin)
@@ -488,49 +524,10 @@ PETRA.HQ.prototype.checkEvents = function(gameState, events)
 			this.maxFields = false;
 		}
 	}
-
-	// Then deals with decaying structures: destroy them if being lost to enemy (except in easier difficulties)
-	if (this.Config.difficulty < 2)
-		return;
-	for (let entId of this.decayingStructures)
-	{
-		let ent = gameState.getEntityById(entId);
-		if (ent && ent.decaying() && ent.isOwn(PlayerID))
-		{
-			let capture = ent.capturePoints();
-			if (!capture)
-				continue;
-			let captureRatio = capture[PlayerID] / capture.reduce((a, b) => a + b);
-			if (captureRatio < 0.50)
-				continue;
-			let decayToGaia = true;
-			for (let i = 1; i < capture.length; ++i)
-			{
-				if (gameState.isPlayerAlly(i) || !capture[i])
-					continue;
-				decayToGaia = false;
-				break;
-			}
-			if (decayToGaia)
-				continue;
-			let ratioMax = 0.7 + randFloat(0, 0.1);
-			for (let evt of events.Attacked)
-			{
-				if (ent.id() != evt.target)
-					continue;
-				ratioMax = 0.85 + randFloat(0, 0.1);
-				break;
-			}
-			if (captureRatio > ratioMax)
-				continue;
-			ent.destroy();
-		}
-		this.decayingStructures.delete(entId);
-	}
 };
 
 /** Ensure that all requirements are met when phasing up*/
-PETRA.HQ.prototype.checkPhaseRequirements = function(gameState, queues)
+DELPHI.HQ.prototype.checkPhaseRequirements = function(gameState, queues)
 {
 	if (gameState.getNumberOfPhases() == this.currentPhase)
 		return;
@@ -554,21 +551,21 @@ PETRA.HQ.prototype.checkPhaseRequirements = function(gameState, queues)
 				if (!gameState.getOwnEntitiesByClass("Market", true).hasEntities() &&
 				    this.canBuild(gameState, "structures/{civ}/market"))
 				{
-					plan = new PETRA.ConstructionPlan(gameState, "structures/{civ}/market", { "phaseUp": true });
+					plan = new DELPHI.ConstructionPlan(gameState, "structures/{civ}/market", { "phaseUp": true });
 					queue = "economicBuilding";
 					break;
 				}
 				if (!gameState.getOwnEntitiesByClass("Temple", true).hasEntities() &&
 				    this.canBuild(gameState, "structures/{civ}/temple"))
 				{
-					plan = new PETRA.ConstructionPlan(gameState, "structures/{civ}/temple", { "phaseUp": true });
+					plan = new DELPHI.ConstructionPlan(gameState, "structures/{civ}/temple", { "phaseUp": true });
 					queue = "economicBuilding";
 					break;
 				}
 				if (!gameState.getOwnEntitiesByClass("Forge", true).hasEntities() &&
 				    this.canBuild(gameState, "structures/{civ}/forge"))
 				{
-					plan = new PETRA.ConstructionPlan(gameState, "structures/{civ}/forge", { "phaseUp": true });
+					plan = new DELPHI.ConstructionPlan(gameState, "structures/{civ}/forge", { "phaseUp": true });
 					queue = "militaryBuilding";
 					break;
 				}
@@ -582,7 +579,7 @@ PETRA.HQ.prototype.checkPhaseRequirements = function(gameState, queues)
 			{
 				let structure = this.buildManager.findStructureWithClass(gameState, [entityReq.class]);
 				if (structure && this.canBuild(gameState, structure))
-					plan = new PETRA.ConstructionPlan(gameState, structure, { "phaseUp": true });
+					plan = new DELPHI.ConstructionPlan(gameState, structure, { "phaseUp": true });
 			}
 		}
 
@@ -605,12 +602,12 @@ PETRA.HQ.prototype.checkPhaseRequirements = function(gameState, queues)
 };
 
 /** Called by any "phase" research plan once it's started */
-PETRA.HQ.prototype.OnPhaseUp = function(gameState, phase)
+DELPHI.HQ.prototype.OnPhaseUp = function(gameState, phase)
 {
 };
 
 /** This code trains citizen workers, trying to keep close to a ratio of worker/soldiers */
-PETRA.HQ.prototype.trainMoreWorkers = function(gameState, queues)
+DELPHI.HQ.prototype.trainMoreWorkers = function(gameState, queues)
 {
 	// default template
 	let requirementsDef = [ ["costsResource", 1, "food"] ];
@@ -710,13 +707,13 @@ PETRA.HQ.prototype.trainMoreWorkers = function(gameState, queues)
 	// If the template variable is empty, the default unit (Support unit) will be used
 	// base "0" means automatic choice of base
 	if (!template && templateDef)
-		queues.villager.addPlan(new PETRA.TrainingPlan(gameState, templateDef, { "role": "worker", "base": 0, "support": true }, size, size));
+		queues.villager.addPlan(new DELPHI.TrainingPlan(gameState, templateDef, { "role": "worker", "base": 0, "support": true }, size, size));
 	else if (template)
-		queues.citizenSoldier.addPlan(new PETRA.TrainingPlan(gameState, template, { "role": "worker", "base": 0 }, size, size));
+		queues.citizenSoldier.addPlan(new DELPHI.TrainingPlan(gameState, template, { "role": "worker", "base": 0 }, size, size));
 };
 
 /** picks the best template based on parameters and classes */
-PETRA.HQ.prototype.findBestTrainableUnit = function(gameState, classes, requirements)
+DELPHI.HQ.prototype.findBestTrainableUnit = function(gameState, classes, requirements)
 {
 	let units;
 	if (classes.indexOf("Hero") != -1)
@@ -761,13 +758,13 @@ PETRA.HQ.prototype.findBestTrainableUnit = function(gameState, classes, requirem
 		{
 			if (param[0] == "strength")
 			{
-				aValue += PETRA.getMaxStrength(a[1], gameState.ai.Config.debug, gameState.ai.Config.DamageTypeImportance) * param[1];
-				bValue += PETRA.getMaxStrength(b[1], gameState.ai.Config.debug, gameState.ai.Config.DamageTypeImportance) * param[1];
+				aValue += DELPHI.getMaxStrength(a[1], gameState.ai.Config.debug, gameState.ai.Config.DamageTypeImportance) * param[1];
+				bValue += DELPHI.getMaxStrength(b[1], gameState.ai.Config.debug, gameState.ai.Config.DamageTypeImportance) * param[1];
 			}
 			else if (param[0] == "siegeStrength")
 			{
-				aValue += PETRA.getMaxStrength(a[1], gameState.ai.Config.debug, gameState.ai.Config.DamageTypeImportance, "Structure") * param[1];
-				bValue += PETRA.getMaxStrength(b[1], gameState.ai.Config.debug, gameState.ai.Config.DamageTypeImportance, "Structure") * param[1];
+				aValue += DELPHI.getMaxStrength(a[1], gameState.ai.Config.debug, gameState.ai.Config.DamageTypeImportance, "Structure") * param[1];
+				bValue += DELPHI.getMaxStrength(b[1], gameState.ai.Config.debug, gameState.ai.Config.DamageTypeImportance, "Structure") * param[1];
 			}
 			else if (param[0] == "speed")
 			{
@@ -802,7 +799,7 @@ PETRA.HQ.prototype.findBestTrainableUnit = function(gameState, classes, requirem
  * returns an entity collection of workers through BaseManager.pickBuilders
  * TODO: when same accessIndex, sort by distance
  */
-PETRA.HQ.prototype.bulkPickWorkers = function(gameState, baseRef, number)
+DELPHI.HQ.prototype.bulkPickWorkers = function(gameState, baseRef, number)
 {
 	let accessIndex = baseRef.accessIndex;
 	if (!accessIndex)
@@ -820,7 +817,7 @@ PETRA.HQ.prototype.bulkPickWorkers = function(gameState, baseRef, number)
 	let workers = new API3.EntityCollection(gameState.sharedScript);
 	for (let base of baseBest)
 	{
-		if (base.ID == baseRef.ID)
+		if (!base || base.ID == baseRef.ID)
 			continue;
 		base.pickBuilders(gameState, workers, needed);
 		if (workers.length >= number)
@@ -832,14 +829,18 @@ PETRA.HQ.prototype.bulkPickWorkers = function(gameState, baseRef, number)
 	return workers;
 };
 
-PETRA.HQ.prototype.getTotalResourceLevel = function(gameState)
+DELPHI.HQ.prototype.getTotalResourceLevel = function(gameState)
 {
 	let total = {};
 	for (let res of Resources.GetCodes())
 		total[res] = 0;
 	for (let base of this.baseManagers)
+	{
+		if (!base)
+			continue;
 		for (let res in total)
 			total[res] += base.getResourceLevel(gameState, res);
+	}
 
 	return total;
 };
@@ -848,7 +849,7 @@ PETRA.HQ.prototype.getTotalResourceLevel = function(gameState)
  * Returns the current gather rate
  * This is not per-se exact, it performs a few adjustments ad-hoc to account for travel distance, stuffs like that.
  */
-PETRA.HQ.prototype.GetCurrentGatherRates = function(gameState)
+DELPHI.HQ.prototype.GetCurrentGatherRates = function(gameState)
 {
 	if (!this.turnCache.currentRates)
 	{
@@ -857,7 +858,11 @@ PETRA.HQ.prototype.GetCurrentGatherRates = function(gameState)
 			currentRates[res] = 0.5 * this.GetTCResGatherer(res);
 
 		for (let base of this.baseManagers)
+		{
+			if (!base)
+				continue;
 			base.addGatherRates(gameState, currentRates);
+		}
 
 		for (let res of Resources.GetCodes())
 			currentRates[res] = Math.max(currentRates[res], 0);
@@ -871,7 +876,7 @@ PETRA.HQ.prototype.GetCurrentGatherRates = function(gameState)
 /**
  * Returns the wanted gather rate.
  */
-PETRA.HQ.prototype.GetWantedGatherRates = function(gameState)
+DELPHI.HQ.prototype.GetWantedGatherRates = function(gameState)
 {
 	if (!this.turnCache.wantedRates)
 		this.turnCache.wantedRates = gameState.ai.queueManager.wantedGatherRates(gameState);
@@ -887,7 +892,7 @@ PETRA.HQ.prototype.GetWantedGatherRates = function(gameState)
  * We compare; we pick the one where the discrepancy is highest.
  * Need to balance long-term needs and possible short-term needs.
  */
-PETRA.HQ.prototype.pickMostNeededResources = function(gameState, allowedResources = [])
+DELPHI.HQ.prototype.pickMostNeededResources = function(gameState, allowedResources = [])
 {
 	let wantedRates = this.GetWantedGatherRates(gameState);
 	let currentRates = this.GetCurrentGatherRates(gameState);
@@ -918,11 +923,131 @@ PETRA.HQ.prototype.pickMostNeededResources = function(gameState, allowedResource
 	return needed;
 };
 
+// new for Delphi bot: find a civic centre position that maximizes trade revenue
+// without being too close to enemy CCs (i.e. indefensible).
+// should prefer (but not exclusively choose) locations on the shore of
+// large bodies of water in order to take advantage of sea trade.
+// should also take resource needs into account.
+DELPHI.HQ.prototype.findGenericCCLocation = function(gameState, template)
+{
+	Engine.ProfileStart('findGenericCCLocation');
+	let placement = new API3.Map(gameState.sharedScript, "territory");
+	const maxChoices = 10;// number of possible positions to choose from
+	const mapWidth = this.territoryMap.width;
+	const mapWidthHalf = Math.floor(mapWidth / 2);
+	const cellSize = this.territoryMap.cellSize;
+	const defaultTileVal = 64;
+	const maxTileVal = 255;
+	const shoreCoeff = 1.2;
+	placement.setMaxVal(maxTileVal);
+	for (let i in placement.map) {
+		placement.map[i] = defaultTileVal;
+	}// end for i in placement.map
+	const structRadius = (() => {
+		let cityRadius = Number(template.get('City/Radius'));
+		return cityRadius ? Math.floor(cityRadius / cellSize) : Math.floor(128 / cellSize);
+	})();
+	let obstructions = DELPHI.createObstructionMap(gameState, 0, template);
+	const radius = Math.ceil((template.obstructionRadius().max / obstructions.cellSize));
+	// favor resource supplies
+	for (let res of Resources.GetCodes()) {
+		let ents = gameState.getResourceSupplies(res).toEntityArray();
+		for (let ent of ents) {
+			let strength = Math.floor((defaultTileVal * 2) / ents.length);
+			let pos = ent.position();
+			let posX = Math.floor(pos[0] / cellSize);
+			let posZ = Math.floor(pos[1] / cellSize);
+			placement.addInfluence(posX, posZ, structRadius * 2, strength);
+		}// end for ent of ents
+	}// end for res of Resources.GetCodes()
+	// favor shorelines
+	for (let tile of this.shoreTiles) {
+		let pos = gameState.ai.accessibility.mapPosToGamePos(tile.index);
+		let tilePosX = Math.floor(pos[0] / cellSize);
+		let tilePosZ = Math.floor(pos[1] / cellSize);
+		placement.addInfluence(tilePosX, tilePosZ, structRadius, Math.ceil((tile.waterValue * shoreCoeff) / cellSize));
+		placement.addInfluence(tilePosX, tilePosZ, Math.floor(structRadius / 4), -Math.ceil(tile.waterValue / cellSize), 'constant');
+	}// end for tile of this.shoreTiles
+	let friendlyCivCentres = gameState.getOwnEntitiesByClass('CivCentre', true).toEntityArray().concat(gameState.getAllyStructures().filter(API3.Filters.byClass('CivCentre')).toEntityArray());
+	let friendlyCivCentrePositions = friendlyCivCentres.map((cc) => {
+		let ccPos = cc.position();
+		let ccPosX = Math.floor(ccPos[0] / cellSize);
+		let ccPosZ = Math.floor(ccPos[1] / cellSize);
+		return { 'x': ccPosX, 'z': ccPosZ };
+	});
+	for (let pos of friendlyCivCentrePositions) {
+		placement.addInfluence(pos.x, pos.z, mapWidthHalf * 2, defaultTileVal * 2);
+	}// end for pos of friendlyCivCentrePositions
+	for (let pos of friendlyCivCentrePositions) {
+		placement.addInfluence(pos.x, pos.z, mapWidthHalf, -defaultTileVal * 2);
+	}// end for pos of friendlyCivCentrePositions
+	let enemyCivCentres = gameState.getEnemyStructures().filter(API3.Filters.byClass('CivCentre')).toEntityArray();
+	for (let cc of enemyCivCentres) {
+		let ccPos = cc.position();
+		let ccPosX = Math.floor(ccPos[0] / cellSize);
+		let ccPosZ = Math.floor(ccPos[1] / cellSize);
+		placement.addInfluence(ccPosX, ccPosZ, mapWidthHalf, -defaultTileVal * 2);
+	}// end for cc of enemyCivCentres
+	// if first civ centre, prioritize locations near (but not on) perimeter of map
+	// also prioritize current unit positions
+	if (friendlyCivCentres.length < 1) {
+		placement.addInfluence(mapWidthHalf, mapWidthHalf, mapWidthHalf, -Math.floor(defaultTileVal / 4));
+		for (let i in placement.map) {
+			placement.map[i] = Math.ceil(placement.map[i] / 5);
+		}// end for i in placement.map
+		let currUnits = gameState.getOwnUnits().toEntityArray();
+		let avgPos = (() => {
+			let sumX = 0;
+			let sumZ = 0;
+			for (let unit of currUnits) {
+				let pos = unit.position();
+				sumX += pos[0];
+				sumZ += pos[1];
+			}// end for unit of currUnits
+			let avgX = Math.floor(sumX / (currUnits.length * cellSize));
+			let avgZ = Math.floor(sumZ / (currUnits.length * cellSize));
+			return [avgX, avgZ];
+		})();
+		placement.addInfluence(avgPos[0], avgPos[1], Math.floor(mapWidthHalf / 2), defaultTileVal * 2, 'constant');
+		const accessVal = gameState.ai.accessibility.getAccessValue([avgPos[0] * cellSize, avgPos[1] * cellSize]);
+		for (let i in placement.map) {
+			let tileAccessVal = gameState.ai.accessibility.getAccessValue([(i % mapWidth) * cellSize, Math.floor(i / mapWidth) * cellSize]);
+			if (tileAccessVal != accessVal)
+				placement.map[i] = 0;
+		}// end for i in placement.map
+	}// end if friendlyCivCentres.length < 1
+	let tileChoices = [];
+	for (let i = 0; i < maxChoices; i++) {
+		let tile = placement.findBestTile(radius, obstructions);
+		if (!tile.val)
+			break;
+		tileChoices.push(tile);
+		placement.map[tile.idx] = 0;
+	}// end for i = 0; i < maxChoices; i++
+	if (tileChoices.length < 1)
+		return false
+	let bestTile = tileChoices[randIntExclusive(0, tileChoices.length)];
+	Engine.ProfileStop();
+
+	// Define a minimal number of wanted ships in the seas reaching this new base
+	let indexIdx = gameState.ai.accessibility.landPassMap[bestTile.idx];
+	for (let base of this.baseManagers)
+	{
+		if (!base || !base.anchor || base.accessIndex == indexIdx)
+			continue;
+		let sea = this.getSeaBetweenIndices(gameState, base.accessIndex, indexIdx);
+		if (sea !== undefined)
+			this.navalManager.setMinimalTransportShips(gameState, sea, 1);
+	}
+
+	return gameState.ai.accessibility.mapPosToGamePos(bestTile.idx);
+};// end function DELPHI.HQ.prototype.findGenericCCLocation
+
 /**
  * Returns the best position to build a new Civil Center
  * Whose primary function would be to reach new resources of type "resource".
  */
-PETRA.HQ.prototype.findEconomicCCLocation = function(gameState, template, resource, proximity, fromStrategic)
+DELPHI.HQ.prototype.findEconomicCCLocation = function(gameState, template, resource, proximity, fromStrategic)
 {
 	// This builds a map. The procedure is fairly simple. It adds the resource maps
 	//	(which are dynamically updated and are made so that they will facilitate DP placement)
@@ -931,7 +1056,7 @@ PETRA.HQ.prototype.findEconomicCCLocation = function(gameState, template, resour
 	Engine.ProfileStart("findEconomicCCLocation");
 
 	// obstruction map
-	let obstructions = PETRA.createObstructionMap(gameState, 0, template);
+	let obstructions = DELPHI.createObstructionMap(gameState, 0, template);
 	let halfSize = 0;
 	if (template.get("Footprint/Square"))
 		halfSize = Math.max(+template.get("Footprint/Square/@depth"), +template.get("Footprint/Square/@width")) / 2;
@@ -1029,7 +1154,7 @@ PETRA.HQ.prototype.findEconomicCCLocation = function(gameState, template, resour
 
 				if (dist < minDist)
 					minDist = dist;
-				accessible = accessible || index == PETRA.getLandAccess(gameState, cc.ent);
+				accessible = accessible || index == DELPHI.getLandAccess(gameState, cc.ent);
 			}
 			if (norm == 0)
 				continue;
@@ -1051,7 +1176,7 @@ PETRA.HQ.prototype.findEconomicCCLocation = function(gameState, template, resour
 			}
 
 			// Not near any of our dropsite, except for oversea docks
-			oversea = !accessible && dpList.some(dp => PETRA.getLandAccess(gameState, dp.ent) == index);
+			oversea = !accessible && dpList.some(dp => DELPHI.getLandAccess(gameState, dp.ent) == index);
 			if (!oversea)
 			{
 				for (let dp of dpList)
@@ -1070,7 +1195,7 @@ PETRA.HQ.prototype.findEconomicCCLocation = function(gameState, template, resour
 				continue;
 		}
 
-		if (this.borderMap.map[j] & PETRA.fullBorder_Mask)	// disfavor the borders of the map
+		if (this.borderMap.map[j] & DELPHI.fullBorder_Mask)	// disfavor the borders of the map
 			norm *= 0.5;
 
 		let val = 2 * gameState.sharedScript.ccResourceMaps[resource].map[j];
@@ -1108,7 +1233,7 @@ PETRA.HQ.prototype.findEconomicCCLocation = function(gameState, template, resour
 	let indexIdx = gameState.ai.accessibility.landPassMap[bestIdx];
 	for (let base of this.baseManagers)
 	{
-		if (!base.anchor || base.accessIndex == indexIdx)
+		if (!base || !base.anchor || base.accessIndex == indexIdx)
 			continue;
 		let sea = this.getSeaBetweenIndices(gameState, base.accessIndex, indexIdx);
 		if (sea !== undefined)
@@ -1122,7 +1247,7 @@ PETRA.HQ.prototype.findEconomicCCLocation = function(gameState, template, resour
  * Returns the best position to build a new Civil Center
  * Whose primary function would be to assure territorial continuity with our allies
  */
-PETRA.HQ.prototype.findStrategicCCLocation = function(gameState, template)
+DELPHI.HQ.prototype.findStrategicCCLocation = function(gameState, template)
 {
 	// This builds a map. The procedure is fairly simple.
 	// We minimize the Sum((dist - 300)^2) where the sum is on the three nearest allied CC
@@ -1145,7 +1270,7 @@ PETRA.HQ.prototype.findStrategicCCLocation = function(gameState, template)
 	Engine.ProfileStart("findStrategicCCLocation");
 
 	// obstruction map
-	let obstructions = PETRA.createObstructionMap(gameState, 0, template);
+	let obstructions = DELPHI.createObstructionMap(gameState, 0, template);
 	let halfSize = 0;
 	if (template.get("Footprint/Square"))
 		halfSize = Math.max(+template.get("Footprint/Square/@depth"), +template.get("Footprint/Square/@width")) / 2;
@@ -1225,7 +1350,7 @@ PETRA.HQ.prototype.findStrategicCCLocation = function(gameState, template)
 			currentVal += delta*delta;
 		}
 		// disfavor border of the map
-		if (this.borderMap.map[j] & PETRA.fullBorder_Mask)
+		if (this.borderMap.map[j] & DELPHI.fullBorder_Mask)
 			currentVal += 10000;
 
 		if (bestVal !== undefined && currentVal > bestVal)
@@ -1251,7 +1376,7 @@ PETRA.HQ.prototype.findStrategicCCLocation = function(gameState, template)
 	let indexIdx = gameState.ai.accessibility.landPassMap[bestIdx];
 	for (let base of this.baseManagers)
 	{
-		if (!base.anchor || base.accessIndex == indexIdx)
+		if (!base || !base.anchor || base.accessIndex == indexIdx)
 			continue;
 		let sea = this.getSeaBetweenIndices(gameState, base.accessIndex, indexIdx);
 		if (sea !== undefined)
@@ -1262,133 +1387,285 @@ PETRA.HQ.prototype.findStrategicCCLocation = function(gameState, template)
 };
 
 /**
- * Returns the best position to build a new market: if the allies already have a market, build it as far as possible
- * from it, although not in our border to be able to defend it easily. If no allied market, our second market will
- * follow the same logic.
- * To do so, we suppose that the gain/distance is an increasing function of distance and look for the max distance
- * for performance reasons.
+ * Applies a template's BuildRestriction values to a territory placement map, specifically MinDistances and MaxDistances
+ * @param placement territory placement map, as returned by API3.Map()
+ * @param gameState object containing game state info
+ * @param template template of the structure to be built, as defined in simulation/templates
+ * @return None (modifies placement)
  */
-PETRA.HQ.prototype.findMarketLocation = function(gameState, template)
+DELPHI.HQ.prototype.applyBuildRestrictions = function(placement, gameState, template)
 {
-	let markets = gameState.updatingCollection("diplo-ExclusiveAllyMarkets", API3.Filters.byClass("Trade"), gameState.getExclusiveAllyEntities()).toEntityArray();
-	if (!markets.length)
-		markets = gameState.updatingCollection("OwnMarkets", API3.Filters.byClass("Trade"), gameState.getOwnStructures()).toEntityArray();
+	// distance from similar structures; try to spread out amongst civ centres
+	const cellSize = this.territoryMap.cellSize; // size of each tile
+	const avoidPenalty = -512;
+	// account for BuildRestrictions distances
+	let distancesExclusive = template.get('BuildRestrictions/DistancesExclusive');
+	if (distancesExclusive)
+	{
+		for (let d in distancesExclusive)
+		{
+			let dist = distancesExclusive[d];
+			if (!dist.MinDistance)
+				continue;
+			let minDist = Math.floor(Number(dist.MinDistance));
+			let distClass = dist.FromClass;
+			let classStructs = gameState.getOwnStructures().filter(API3.Filters.byClass(distClass)).toEntityArray();
+			for (let ent of classStructs)
+			{
+				let entPos = ent.position();
+				placement.addInfluence(Math.floor(entPos[0] / cellSize), Math.floor(entPos[1] / cellSize), Math.ceil(minDist / cellSize), avoidPenalty);
+			}// end for ent
+		}// end for dist
+	}
+};//end DELPHI.HQ.prototype.applyBuildRestrictions
 
-	if (!markets.length)	// this is the first market. For the time being, place it arbitrarily by the ConstructionPlan
-		return [-1, -1, -1, 0];
+/**
+ * find the nearest base to a given tile
+ * @param tileIndex (int) index of a tile in a territory map
+ * @param obstructions (obj) map of obstructions
+ * @return (int) id of nearest base; undefined if no nearest base found
+ */
+DELPHI.HQ.prototype.findNearestBase = function(tileIndex, obstructions)
+{
+	let tileX = (tileIndex % obstructions.width) * obstructions.cellSize;
+	let tileZ = (Math.floor(tileIndex / obstructions.width)) * obstructions.cellSize;
+	let minDist = -1;
+	let baseID = undefined;
+	let civCentrePos = [-1, -1];
+	for (let base of this.baseManagers)
+	{
+		if (!base || !base.anchor)
+			continue;
+		let basePos = base.anchor.position();
+		let dist = API3.SquareVectorDistance(basePos, [tileX, tileZ]);
+		minDist = minDist < 0 || dist < minDist ? dist : minDist;
+		if (dist === minDist)
+		{
+			baseID = base.ID;
+			civCentrePos = basePos;
+		}
+	}// end for base
+	return baseID;
+};// end DELPHI.HQ.prototype.findNearestBase
 
-	// No need for more than one market when we cannot trade.
-	if (!Resources.GetTradableCodes().length)
+/** Algorithm taken from the function GetDockAngle in simulation/helpers/Commands.js */
+DELPHI.HQ.prototype.getDockAngle = function(gameState, x, z, size)
+{
+	let pos = gameState.ai.accessibility.gamePosToMapPos([x, z]);
+	let k = pos[0] + pos[1]*gameState.ai.accessibility.width;
+	let seaRef = gameState.ai.accessibility.navalPassMap[k];
+	if (seaRef < 2)
 		return false;
-
-	// obstruction map
-	let obstructions = PETRA.createObstructionMap(gameState, 0, template);
-	let halfSize = 0;
-	if (template.get("Footprint/Square"))
-		halfSize = Math.max(+template.get("Footprint/Square/@depth"), +template.get("Footprint/Square/@width")) / 2;
-	else if (template.get("Footprint/Circle"))
-		halfSize = +template.get("Footprint/Circle/@radius");
-
-	let bestIdx;
-	let bestJdx;
-	let bestVal;
-	let bestDistSq;
-	let bestGainMult;
-	let radius = Math.ceil(template.obstructionRadius().max / obstructions.cellSize);
-	const isNavalMarket = template.hasClasses(["Naval+Trade"]);
-
-	let width = this.territoryMap.width;
-	let cellSize = this.territoryMap.cellSize;
-
-	let traderTemplatesGains = gameState.getTraderTemplatesGains();
-
-	for (let j = 0; j < this.territoryMap.length; ++j)
+	const numPoints = 16;
+	for (let dist = 0; dist < 4; ++dist)
 	{
-		// do not try on the narrow border of our territory
-		if (this.borderMap.map[j] & PETRA.narrowFrontier_Mask)
-			continue;
-		if (this.basesMap.map[j] == 0)   // only in our territory
-			continue;
-		// with enough room around to build the market
-		let i = this.territoryMap.getNonObstructedTile(j, radius, obstructions);
-		if (i < 0)
-			continue;
-		let index = gameState.ai.accessibility.landPassMap[i];
-		if (!this.landRegions[index])
+		let waterPoints = [];
+		for (let i = 0; i < numPoints; ++i)
+		{
+			let angle = 2 * Math.PI * i / numPoints;
+			pos = [x - (1+dist)*size*Math.sin(angle), z + (1+dist)*size*Math.cos(angle)];
+			pos = gameState.ai.accessibility.gamePosToMapPos(pos);
+			if (pos[0] < 0 || pos[0] >= gameState.ai.accessibility.width ||
+			    pos[1] < 0 || pos[1] >= gameState.ai.accessibility.height)
+				continue;
+			let j = pos[0] + pos[1]*gameState.ai.accessibility.width;
+			if (gameState.ai.accessibility.navalPassMap[j] == seaRef)
+				waterPoints.push(i);
+		}
+		let length = waterPoints.length;
+		if (!length)
 			continue;
-		let pos = [cellSize * (j%width+0.5), cellSize * (Math.floor(j/width)+0.5)];
-		// checking distances to other markets
-		let maxVal = 0;
-		let maxDistSq;
-		let maxGainMult;
-		let gainMultiplier;
-		for (let market of markets)
-		{
-			if (isNavalMarket && template.hasClasses(["Naval+Trade"]))
+		let consec = [];
+		for (let i = 0; i < length; ++i)
+		{
+			let count = 0;
+			for (let j = 0; j < length-1; ++j)
 			{
-				if (PETRA.getSeaAccess(gameState, market) != gameState.ai.accessibility.getAccessValue(pos, true))
-					continue;
-				gainMultiplier = traderTemplatesGains.navalGainMultiplier;
+				if ((waterPoints[(i + j) % length]+1) % numPoints == waterPoints[(i + j + 1) % length])
+					++count;
+				else
+					break;
 			}
-			else if (PETRA.getLandAccess(gameState, market) == index &&
-				!PETRA.isLineInsideEnemyTerritory(gameState, market.position(), pos))
-				gainMultiplier = traderTemplatesGains.landGainMultiplier;
-			else
-				continue;
-			if (!gainMultiplier)
-				continue;
-			let distSq = API3.SquareVectorDistance(market.position(), pos);
-			if (gainMultiplier * distSq > maxVal)
+			consec[i] = count;
+		}
+		let start = 0;
+		let count = 0;
+		for (let c in consec)
+		{
+			if (consec[c] > count)
 			{
-				maxVal = gainMultiplier * distSq;
-				maxDistSq = distSq;
-				maxGainMult = gainMultiplier;
+				start = c;
+				count = consec[c];
 			}
 		}
-		if (maxVal == 0)
-			continue;
-		if (bestVal !== undefined && maxVal < bestVal)
-			continue;
-		if (this.isDangerousLocation(gameState, pos, halfSize))
-			continue;
-		bestVal = maxVal;
-		bestDistSq = maxDistSq;
-		bestGainMult = maxGainMult;
-		bestIdx = i;
-		bestJdx = j;
+
+		// If we've found a shoreline, stop searching
+		if (count != numPoints-1)
+			return -((waterPoints[start] + consec[start]/2) % numPoints)/numPoints*2*Math.PI;
 	}
+	return false;
+};
 
-	if (this.Config.debug > 1)
-		API3.warn("We found a market position with bestVal = " + bestVal);
+/**
+ * Algorithm taken from checkPlacement in simulation/components/BuildRestriction.js
+ * to determine the special dock requirements
+ * returns {"land": land index for this dock, "water": amount of water around this spot}
+ */
+DELPHI.HQ.prototype.checkDockPlacement = function(gameState, x, z, halfDepth, halfWidth, angle)
+{
+	let sz = halfDepth * Math.sin(angle);
+	let cz = halfDepth * Math.cos(angle);
+	// center back position
+	let pos = gameState.ai.accessibility.gamePosToMapPos([x - sz, z - cz]);
+	let j = pos[0] + pos[1]*gameState.ai.accessibility.width;
+	let land = gameState.ai.accessibility.landPassMap[j];
+	if (land < 2)
+		return null;
+	// center front position
+	pos = gameState.ai.accessibility.gamePosToMapPos([x + sz, z + cz]);
+	j = pos[0] + pos[1]*gameState.ai.accessibility.width;
+	if (gameState.ai.accessibility.landPassMap[j] > 1 || gameState.ai.accessibility.navalPassMap[j] < 2)
+		return null;
+	// additional constraints compared to BuildRestriction.js to assure we have enough place to build
+	let sw = halfWidth * Math.cos(angle) * 3 / 4;
+	let cw = halfWidth * Math.sin(angle) * 3 / 4;
+	pos = gameState.ai.accessibility.gamePosToMapPos([x - sz + sw, z - cz - cw]);
+	j = pos[0] + pos[1]*gameState.ai.accessibility.width;
+	if (gameState.ai.accessibility.landPassMap[j] != land)
+		return null;
+	pos = gameState.ai.accessibility.gamePosToMapPos([x - sz - sw, z - cz + cw]);
+	j = pos[0] + pos[1]*gameState.ai.accessibility.width;
+	if (gameState.ai.accessibility.landPassMap[j] != land)
+		return null;
+	let water = 0;
+	let sp = 15 * Math.sin(angle);
+	let cp = 15 * Math.cos(angle);
+	for (let i = 1; i < 5; ++i)
+	{
+		pos = gameState.ai.accessibility.gamePosToMapPos([x + sz + i*(sp+sw), z + cz + i*(cp-cw)]);
+		if (pos[0] < 0 || pos[0] >= gameState.ai.accessibility.width ||
+		    pos[1] < 0 || pos[1] >= gameState.ai.accessibility.height)
+			break;
+		j = pos[0] + pos[1]*gameState.ai.accessibility.width;
+		if (gameState.ai.accessibility.landPassMap[j] > 1 || gameState.ai.accessibility.navalPassMap[j] < 2)
+			break;
+		pos = gameState.ai.accessibility.gamePosToMapPos([x + sz + i*sp, z + cz + i*cp]);
+		if (pos[0] < 0 || pos[0] >= gameState.ai.accessibility.width ||
+		    pos[1] < 0 || pos[1] >= gameState.ai.accessibility.height)
+			break;
+		j = pos[0] + pos[1]*gameState.ai.accessibility.width;
+		if (gameState.ai.accessibility.landPassMap[j] > 1 || gameState.ai.accessibility.navalPassMap[j] < 2)
+			break;
+		pos = gameState.ai.accessibility.gamePosToMapPos([x + sz + i*(sp-sw), z + cz + i*(cp+cw)]);
+		if (pos[0] < 0 || pos[0] >= gameState.ai.accessibility.width ||
+		    pos[1] < 0 || pos[1] >= gameState.ai.accessibility.height)
+			break;
+		j = pos[0] + pos[1]*gameState.ai.accessibility.width;
+		if (gameState.ai.accessibility.landPassMap[j] > 1 || gameState.ai.accessibility.navalPassMap[j] < 2)
+			break;
+		water += 4;
+	}
+	return { "land": land, "water": water };
+};
 
-	if (bestVal === undefined)  // no constraints. For the time being, place it arbitrarily by the ConstructionPlan
-		return [-1, -1, -1, 0];
-	let expectedGain = Math.round(bestGainMult * TradeGain(bestDistSq, gameState.sharedScript.mapSize));
-	if (this.Config.debug > 1)
-		API3.warn("this would give a trading gain of " + expectedGain);
-	// Do not keep it if gain is too small, except if this is our first Market.
-	let idx;
-	if (expectedGain < this.tradeManager.minimalGain)
-	{
-		if (template.hasClass("Market") &&
-		    !gameState.getOwnEntitiesByClass("Market", true).hasEntities())
-			idx = -1; // Needed by queueplanBuilding manager to keep that Market.
-		else
-			return false;
+DELPHI.HQ.prototype.findCivicLocation = function(gameState, template)
+{
+	let placement = new API3.Map(gameState.sharedScript, "territory");
+	const isDock = template.buildPlacementType() == 'shore';
+	const civCentreRadiusRatio = 1.0;
+	const obstructionRatio = isDock ? 0.6 : 1.2;
+	const maxRetries = 100;// for finding dock position
+	const maxValidPositions = 5;
+	const cellSize = this.territoryMap.cellSize; // size of each tile
+	let halfSize = 0;    // used for dock angle
+	let halfDepth = 0;   // used by checkPlacement
+	let halfWidth = 0;   // used by checkPlacement
+	if (template.get("Footprint/Square"))
+	{
+		halfSize = Math.max(+template.get("Footprint/Square/@depth"), +template.get("Footprint/Square/@width")) / 2;
+		halfDepth = +template.get("Footprint/Square/@depth") / 2;
+		halfWidth = +template.get("Footprint/Square/@width") / 2;
 	}
-	else
-		idx = this.basesMap.map[bestJdx];
+	else if (template.get("Footprint/Circle"))
+	{
+		halfSize = +template.get("Footprint/Circle/@radius");
+		halfDepth = halfSize;
+		halfWidth = halfSize;
+	}
+	let civCentres = gameState.getOwnEntitiesByClass('CivCentre', true).toEntityArray();
+	if (civCentres.length < 1)
+		return false;
+	for (let civCentre of civCentres)
+	{
+		let civCentrePos = civCentre.position();
+		let civCentrePosX = Math.floor(civCentrePos[0] / cellSize);
+		let civCentrePosZ = Math.floor(civCentrePos[1] / cellSize);
+		let civCentreRadius = Math.floor(Number(civCentre.get('City/Radius')));
+		if (!civCentreRadius)
+			civCentreRadius = 60;
+			placement.addInfluence(civCentrePosX, civCentrePosZ, Math.floor((civCentreRadius * civCentreRadiusRatio) / cellSize), 255);
+	}// end for civCentre
+	// distance from similar structures; try to spread out amongst civ centres
+	this.applyBuildRestrictions(placement, gameState, template);
+	let obstructions = DELPHI.createObstructionMap(gameState, 0, template);
+	const radius = Math.ceil((template.obstructionRadius().max * obstructionRatio / obstructions.cellSize));
+	// loop until find valid position (useful for docks)
+	// choose randomly from a number of valid positions
+// 	if (isDock) {
+// 		for (let tile of this.shoreTiles) {
+// 			if (placement.map[tile.index] > 0) {
+// 				placement.set(tile.index, placement.map[tile.index] + tile.waterValue);
+// 			}// end if placement.map[tile.index] > 0
+// 		}// end for tile of this.shoreTiles
+// 	}// end if isDock
+	let validPositions = [];
+	for (let i = 0; i < maxRetries; i++)
+	{
+		let structTile = placement.findBestTile(radius, obstructions);
+		// found no best tile
+		if (!structTile.val)
+			break;
+		let structIndex = structTile.idx;
+		let structPosX = (structIndex % obstructions.width) * obstructions.cellSize;
+		let structPosZ = (Math.floor(structIndex / obstructions.width)) * obstructions.cellSize;
+		// find nearest base
+		let baseID = this.findNearestBase(structIndex, obstructions);
+		let position = {'x': structPosX, 'z': structPosZ, 'angle': 3*Math.PI/4, 'base': baseID};
+		if (isDock) {
+			let angle = this.getDockAngle(gameState, structPosX, structPosZ, halfSize);
+			if (angle == false) {
+				obstructions.set(structIndex, 0);
+				continue;
+			}
+			let ret = this.checkDockPlacement(gameState, structPosX, structPosZ, halfDepth, halfWidth, angle);
+			if (!ret || !this.landRegions[ret.land]) {
+				obstructions.set(structIndex, 0);
+				continue;
+			}
+			position['angle'] = angle;
+			position['access'] = ret.land;
+		}// end if iDock
+		obstructions.set(structIndex, 0);
+		validPositions.push(position);
+		if (validPositions.length >= maxValidPositions)
+			break;
+	}// end for maxRetries
+	if (validPositions.length > 0)
+		return validPositions[randIntExclusive(0, validPositions.length)];
+	return false;
+};// end findCivicLocation
 
-	let x = (bestIdx % obstructions.width + 0.5) * obstructions.cellSize;
-	let z = (Math.floor(bestIdx / obstructions.width) + 0.5) * obstructions.cellSize;
-	return [x, z, idx, expectedGain];
+DELPHI.HQ.prototype.findMarketLocation = function(gameState, template)
+{
+	let pos = this.findCivicLocation(gameState, template);
+	return [pos.x, pos.z, pos.base, 9999];
 };
 
 /**
  * Returns the best position to build defensive buildings (fortress and towers)
  * Whose primary function is to defend our borders
  */
-PETRA.HQ.prototype.findDefensiveLocation = function(gameState, template)
+DELPHI.HQ.prototype.findDefensiveLocation = function(gameState, template)
 {
 	// We take the point in our territory which is the nearest to any enemy cc
 	// but requiring a minimal distance with our other defensive structures
@@ -1421,7 +1698,7 @@ PETRA.HQ.prototype.findDefensiveLocation = function(gameState, template)
 	}
 
 	// obstruction map
-	let obstructions = PETRA.createObstructionMap(gameState, 0, template);
+	let obstructions = DELPHI.createObstructionMap(gameState, 0, template);
 	let halfSize = 0;
 	if (template.get("Footprint/Square"))
 		halfSize = Math.max(+template.get("Footprint/Square/@depth"), +template.get("Footprint/Square/@width")) / 2;
@@ -1447,9 +1724,9 @@ PETRA.HQ.prototype.findDefensiveLocation = function(gameState, template)
 		if (!wonderMode)
 		{
 			// do not try if well inside or outside territory
-			if (!(this.borderMap.map[j] & PETRA.fullFrontier_Mask))
+			if (!(this.borderMap.map[j] & DELPHI.fullFrontier_Mask))
 				continue;
-			if (this.borderMap.map[j] & PETRA.largeFrontier_Mask && isTower)
+			if (this.borderMap.map[j] & DELPHI.largeFrontier_Mask && isTower)
 				continue;
 		}
 		if (this.basesMap.map[j] == 0)   // inaccessible cell
@@ -1522,11 +1799,13 @@ PETRA.HQ.prototype.findDefensiveLocation = function(gameState, template)
 	return [x, z, this.basesMap.map[bestJdx]];
 };
 
-PETRA.HQ.prototype.buildTemple = function(gameState, queues)
+DELPHI.HQ.prototype.buildTemple = function(gameState, queues)
 {
+	let numCivCentres = gameState.getOwnStructures().filter(API3.Filters.byClass('CivCentre')).filter(API3.Filters.isBuilt()).length;
 	// at least one market (which have the same queue) should be build before any temple
+	// number of temples should ideally equal number of CivCentres
 	if (queues.economicBuilding.hasQueuedUnits() ||
-		gameState.getOwnEntitiesByClass("Temple", true).hasEntities() ||
+		gameState.getOwnEntitiesByClass("Temple", true).length >= numCivCentres ||
 		!gameState.getOwnEntitiesByClass("Market", true).hasEntities())
 		return;
 	// Try to build a temple earlier if in regicide to recruit healer guards
@@ -1538,46 +1817,98 @@ PETRA.HQ.prototype.buildTemple = function(gameState, queues)
 		templateName = "structures/{civ}/temple_vesta";
 	else if (!this.canBuild(gameState, templateName))
 		return;
-	queues.economicBuilding.addPlan(new PETRA.ConstructionPlan(gameState, templateName));
+	queues.economicBuilding.addPlan(new DELPHI.ConstructionPlan(gameState, templateName));
 };
 
-PETRA.HQ.prototype.buildMarket = function(gameState, queues)
+DELPHI.HQ.prototype.buildTemplePatron = function(gameState, queues)
 {
-	if (gameState.getOwnEntitiesByClass("Market", true).hasEntities() ||
-		!this.canBuild(gameState, "structures/{civ}/market"))
+	// at least one market (which have the same queue) should be build before any temple
+	if (queues.economicBuilding.hasQueuedUnits() ||
+		gameState.getOwnEntitiesByClass("TemplePatron", true).hasEntities() ||
+		!gameState.getOwnEntitiesByClass("Market", true).hasEntities())
 		return;
+	let templeNames = ["fertility", "war", "trade", "sea", "horse"];
+	let chosenTemple = templeNames[randIntExclusive(0, templeNames.length)];
+	let templateName = "structures/{civ}/temple_patron_" + chosenTemple;
+	if (!this.canBuild(gameState, templateName))
+		return;
+	queues.economicBuilding.addPlan(new DELPHI.ConstructionPlan(gameState, templateName));
+};
 
-	if (queues.economicBuilding.hasQueuedUnitsWithClass("Market"))
-	{
-		if (!queues.economicBuilding.paused)
-		{
-			// Put available resources in this market
-			let queueManager = gameState.ai.queueManager;
-			let cost = queues.economicBuilding.plans[0].getCost();
-			queueManager.setAccounts(gameState, cost, "economicBuilding");
-			if (!queueManager.canAfford("economicBuilding", cost))
-			{
-				for (let q in queueManager.queues)
-				{
-					if (q == "economicBuilding")
-						continue;
-					queueManager.transferAccounts(cost, q, "economicBuilding");
-					if (queueManager.canAfford("economicBuilding", cost))
-						break;
-				}
-			}
-		}
+DELPHI.HQ.prototype.buildMarket = function(gameState, queues)
+{
+	let numCivCentres = gameState.getOwnStructures().filter(API3.Filters.byClass('CivCentre')).filter(API3.Filters.isBuilt()).length;
+	if (gameState.getOwnEntitiesByClass("Market", true).length >= numCivCentres)
+		return;
+
+	if (queues.economicBuilding.hasQueuedUnitsWithClass('Market'))
 		return;
-	}
 
+// 	if (queues.economicBuilding.hasQueuedUnitsWithClass("BarterMarket"))
+// 	{
+// 		if (!queues.economicBuilding.paused)
+// 		{
+// 			// Put available resources in this market
+// 			let queueManager = gameState.ai.queueManager;
+// 			let cost = queues.economicBuilding.plans[0].getCost();
+// 			queueManager.setAccounts(gameState, cost, "economicBuilding");
+// 			if (!queueManager.canAfford("economicBuilding", cost))
+// 			{
+// 				for (let q in queueManager.queues)
+// 				{
+// 					if (q == "economicBuilding")
+// 						continue;
+// 					queueManager.transferAccounts(cost, q, "economicBuilding");
+// 					if (queueManager.canAfford("economicBuilding", cost))
+// 						break;
+// 				}
+// 			}
+// 		}
+// 		return;
+// 	}
 	gameState.ai.queueManager.changePriority("economicBuilding", 3 * this.Config.priorities.economicBuilding);
-	let plan = new PETRA.ConstructionPlan(gameState, "structures/{civ}/market");
+	// prioritize ports, build land market otherwise
+	let position = undefined;
+	let metadata = undefined;
+	let portTemplateFormat = 'structures/{civ}/port';
+	let marketTemplateFormat = 'structures/{civ}/market';
+	let chosenTemplate = undefined;
+	if (this.canBuild(gameState, portTemplateFormat))
+	{
+		let portTemplate = gameState.getTemplate(gameState.applyCiv(portTemplateFormat));
+		let portPos = this.findCivicLocation(gameState, portTemplate);
+		if (portPos)
+		{
+			chosenTemplate = portTemplateFormat;
+		}
+	}
+	if (!chosenTemplate && this.canBuild(gameState, marketTemplateFormat))
+		chosenTemplate = marketTemplateFormat;
+	if (!chosenTemplate)
+		return;
+	let plan = new DELPHI.ConstructionPlan(gameState, chosenTemplate);
 	plan.queueToReset = "economicBuilding";
 	queues.economicBuilding.addPlan(plan);
-};
+};// end buildMarket
+
+DELPHI.HQ.prototype.buildTavern = function(gameState, queues)
+{
+	let numMarkets = gameState.getOwnStructures().filter(API3.Filters.byClass('Market')).filter(API3.Filters.isBuilt()).length;
+	// at least one market (which have the same queue) should be build before any tavern
+	// number of taverns should ideally equal number of markets
+	if (queues.economicBuilding.hasQueuedUnits() ||
+		gameState.getOwnEntitiesByClass("Tavern", true).length >= numMarkets ||
+		!gameState.getOwnEntitiesByClass("Market", true).hasEntities())
+		return;
+
+	let templateName = "structures/{civ}/tavern";
+	if (!this.canBuild(gameState, templateName))
+		return;
+	queues.economicBuilding.addPlan(new DELPHI.ConstructionPlan(gameState, templateName));
+};// end buildTavern
 
 /** Build a farmstead */
-PETRA.HQ.prototype.buildFarmstead = function(gameState, queues)
+DELPHI.HQ.prototype.buildFarmstead = function(gameState, queues)
 {
 	// Only build one farmstead for the time being ("DropsiteFood" does not refer to CCs)
 	if (gameState.getOwnEntitiesByClass("Farmstead", true).hasEntities())
@@ -1592,18 +1923,29 @@ PETRA.HQ.prototype.buildFarmstead = function(gameState, queues)
 	if (!this.canBuild(gameState, "structures/{civ}/farmstead"))
 		return;
 
-	queues.economicBuilding.addPlan(new PETRA.ConstructionPlan(gameState, "structures/{civ}/farmstead"));
+	queues.economicBuilding.addPlan(new DELPHI.ConstructionPlan(gameState, "structures/{civ}/farmstead"));
+};
+
+DELPHI.HQ.prototype.buildPalace = function(gameState, queues)
+{
+	if (queues.economicBuilding.hasQueuedUnits() ||
+		gameState.getOwnEntitiesByClass("Palace", true).hasEntities())
+		return;
+	let templateName = "structures/{civ}/palace";
+	if (!this.canBuild(gameState, templateName))
+		return;
+	queues.economicBuilding.addPlan(new DELPHI.ConstructionPlan(gameState, templateName));
 };
 
 /**
  * Try to build a wonder when required
  * force = true when called from the victoryManager in case of Wonder victory condition.
  */
-PETRA.HQ.prototype.buildWonder = function(gameState, queues, force = false)
+DELPHI.HQ.prototype.buildWonder = function(gameState, queues, force = false)
 {
 	if (queues.wonder && queues.wonder.hasQueuedUnits() ||
-	    gameState.getOwnEntitiesByClass("Wonder", true).hasEntities() ||
-	    !this.canBuild(gameState, "structures/{civ}/wonder"))
+		gameState.getOwnEntitiesByClass("Wonder", true).hasEntities() ||
+		!this.canBuild(gameState, "structures/{civ}/wonder"))
 		return;
 
 	if (!force)
@@ -1625,11 +1967,11 @@ PETRA.HQ.prototype.buildWonder = function(gameState, queues, force = false)
 			return;
 	}
 
-	queues.wonder.addPlan(new PETRA.ConstructionPlan(gameState, "structures/{civ}/wonder"));
+	queues.wonder.addPlan(new DELPHI.ConstructionPlan(gameState, "structures/{civ}/wonder"));
 };
 
 /** Build a corral, and train animals there */
-PETRA.HQ.prototype.manageCorral = function(gameState, queues)
+DELPHI.HQ.prototype.manageCorral = function(gameState, queues)
 {
 	if (queues.corral.hasQueuedUnits())
 		return;
@@ -1640,7 +1982,7 @@ PETRA.HQ.prototype.manageCorral = function(gameState, queues)
 	{
 		if (this.canBuild(gameState, "structures/{civ}/corral"))
 		{
-			queues.corral.addPlan(new PETRA.ConstructionPlan(gameState, "structures/{civ}/corral"));
+			queues.corral.addPlan(new DELPHI.ConstructionPlan(gameState, "structures/{civ}/corral"));
 			return;
 		}
 		if (!nCorral)
@@ -1666,7 +2008,7 @@ PETRA.HQ.prototype.manageCorral = function(gameState, queues)
 				count += item.count;
 			if (count > nCorral)
 				continue;
-			queues.corral.addPlan(new PETRA.TrainingPlan(gameState, trainable, { "trainer": corral.id() }));
+			queues.corral.addPlan(new DELPHI.TrainingPlan(gameState, trainable, { "trainer": corral.id() }));
 			return;
 		}
 	}
@@ -1676,7 +2018,7 @@ PETRA.HQ.prototype.manageCorral = function(gameState, queues)
  * build more houses if needed.
  * kinda ugly, lots of special cases to both build enough houses but not tooo many
  */
-PETRA.HQ.prototype.buildMoreHouses = function(gameState, queues)
+DELPHI.HQ.prototype.buildMoreHouses = function(gameState, queues)
 {
 	let houseTemplateString = "structures/{civ}/apartment";
 	if (!gameState.isTemplateAvailable(gameState.applyCiv(houseTemplateString)) ||
@@ -1692,7 +2034,7 @@ PETRA.HQ.prototype.buildMoreHouses = function(gameState, queues)
 	let numPlanned = queues.house.length();
 	if (numPlanned < 3 || numPlanned < 5 && gameState.getPopulation() > 80)
 	{
-		let plan = new PETRA.ConstructionPlan(gameState, houseTemplateString);
+		let plan = new DELPHI.ConstructionPlan(gameState, houseTemplateString);
 		// change the starting condition according to the situation.
 		plan.goRequirement = "houseNeeded";
 		queues.house.addPlan(plan);
@@ -1766,7 +2108,7 @@ PETRA.HQ.prototype.buildMoreHouses = function(gameState, queues)
 };
 
 /** Checks the status of the territory expansion. If no new economic bases created, build some strategic ones. */
-PETRA.HQ.prototype.checkBaseExpansion = function(gameState, queues)
+DELPHI.HQ.prototype.checkBaseExpansion = function(gameState, queues)
 {
 	if (queues.civilCentre.hasQueuedUnits())
 		return;
@@ -1799,7 +2141,7 @@ PETRA.HQ.prototype.checkBaseExpansion = function(gameState, queues)
 	}
 };
 
-PETRA.HQ.prototype.buildNewBase = function(gameState, queues, resource)
+DELPHI.HQ.prototype.buildNewBase = function(gameState, queues, resource)
 {
 	if (this.numPotentialBases() > 0 && this.currentPhase == 1 && !gameState.isResearching(gameState.getPhaseName(2)))
 		return false;
@@ -1828,12 +2170,12 @@ PETRA.HQ.prototype.buildNewBase = function(gameState, queues, resource)
 	// base "-1" means new base.
 	if (this.Config.debug > 1)
 		API3.warn("new base " + gameState.applyCiv(template) + " planned with resource " + resource);
-	queues.civilCentre.addPlan(new PETRA.ConstructionPlan(gameState, template, { "base": -1, "resource": resource }));
+	queues.civilCentre.addPlan(new DELPHI.ConstructionPlan(gameState, template, { "base": -1, "resource": resource }));
 	return true;
 };
 
 /** Deals with building fortresses and towers along our border with enemies. */
-PETRA.HQ.prototype.buildDefenses = function(gameState, queues)
+DELPHI.HQ.prototype.buildDefenses = function(gameState, queues)
 {
 	if (this.saveResources && !this.canBarter || queues.defenseBuilding.hasQueuedUnits())
 		return;
@@ -1852,7 +2194,7 @@ PETRA.HQ.prototype.buildDefenses = function(gameState, queues)
 				this.fortressStartTime = gameState.ai.elapsedTime;
 				if (!numFortresses)
 					gameState.ai.queueManager.changePriority("defenseBuilding", 2 * this.Config.priorities.defenseBuilding);
-				let plan = new PETRA.ConstructionPlan(gameState, "structures/{civ}/fortress");
+				let plan = new DELPHI.ConstructionPlan(gameState, "structures/{civ}/fortress");
 				plan.queueToReset = "defenseBuilding";
 				queues.defenseBuilding.addPlan(plan);
 				return;
@@ -1868,7 +2210,7 @@ PETRA.HQ.prototype.buildDefenses = function(gameState, queues)
 		if (numTowers < this.Config.Military.numSentryTowers && gameState.ai.elapsedTime > towerLapseTime + this.fortStartTime)
 		{
 			this.fortStartTime = gameState.ai.elapsedTime;
-			queues.defenseBuilding.addPlan(new PETRA.ConstructionPlan(gameState, "structures/{civ}/sentry_tower"));
+			queues.defenseBuilding.addPlan(new DELPHI.ConstructionPlan(gameState, "structures/{civ}/sentry_tower"));
 		}
 		return;
 	}
@@ -1886,13 +2228,13 @@ PETRA.HQ.prototype.buildDefenses = function(gameState, queues)
 		this.towerStartTime = gameState.ai.elapsedTime;
 		if (numTowers > 2 * this.numActiveBases() + 3)
 			gameState.ai.queueManager.changePriority("defenseBuilding", Math.round(0.7 * this.Config.priorities.defenseBuilding));
-		let plan = new PETRA.ConstructionPlan(gameState, "structures/{civ}/defense_tower");
+		let plan = new DELPHI.ConstructionPlan(gameState, "structures/{civ}/defense_tower");
 		plan.queueToReset = "defenseBuilding";
 		queues.defenseBuilding.addPlan(plan);
 	}
 };
 
-PETRA.HQ.prototype.buildForge = function(gameState, queues)
+DELPHI.HQ.prototype.buildForge = function(gameState, queues)
 {
 	if (this.getAccountedPopulation(gameState) < this.Config.Military.popForForge ||
 		queues.militaryBuilding.hasQueuedUnits() || gameState.getOwnEntitiesByClass("Forge", true).length)
@@ -1902,14 +2244,14 @@ PETRA.HQ.prototype.buildForge = function(gameState, queues)
 		return;
 
 	if (this.canBuild(gameState, "structures/{civ}/forge"))
-		queues.militaryBuilding.addPlan(new PETRA.ConstructionPlan(gameState, "structures/{civ}/forge"));
+		queues.militaryBuilding.addPlan(new DELPHI.ConstructionPlan(gameState, "structures/{civ}/forge"));
 };
 
 /**
  * Deals with constructing military buildings (e.g. barracks, stable).
  * They are mostly defined by Config.js. This is unreliable since changes could be done easily.
  */
-PETRA.HQ.prototype.constructTrainingBuildings = function(gameState, queues)
+DELPHI.HQ.prototype.constructTrainingBuildings = function(gameState, queues)
 {
 	if (this.saveResources && !this.canBarter || queues.militaryBuilding.hasQueuedUnits())
 		return;
@@ -1936,7 +2278,7 @@ PETRA.HQ.prototype.constructTrainingBuildings = function(gameState, queues)
 			if (template)
 			{
 				gameState.ai.queueManager.changePriority("militaryBuilding", 2 * this.Config.priorities.militaryBuilding);
-				let plan = new PETRA.ConstructionPlan(gameState, template, { "militaryBase": true });
+				let plan = new DELPHI.ConstructionPlan(gameState, template, { "militaryBase": true });
 				plan.queueToReset = "militaryBuilding";
 				queues.militaryBuilding.addPlan(plan);
 				return;
@@ -1944,7 +2286,7 @@ PETRA.HQ.prototype.constructTrainingBuildings = function(gameState, queues)
 		}
 		if (numStables == 0 && stableTemplate)
 		{
-			queues.militaryBuilding.addPlan(new PETRA.ConstructionPlan(gameState, stableTemplate, { "militaryBase": true }));
+			queues.militaryBuilding.addPlan(new DELPHI.ConstructionPlan(gameState, stableTemplate, { "militaryBase": true }));
 			return;
 		}
 
@@ -1954,23 +2296,23 @@ PETRA.HQ.prototype.constructTrainingBuildings = function(gameState, queues)
 			let template = numBarracks == 0 ? (barracksTemplate || rangeTemplate) : (rangeTemplate || barracksTemplate);
 			if (template)
 			{
-				queues.militaryBuilding.addPlan(new PETRA.ConstructionPlan(gameState, template, { "militaryBase": true }));
+				queues.militaryBuilding.addPlan(new DELPHI.ConstructionPlan(gameState, template, { "militaryBase": true }));
 				return;
 			}
 		}
 		if (numStables == 1 && stableTemplate && this.getAccountedPopulation(gameState) > this.Config.Military.popForBarracks2)
 		{
-			queues.militaryBuilding.addPlan(new PETRA.ConstructionPlan(gameState, stableTemplate, { "militaryBase": true }));
+			queues.militaryBuilding.addPlan(new DELPHI.ConstructionPlan(gameState, stableTemplate, { "militaryBase": true }));
 			return;
 		}
 
-		// Third barracks/range and stable, if needed.
+		// Third barracks/range and stable if needed.
 		if (numBarracks + numRanges + numStables == 2 && this.getAccountedPopulation(gameState) > this.Config.Military.popForBarracks2 + 30)
 		{
 			let template = barracksTemplate || stableTemplate || rangeTemplate;
 			if (template)
 			{
-				queues.militaryBuilding.addPlan(new PETRA.ConstructionPlan(gameState, template, { "militaryBase": true }));
+				queues.militaryBuilding.addPlan(new DELPHI.ConstructionPlan(gameState, template, { "militaryBase": true }));
 				return;
 			}
 		}
@@ -1984,13 +2326,13 @@ PETRA.HQ.prototype.constructTrainingBuildings = function(gameState, queues)
 
 	if (this.canBuild(gameState, "structures/{civ}/elephant_stable") && !gameState.getOwnEntitiesByClass("ElephantStable", true).hasEntities())
 	{
-		queues.militaryBuilding.addPlan(new PETRA.ConstructionPlan(gameState, "structures/{civ}/elephant_stable", { "militaryBase": true }));
+		queues.militaryBuilding.addPlan(new DELPHI.ConstructionPlan(gameState, "structures/{civ}/elephant_stable", { "militaryBase": true }));
 		return;
 	}
 
 	if (this.canBuild(gameState, "structures/{civ}/arsenal") && !gameState.getOwnEntitiesByClass("Arsenal", true).hasEntities())
 	{
-		queues.militaryBuilding.addPlan(new PETRA.ConstructionPlan(gameState, "structures/{civ}/arsenal", { "militaryBase": true }));
+		queues.militaryBuilding.addPlan(new DELPHI.ConstructionPlan(gameState, "structures/{civ}/arsenal", { "militaryBase": true }));
 		return;
 	}
 
@@ -2013,9 +2355,9 @@ PETRA.HQ.prototype.constructTrainingBuildings = function(gameState, queues)
 				continue;
 			let civ = gameState.getPlayerCiv();
 			if (template.hasDefensiveFire() || template.trainableEntities(civ))
-				queues.militaryBuilding.addPlan(new PETRA.ConstructionPlan(gameState, advanced, { "militaryBase": true }));
+				queues.militaryBuilding.addPlan(new DELPHI.ConstructionPlan(gameState, advanced, { "militaryBase": true }));
 			else	// not a military building, but still use this queue
-				queues.militaryBuilding.addPlan(new PETRA.ConstructionPlan(gameState, advanced));
+				queues.militaryBuilding.addPlan(new DELPHI.ConstructionPlan(gameState, advanced));
 			return;
 		}
 	}
@@ -2024,7 +2366,7 @@ PETRA.HQ.prototype.constructTrainingBuildings = function(gameState, queues)
 /**
  *  Find base nearest to ennemies for military buildings.
  */
-PETRA.HQ.prototype.findBestBaseForMilitary = function(gameState)
+DELPHI.HQ.prototype.findBestBaseForMilitary = function(gameState)
 {
 	let ccEnts = gameState.updatingGlobalCollection("allCCs", API3.Filters.byClass("CivCentre")).toEntityArray();
 	let bestBase;
@@ -2036,13 +2378,13 @@ PETRA.HQ.prototype.findBestBaseForMilitary = function(gameState)
 			continue;
 		if (enemyFound && !gameState.isPlayerEnemy(cce.owner()))
 			continue;
-		let access = PETRA.getLandAccess(gameState, cce);
+		let access = DELPHI.getLandAccess(gameState, cce);
 		let isEnemy = gameState.isPlayerEnemy(cce.owner());
 		for (let cc of ccEnts)
 		{
 			if (cc.owner() != PlayerID)
 				continue;
-			if (PETRA.getLandAccess(gameState, cc) != access)
+			if (DELPHI.getLandAccess(gameState, cc) != access)
 				continue;
 			let dist = API3.SquareVectorDistance(cc.position(), cce.position());
 			if (!enemyFound && isEnemy)
@@ -2060,7 +2402,7 @@ PETRA.HQ.prototype.findBestBaseForMilitary = function(gameState)
  * train with highest priority ranged infantry in the nearest civil center from a given set of positions
  * and garrison them there for defense
  */
-PETRA.HQ.prototype.trainEmergencyUnits = function(gameState, positions)
+DELPHI.HQ.prototype.trainEmergencyUnits = function(gameState, positions)
 {
 	if (gameState.ai.queues.emergency.hasQueuedUnits())
 		return false;
@@ -2076,9 +2418,9 @@ PETRA.HQ.prototype.trainEmergencyUnits = function(gameState, positions)
 		// check nearest base anchor
 		for (let base of this.baseManagers)
 		{
-			if (!base.anchor || !base.anchor.position())
+			if (!base || !base.anchor || !base.anchor.position())
 				continue;
-			if (PETRA.getLandAccess(gameState, base.anchor) != access)
+			if (DELPHI.getLandAccess(gameState, base.anchor) != access)
 				continue;
 			if (!base.anchor.trainableEntities(civ))	// base still in construction
 				continue;
@@ -2161,11 +2503,11 @@ PETRA.HQ.prototype.trainEmergencyUnits = function(gameState, positions)
 	let metadata = { "role": "worker", "base": nearestAnchor.getMetadata(PlayerID, "base"), "plan": -1, "trainer": nearestAnchor.id() };
 	if (autogarrison)
 		metadata.garrisonType = "protection";
-	gameState.ai.queues.emergency.addPlan(new PETRA.TrainingPlan(gameState, templateFound[0], metadata, 1, 1));
+	gameState.ai.queues.emergency.addPlan(new DELPHI.TrainingPlan(gameState, templateFound[0], metadata, 1, 1));
 	return true;
 };
 
-PETRA.HQ.prototype.canBuild = function(gameState, structure)
+DELPHI.HQ.prototype.canBuild = function(gameState, structure)
 {
 	let type = gameState.applyCiv(structure);
 	if (this.buildManager.isUnbuildable(gameState, type))
@@ -2219,7 +2561,7 @@ PETRA.HQ.prototype.canBuild = function(gameState, structure)
 	return true;
 };
 
-PETRA.HQ.prototype.updateTerritories = function(gameState)
+DELPHI.HQ.prototype.updateTerritories = function(gameState)
 {
 	const around = [ [-0.7, 0.7], [0, 1], [0.7, 0.7], [1, 0], [0.7, -0.7], [0, -1], [-0.7, -0.7], [-1, 0] ];
 	let alliedVictory = gameState.getAlliedVictory();
@@ -2232,10 +2574,10 @@ PETRA.HQ.prototype.updateTerritories = function(gameState)
 
 	for (let j = 0; j < this.territoryMap.length; ++j)
 	{
-		if (this.borderMap.map[j] & PETRA.outside_Mask)
+		if (this.borderMap.map[j] & DELPHI.outside_Mask)
 			continue;
-		if (this.borderMap.map[j] & PETRA.fullFrontier_Mask)
-			this.borderMap.map[j] &= ~PETRA.fullFrontier_Mask;	// reset the frontier
+		if (this.borderMap.map[j] & DELPHI.fullFrontier_Mask)
+			this.borderMap.map[j] &= ~DELPHI.fullFrontier_Mask;	// reset the frontier
 
 		if (this.territoryMap.getOwnerIndex(j) != PlayerID)
 		{
@@ -2269,12 +2611,12 @@ PETRA.HQ.prototype.updateTerritories = function(gameState)
 				let jz = iz + Math.round(insideSmall*a[1]);
 				if (jz < 0 || jz >= width)
 					continue;
-				if (this.borderMap.map[jx+width*jz] & PETRA.outside_Mask)
+				if (this.borderMap.map[jx+width*jz] & DELPHI.outside_Mask)
 					continue;
 				let territoryOwner = this.territoryMap.getOwnerIndex(jx+width*jz);
 				if (territoryOwner != PlayerID && !(alliedVictory && gameState.isPlayerAlly(territoryOwner)))
 				{
-					this.borderMap.map[j] |= PETRA.narrowFrontier_Mask;
+					this.borderMap.map[j] |= DELPHI.narrowFrontier_Mask;
 					break;
 				}
 				jx = ix + Math.round(insideLarge*a[0]);
@@ -2283,14 +2625,14 @@ PETRA.HQ.prototype.updateTerritories = function(gameState)
 				jz = iz + Math.round(insideLarge*a[1]);
 				if (jz < 0 || jz >= width)
 					continue;
-				if (this.borderMap.map[jx+width*jz] & PETRA.outside_Mask)
+				if (this.borderMap.map[jx+width*jz] & DELPHI.outside_Mask)
 					continue;
 				territoryOwner = this.territoryMap.getOwnerIndex(jx+width*jz);
 				if (territoryOwner != PlayerID && !(alliedVictory && gameState.isPlayerAlly(territoryOwner)))
 					onFrontier = true;
 			}
-			if (onFrontier && !(this.borderMap.map[j] & PETRA.narrowFrontier_Mask))
-				this.borderMap.map[j] |= PETRA.largeFrontier_Mask;
+			if (onFrontier && !(this.borderMap.map[j] & DELPHI.narrowFrontier_Mask))
+				this.borderMap.map[j] |= DELPHI.largeFrontier_Mask;
 
 			// If this tile was not already accounted, add it.
 			if (this.basesMap.map[j] != 0)
@@ -2313,7 +2655,7 @@ PETRA.HQ.prototype.updateTerritories = function(gameState)
 			let pos = [cellSize * (j%width+0.5), cellSize * (Math.floor(j/width)+0.5)];
 			for (let base of this.baseManagers)
 			{
-				if (!base.anchor || !base.anchor.position())
+				if (!base || !base.anchor || !base.anchor.position())
 					continue;
 				if (base.accessIndex != access)
 					continue;
@@ -2342,7 +2684,7 @@ PETRA.HQ.prototype.updateTerritories = function(gameState)
 };
 
 /** Reassign territories when a base is going to be deleted */
-PETRA.HQ.prototype.reassignTerritories = function(deletedBase)
+DELPHI.HQ.prototype.reassignTerritories = function(deletedBase)
 {
 	let cellSize = this.territoryMap.cellSize;
 	let width = this.territoryMap.width;
@@ -2352,7 +2694,7 @@ PETRA.HQ.prototype.reassignTerritories = function(deletedBase)
 			continue;
 		if (this.territoryMap.getOwnerIndex(j) != PlayerID)
 		{
-			API3.warn("Petra reassignTerritories: should never happen");
+			API3.warn("Delphi reassignTerritories: should never happen");
 			this.basesMap.map[j] = 0;
 			continue;
 		}
@@ -2362,7 +2704,7 @@ PETRA.HQ.prototype.reassignTerritories = function(deletedBase)
 		let pos = [cellSize * (j%width+0.5), cellSize * (Math.floor(j/width)+0.5)];
 		for (let base of this.baseManagers)
 		{
-			if (!base.anchor || !base.anchor.position())
+			if (!base || !base.anchor || !base.anchor.position())
 				continue;
 			if (base.accessIndex != deletedBase.accessIndex)
 				continue;
@@ -2385,10 +2727,10 @@ PETRA.HQ.prototype.reassignTerritories = function(deletedBase)
 /**
  * returns the base corresponding to baseID
  */
-PETRA.HQ.prototype.getBaseByID = function(baseID)
+DELPHI.HQ.prototype.getBaseByID = function(baseID)
 {
 	for (let base of this.baseManagers)
-		if (base.ID == baseID)
+		if (base && base.ID == baseID)
 			return base;
 
 	return undefined;
@@ -2399,26 +2741,26 @@ PETRA.HQ.prototype.getBaseByID = function(baseID)
  * ActiveBases includes only those with a built cc
  * PotentialBases includes also those with a cc in construction
  */
-PETRA.HQ.prototype.numActiveBases = function()
+DELPHI.HQ.prototype.numActiveBases = function()
 {
 	if (!this.turnCache.base)
 		this.updateBaseCache();
 	return this.turnCache.base.active;
 };
 
-PETRA.HQ.prototype.numPotentialBases = function()
+DELPHI.HQ.prototype.numPotentialBases = function()
 {
 	if (!this.turnCache.base)
 		this.updateBaseCache();
 	return this.turnCache.base.potential;
 };
 
-PETRA.HQ.prototype.updateBaseCache = function()
+DELPHI.HQ.prototype.updateBaseCache = function()
 {
 	this.turnCache.base = { "active": 0, "potential": 0 };
 	for (let base of this.baseManagers)
 	{
-		if (!base.anchor)
+		if (!base || !base.anchor)
 			continue;
 		++this.turnCache.base.potential;
 		if (base.anchor.foundationProgress() === undefined)
@@ -2426,7 +2768,7 @@ PETRA.HQ.prototype.updateBaseCache = function()
 	}
 };
 
-PETRA.HQ.prototype.resetBaseCache = function()
+DELPHI.HQ.prototype.resetBaseCache = function()
 {
 	this.turnCache.base = undefined;
 };
@@ -2435,7 +2777,7 @@ PETRA.HQ.prototype.resetBaseCache = function()
  * Count gatherers returning resources in the number of gatherers of resourceSupplies
  * to prevent the AI always reassigning idle workers to these resourceSupplies (specially in naval maps).
  */
-PETRA.HQ.prototype.assignGatherers = function()
+DELPHI.HQ.prototype.assignGatherers = function()
 {
 	for (let base of this.baseManagers)
 	{
@@ -2451,13 +2793,13 @@ PETRA.HQ.prototype.assignGatherers = function()
 	}
 };
 
-PETRA.HQ.prototype.isDangerousLocation = function(gameState, pos, radius)
+DELPHI.HQ.prototype.isDangerousLocation = function(gameState, pos, radius)
 {
 	return this.isNearInvadingArmy(pos) || this.isUnderEnemyFire(gameState, pos, radius);
 };
 
 /** Check that the chosen position is not too near from an invading army */
-PETRA.HQ.prototype.isNearInvadingArmy = function(pos)
+DELPHI.HQ.prototype.isNearInvadingArmy = function(pos)
 {
 	for (let army of this.defenseManager.armies)
 		if (army.foePosition && API3.SquareVectorDistance(army.foePosition, pos) < 12000)
@@ -2465,21 +2807,24 @@ PETRA.HQ.prototype.isNearInvadingArmy = function(pos)
 	return false;
 };
 
-PETRA.HQ.prototype.isUnderEnemyFire = function(gameState, pos, radius = 0)
+DELPHI.HQ.prototype.isUnderEnemyFire = function(gameState, pos, radius = 0)
 {
 	if (!this.turnCache.firingStructures)
 		this.turnCache.firingStructures = gameState.updatingCollection("diplo-FiringStructures", API3.Filters.hasDefensiveFire(), gameState.getEnemyStructures());
 	for (let ent of this.turnCache.firingStructures.values())
 	{
 		let range = radius + ent.attackRange("Ranged").max;
-		if (API3.SquareVectorDistance(ent.position(), pos) < range*range)
+		let entPos = ent.position();
+		if (!entPos || !pos)
+			continue;
+		if (API3.SquareVectorDistance(entPos, pos) < range*range)
 			return true;
 	}
 	return false;
 };
 
 /** Compute the capture strength of all units attacking a capturable target */
-PETRA.HQ.prototype.updateCaptureStrength = function(gameState)
+DELPHI.HQ.prototype.updateCaptureStrength = function(gameState)
 {
 	this.capturableTargets.clear();
 	for (let ent of gameState.getOwnUnits().values())
@@ -2498,13 +2843,13 @@ PETRA.HQ.prototype.updateCaptureStrength = function(gameState)
 			continue;
 		if (!this.capturableTargets.has(targetId))
 			this.capturableTargets.set(targetId, {
-				"strength": ent.captureStrength() * PETRA.getAttackBonus(ent, target, "Capture"),
+				"strength": ent.captureStrength() * DELPHI.getAttackBonus(ent, target, "Capture"),
 				"ents": new Set([ent.id()])
 			});
 		else
 		{
 			let capturableTarget = this.capturableTargets.get(target.id());
-			capturableTarget.strength += ent.captureStrength() * PETRA.getAttackBonus(ent, target, "Capture");
+			capturableTarget.strength += ent.captureStrength() * DELPHI.getAttackBonus(ent, target, "Capture");
 			capturableTarget.ents.add(ent.id());
 		}
 	}
@@ -2517,7 +2862,7 @@ PETRA.HQ.prototype.updateCaptureStrength = function(gameState)
 		{
 			let ent = gameState.getEntityById(entId);
 			if (allowCapture === undefined)
-				allowCapture = PETRA.allowCapture(gameState, ent, target);
+				allowCapture = DELPHI.allowCapture(gameState, ent, target);
 			let orderData = ent.unitAIOrderData();
 			if (!orderData || !orderData.length || !orderData[0].attackType)
 				continue;
@@ -2532,7 +2877,7 @@ PETRA.HQ.prototype.updateCaptureStrength = function(gameState)
 /** Some functions that register that we assigned a gatherer to a resource this turn */
 
 /** add a gatherer to the turn cache for this supply. */
-PETRA.HQ.prototype.AddTCGatherer = function(supplyID)
+DELPHI.HQ.prototype.AddTCGatherer = function(supplyID)
 {
 	if (this.turnCache.resourceGatherer && this.turnCache.resourceGatherer[supplyID] !== undefined)
 		++this.turnCache.resourceGatherer[supplyID];
@@ -2545,7 +2890,7 @@ PETRA.HQ.prototype.AddTCGatherer = function(supplyID)
 };
 
 /** remove a gatherer to the turn cache for this supply. */
-PETRA.HQ.prototype.RemoveTCGatherer = function(supplyID)
+DELPHI.HQ.prototype.RemoveTCGatherer = function(supplyID)
 {
 	if (this.turnCache.resourceGatherer && this.turnCache.resourceGatherer[supplyID])
 		--this.turnCache.resourceGatherer[supplyID];
@@ -2557,7 +2902,7 @@ PETRA.HQ.prototype.RemoveTCGatherer = function(supplyID)
 	}
 };
 
-PETRA.HQ.prototype.GetTCGatherer = function(supplyID)
+DELPHI.HQ.prototype.GetTCGatherer = function(supplyID)
 {
 	if (this.turnCache.resourceGatherer && this.turnCache.resourceGatherer[supplyID])
 		return this.turnCache.resourceGatherer[supplyID];
@@ -2566,7 +2911,7 @@ PETRA.HQ.prototype.GetTCGatherer = function(supplyID)
 };
 
 /** The next two are to register that we assigned a gatherer to a resource this turn. */
-PETRA.HQ.prototype.AddTCResGatherer = function(resource)
+DELPHI.HQ.prototype.AddTCResGatherer = function(resource)
 {
 	if (this.turnCache["resourceGatherer-" + resource])
 		++this.turnCache["resourceGatherer-" + resource];
@@ -2577,7 +2922,7 @@ PETRA.HQ.prototype.AddTCResGatherer = function(resource)
 		this.turnCache.currentRates[resource] += 0.5;
 };
 
-PETRA.HQ.prototype.GetTCResGatherer = function(resource)
+DELPHI.HQ.prototype.GetTCResGatherer = function(resource)
 {
 	if (this.turnCache["resourceGatherer-" + resource])
 		return this.turnCache["resourceGatherer-" + resource];
@@ -2588,7 +2933,7 @@ PETRA.HQ.prototype.GetTCResGatherer = function(resource)
 /**
  * flag a resource as exhausted
  */
-PETRA.HQ.prototype.isResourceExhausted = function(resource)
+DELPHI.HQ.prototype.isResourceExhausted = function(resource)
 {
 	if (this.turnCache["exhausted-" + resource] == undefined)
 		this.turnCache["exhausted-" + resource] = this.baseManagers.every(base =>
@@ -2602,7 +2947,7 @@ PETRA.HQ.prototype.isResourceExhausted = function(resource)
 /**
  * Check if a structure in blinking territory should/can be defended (currently if it has some attacking armies around)
  */
-PETRA.HQ.prototype.isDefendable = function(ent)
+DELPHI.HQ.prototype.isDefendable = function(ent)
 {
 	if (!this.turnCache.numAround)
 		this.turnCache.numAround = {};
@@ -2614,7 +2959,7 @@ PETRA.HQ.prototype.isDefendable = function(ent)
 /**
  * Get the number of population already accounted for
  */
-PETRA.HQ.prototype.getAccountedPopulation = function(gameState)
+DELPHI.HQ.prototype.getAccountedPopulation = function(gameState)
 {
 	if (this.turnCache.accountedPopulation == undefined)
 	{
@@ -2638,7 +2983,7 @@ PETRA.HQ.prototype.getAccountedPopulation = function(gameState)
 /**
  * Get the number of workers already accounted for
  */
-PETRA.HQ.prototype.getAccountedWorkers = function(gameState)
+DELPHI.HQ.prototype.getAccountedWorkers = function(gameState)
 {
 	if (this.turnCache.accountedWorkers == undefined)
 	{
@@ -2661,11 +3006,12 @@ PETRA.HQ.prototype.getAccountedWorkers = function(gameState)
  * Some functions are run every turn
  * Others once in a while
  */
-PETRA.HQ.prototype.update = function(gameState, queues, events)
+DELPHI.HQ.prototype.update = function(gameState, queues, events)
 {
 	Engine.ProfileStart("Headquarters update");
 	this.turnCache = {};
-	this.territoryMap = PETRA.createTerritoryMap(gameState);
+	this.territoryMap = DELPHI.createTerritoryMap(gameState);
+	let numCivCentres = gameState.getOwnStructures().filter(API3.Filters.byClass('CivCentre')).filter(API3.Filters.isBuilt()).length;
 	this.canBarter = gameState.getOwnEntitiesByClass("Market", true).filter(API3.Filters.isBuilt()).hasEntities();
 	// TODO find a better way to update
 	if (this.currentPhase != gameState.currentPhase())
@@ -2688,7 +3034,7 @@ PETRA.HQ.prototype.update = function(gameState, queues, events)
 		gameState.getOwnUnits().forEach (function (ent) {
 			if (!ent.position())
 				return;
-			PETRA.dumpEntity(ent);
+			DELPHI.dumpEntity(ent);
 		});
 	}
 	*/
@@ -2728,10 +3074,15 @@ PETRA.HQ.prototype.update = function(gameState, queues, events)
 		if (!this.canBarter)
 			this.buildMarket(gameState, queues);
 
+		if (gameState.getOwnEntitiesByClass('Market', true).toEntityArray().length < numCivCentres)
+			this.buildMarket(gameState, queues);
+
 		if (!this.saveResources)
 		{
 			this.buildForge(gameState, queues);
 			this.buildTemple(gameState, queues);
+			this.buildTemplePatron(gameState, queues);
+			this.buildPalace(gameState, queues);
 		}
 
 		if (gameState.ai.playedTurn % 30 == 0 &&
@@ -2779,7 +3130,7 @@ PETRA.HQ.prototype.update = function(gameState, queues, events)
 	Engine.ProfileStop();
 };
 
-PETRA.HQ.prototype.Serialize = function()
+DELPHI.HQ.prototype.Serialize = function()
 {
 	let properties = {
 		"phasing": this.phasing,
@@ -2810,7 +3161,8 @@ PETRA.HQ.prototype.Serialize = function()
 
 	let baseManagers = [];
 	for (let base of this.baseManagers)
-		baseManagers.push(base.Serialize());
+		if (base)
+			baseManagers.push(base.Serialize());
 
 	if (this.Config.debug == -100)
 	{
@@ -2844,7 +3196,7 @@ PETRA.HQ.prototype.Serialize = function()
 	};
 };
 
-PETRA.HQ.prototype.Deserialize = function(gameState, data)
+DELPHI.HQ.prototype.Deserialize = function(gameState, data)
 {
 	for (let key in data.properties)
 		this[key] = data.properties[key];
@@ -2852,42 +3204,44 @@ PETRA.HQ.prototype.Deserialize = function(gameState, data)
 	this.baseManagers = [];
 	for (let base of data.baseManagers)
 	{
+		if (!base)
+			continue;
 		// the first call to deserialize set the ID base needed by entitycollections
-		let newbase = new PETRA.BaseManager(gameState, this.Config);
+		let newbase = new DELPHI.BaseManager(gameState, this.Config);
 		newbase.Deserialize(gameState, base);
 		newbase.init(gameState);
 		newbase.Deserialize(gameState, base);
 		this.baseManagers.push(newbase);
 	}
 
-	this.navalManager = new PETRA.NavalManager(this.Config);
+	this.navalManager = new DELPHI.NavalManager(this.Config);
 	this.navalManager.init(gameState, true);
 	this.navalManager.Deserialize(gameState, data.navalManager);
 
-	this.attackManager = new PETRA.AttackManager(this.Config);
+	this.attackManager = new DELPHI.AttackManager(this.Config);
 	this.attackManager.Deserialize(gameState, data.attackManager);
 	this.attackManager.init(gameState);
 	this.attackManager.Deserialize(gameState, data.attackManager);
 
-	this.buildManager = new PETRA.BuildManager();
+	this.buildManager = new DELPHI.BuildManager();
 	this.buildManager.Deserialize(data.buildManager);
 
-	this.defenseManager = new PETRA.DefenseManager(this.Config);
+	this.defenseManager = new DELPHI.DefenseManager(this.Config);
 	this.defenseManager.Deserialize(gameState, data.defenseManager);
 
-	this.tradeManager = new PETRA.TradeManager(this.Config);
+	this.tradeManager = new DELPHI.TradeManager(this.Config);
 	this.tradeManager.init(gameState);
 	this.tradeManager.Deserialize(gameState, data.tradeManager);
 
-	this.researchManager = new PETRA.ResearchManager(this.Config);
+	this.researchManager = new DELPHI.ResearchManager(this.Config);
 	this.researchManager.Deserialize(data.researchManager);
 
-	this.diplomacyManager = new PETRA.DiplomacyManager(this.Config);
+	this.diplomacyManager = new DELPHI.DiplomacyManager(this.Config);
 	this.diplomacyManager.Deserialize(data.diplomacyManager);
 
-	this.garrisonManager = new PETRA.GarrisonManager(this.Config);
+	this.garrisonManager = new DELPHI.GarrisonManager(this.Config);
 	this.garrisonManager.Deserialize(data.garrisonManager);
 
-	this.victoryManager = new PETRA.VictoryManager(this.Config);
+	this.victoryManager = new DELPHI.VictoryManager(this.Config);
 	this.victoryManager.Deserialize(data.victoryManager);
 };
diff --git a/binaries/data/mods/public/simulation/ai/delphi/mapModule.js b/binaries/data/mods/public/simulation/ai/delphi/mapModule.js
index d729faab9b..aa07cb5f39 100644
--- a/binaries/data/mods/public/simulation/ai/delphi/mapModule.js
+++ b/binaries/data/mods/public/simulation/ai/delphi/mapModule.js
@@ -1,9 +1,9 @@
 /** map functions */
 
-PETRA.TERRITORY_PLAYER_MASK = 0x1F;
-PETRA.TERRITORY_BLINKING_MASK = 0x40;
+DELPHI.TERRITORY_PLAYER_MASK = 0x1F;
+DELPHI.TERRITORY_BLINKING_MASK = 0x40;
 
-PETRA.createObstructionMap = function(gameState, accessIndex, template)
+DELPHI.createObstructionMap = function(gameState, accessIndex, template)
 {
 	let passabilityMap = gameState.getPassabilityMap();
 	let territoryMap = gameState.ai.territoryMap;
@@ -41,8 +41,8 @@ PETRA.createObstructionMap = function(gameState, accessIndex, template)
 
 	for (let k = 0; k < territoryMap.data.length; ++k)
 	{
-		let tilePlayer = territoryMap.data[k] & PETRA.TERRITORY_PLAYER_MASK;
-		let isConnected = (territoryMap.data[k] & PETRA.TERRITORY_BLINKING_MASK) == 0;
+		let tilePlayer = territoryMap.data[k] & DELPHI.TERRITORY_PLAYER_MASK;
+		let isConnected = (territoryMap.data[k] & DELPHI.TERRITORY_BLINKING_MASK) == 0;
 		if (tilePlayer === PlayerID)
 		{
 			if (!buildOwn || !buildNeutral && !isConnected)
@@ -79,20 +79,24 @@ PETRA.createObstructionMap = function(gameState, accessIndex, template)
 		}
 	}
 
+	// contrain using BuildRestrictions/Distances*
 	let map = new API3.Map(gameState.sharedScript, "passability", obstructionTiles);
 	map.setMaxVal(255);
+	const penalty = -255;
 
-	if (template && template.buildDistance())
+	if (template && template.get('BuildRestrictions/DistancesExclusive'))
 	{
-		let distance = template.buildDistance();
-		let minDist = distance.MinDistance ? +distance.MinDistance : 0;
-		if (minDist)
-		{
-			let obstructionRadius = template.obstructionRadius();
+		const obstructionRadius = template.obstructionRadius();
+		const cellSize = passabilityMap.cellSize;
+		let distances = template.get('BuildRestrictions/DistancesExclusive');
+		for (let d in distances) {
+			let dist = distances[d];
+			let minDist = dist.MinDistance;
+			if (!minDist)
+				continue;
+			let fromClass = dist.FromClass;
 			if (obstructionRadius)
 				minDist -= obstructionRadius.min;
-			let fromClass = distance.FromClass;
-			let cellSize = passabilityMap.cellSize;
 			let cellDist = 1 + minDist / cellSize;
 			let structures = gameState.getOwnStructures().filter(API3.Filters.byClass(fromClass));
 			for (let ent of structures.values())
@@ -102,23 +106,23 @@ PETRA.createObstructionMap = function(gameState, accessIndex, template)
 				let pos = ent.position();
 				let x = Math.round(pos[0] / cellSize);
 				let z = Math.round(pos[1] / cellSize);
-				map.addInfluence(x, z, cellDist, -255, "constant");
-			}
-		}
+				map.addInfluence(x, z, cellDist, penalty, "constant");
+			}// end for ent of structures.values()
+		}// end for d in distances
 	}
 
 	return map;
 };
 
 
-PETRA.createTerritoryMap = function(gameState)
+DELPHI.createTerritoryMap = function(gameState)
 {
 	let map = gameState.ai.territoryMap;
 
 	let ret = new API3.Map(gameState.sharedScript, "territory", map.data);
-	ret.getOwner = function(p) { return this.point(p) & PETRA.TERRITORY_PLAYER_MASK; };
-	ret.getOwnerIndex = function(p) { return this.map[p] & PETRA.TERRITORY_PLAYER_MASK; };
-	ret.isBlinking = function(p) { return (this.point(p) & PETRA.TERRITORY_BLINKING_MASK) != 0; };
+	ret.getOwner = function(p) { return this.point(p) & DELPHI.TERRITORY_PLAYER_MASK; };
+	ret.getOwnerIndex = function(p) { return this.map[p] & DELPHI.TERRITORY_PLAYER_MASK; };
+	ret.isBlinking = function(p) { return (this.point(p) & DELPHI.TERRITORY_BLINKING_MASK) != 0; };
 	return ret;
 };
 
@@ -132,14 +136,14 @@ PETRA.createTerritoryMap = function(gameState)
  *     - large border (inside our territory, exclusive of narrow)   => bit 3
  */
 
-PETRA.outside_Mask = 1;
-PETRA.border_Mask = 2;
-PETRA.fullBorder_Mask = PETRA.outside_Mask | PETRA.border_Mask;
-PETRA.narrowFrontier_Mask = 4;
-PETRA.largeFrontier_Mask = 8;
-PETRA.fullFrontier_Mask = PETRA.narrowFrontier_Mask | PETRA.largeFrontier_Mask;
+DELPHI.outside_Mask = 1;
+DELPHI.border_Mask = 2;
+DELPHI.fullBorder_Mask = DELPHI.outside_Mask | DELPHI.border_Mask;
+DELPHI.narrowFrontier_Mask = 4;
+DELPHI.largeFrontier_Mask = 8;
+DELPHI.fullFrontier_Mask = DELPHI.narrowFrontier_Mask | DELPHI.largeFrontier_Mask;
 
-PETRA.createBorderMap = function(gameState)
+DELPHI.createBorderMap = function(gameState)
 {
 	let map = new API3.Map(gameState.sharedScript, "territory");
 	let width = map.width;
@@ -157,13 +161,13 @@ PETRA.createBorderMap = function(gameState)
 			let radius = dx*dx + dy*dy;
 			if (radius < radcut)
 				continue;
-			map.map[j] = PETRA.outside_Mask;
+			map.map[j] = DELPHI.outside_Mask;
 			let ind = API3.getMapIndices(j, map, passabilityMap);
 			for (let k of ind)
 			{
 				if (passabilityMap.data[k] & obstructionMask)
 					continue;
-				map.map[j] = PETRA.border_Mask;
+				map.map[j] = DELPHI.border_Mask;
 				break;
 			}
 		}
@@ -177,13 +181,13 @@ PETRA.createBorderMap = function(gameState)
 			let iy = Math.floor(j/width);
 			if (ix < border || ix >= borderCut || iy < border || iy >= borderCut)
 			{
-				map.map[j] = PETRA.outside_Mask;
+				map.map[j] = DELPHI.outside_Mask;
 				let ind = API3.getMapIndices(j, map, passabilityMap);
 				for (let k of ind)
 				{
 					if (passabilityMap.data[k] & obstructionMask)
 						continue;
-					map.map[j] = PETRA.border_Mask;
+					map.map[j] = DELPHI.border_Mask;
 					break;
 				}
 			}
@@ -194,7 +198,7 @@ PETRA.createBorderMap = function(gameState)
 	return map;
 };
 
-PETRA.debugMap = function(gameState, map)
+DELPHI.debugMap = function(gameState, map)
 {
 	let width = map.width;
 	let cell = map.cellSize;
diff --git a/binaries/data/mods/public/simulation/ai/delphi/navalManager.js b/binaries/data/mods/public/simulation/ai/delphi/navalManager.js
index 2c97b0719e..8cf78c1580 100644
--- a/binaries/data/mods/public/simulation/ai/delphi/navalManager.js
+++ b/binaries/data/mods/public/simulation/ai/delphi/navalManager.js
@@ -7,7 +7,7 @@
  * -Scouting, ultimately.
  * Also deals with handling docks, making sure we have access and stuffs like that.
  */
-PETRA.NavalManager = function(Config)
+DELPHI.NavalManager = function(Config)
 {
 	this.Config = Config;
 
@@ -32,7 +32,7 @@ PETRA.NavalManager = function(Config)
 };
 
 /** More initialisation for stuff that needs the gameState */
-PETRA.NavalManager.prototype.init = function(gameState, deserializing)
+DELPHI.NavalManager.prototype.init = function(gameState, deserializing)
 {
 	// docks
 	this.docks = gameState.getOwnStructures().filter(API3.Filters.byClasses(["Dock", "Shipyard"]));
@@ -152,18 +152,18 @@ PETRA.NavalManager.prototype.init = function(gameState, deserializing)
 
 	// Assign our initial docks and ships
 	for (let ship of this.ships.values())
-		PETRA.setSeaAccess(gameState, ship);
+		DELPHI.setSeaAccess(gameState, ship);
 	for (let dock of this.docks.values())
-		PETRA.setSeaAccess(gameState, dock);
+		DELPHI.setSeaAccess(gameState, dock);
 };
 
-PETRA.NavalManager.prototype.updateFishingBoats = function(sea, num)
+DELPHI.NavalManager.prototype.updateFishingBoats = function(sea, num)
 {
 	if (this.wantedFishShips[sea])
 		this.wantedFishShips[sea] = num;
 };
 
-PETRA.NavalManager.prototype.resetFishingBoats = function(gameState, sea)
+DELPHI.NavalManager.prototype.resetFishingBoats = function(gameState, sea)
 {
 	if (sea !== undefined)
 		this.wantedFishShips[sea] = 0;
@@ -172,7 +172,7 @@ PETRA.NavalManager.prototype.resetFishingBoats = function(gameState, sea)
 };
 
 /** Get the sea, cache it if not yet done and check if in opensea */
-PETRA.NavalManager.prototype.getFishSea = function(gameState, fish)
+DELPHI.NavalManager.prototype.getFishSea = function(gameState, fish)
 {
 	let sea = fish.getMetadata(PlayerID, "sea");
 	if (sea)
@@ -209,7 +209,7 @@ PETRA.NavalManager.prototype.getFishSea = function(gameState, fish)
 };
 
 /** check if we can safely fish at the fish position */
-PETRA.NavalManager.prototype.canFishSafely = function(gameState, fish)
+DELPHI.NavalManager.prototype.canFishSafely = function(gameState, fish)
 {
 	if (fish.getMetadata(PlayerID, "opensea"))
 		return true;
@@ -235,28 +235,28 @@ PETRA.NavalManager.prototype.canFishSafely = function(gameState, fish)
 };
 
 /** get the list of seas (or lands) around this region not connected by a dock */
-PETRA.NavalManager.prototype.getUnconnectedSeas = function(gameState, region)
+DELPHI.NavalManager.prototype.getUnconnectedSeas = function(gameState, region)
 {
 	let seas = gameState.ai.accessibility.regionLinks[region].slice();
 	this.docks.forEach(dock => {
-		if (!dock.hasClass("Dock") || PETRA.getLandAccess(gameState, dock) != region)
+		if (!dock.hasClass("Dock") || DELPHI.getLandAccess(gameState, dock) != region)
 			return;
-		let i = seas.indexOf(PETRA.getSeaAccess(gameState, dock));
+		let i = seas.indexOf(DELPHI.getSeaAccess(gameState, dock));
 		if (i != -1)
 			seas.splice(i--, 1);
 	});
 	return seas;
 };
 
-PETRA.NavalManager.prototype.checkEvents = function(gameState, queues, events)
+DELPHI.NavalManager.prototype.checkEvents = function(gameState, queues, events)
 {
 	for (let evt of events.Create)
 	{
 		if (!evt.entity)
 			continue;
 		let ent = gameState.getEntityById(evt.entity);
-		if (ent && ent.isOwn(PlayerID) && ent.foundationProgress() !== undefined && ent.hasClasses(["Dock", "Shipyard"]))
-			PETRA.setSeaAccess(gameState, ent);
+		if (ent && ent.isOwn(PlayerID) && ent.foundationProgress() !== undefined && ent.hasClasses(["Dock", "Shipyard", "Port"]))
+			DELPHI.setSeaAccess(gameState, ent);
 	}
 
 	for (let evt of events.TrainingFinished)
@@ -268,7 +268,7 @@ PETRA.NavalManager.prototype.checkEvents = function(gameState, queues, events)
 			let ent = gameState.getEntityById(entId);
 			if (!ent || !ent.hasClass("Ship") || !ent.isOwn(PlayerID))
 				continue;
-			PETRA.setSeaAccess(gameState, ent);
+			DELPHI.setSeaAccess(gameState, ent);
 		}
 	}
 
@@ -302,7 +302,7 @@ PETRA.NavalManager.prototype.checkEvents = function(gameState, queues, events)
 			{
 				if (!ent.position())  // unit from another ship of this plan ... do nothing
 					continue;
-				let access = PETRA.getLandAccess(gameState, ent);
+				let access = DELPHI.getLandAccess(gameState, ent);
 				let endPos = ent.getMetadata(PlayerID, "endPos");
 				ent.setMetadata(PlayerID, "transport", undefined);
 				ent.setMetadata(PlayerID, "onBoard", undefined);
@@ -322,13 +322,13 @@ PETRA.NavalManager.prototype.checkEvents = function(gameState, queues, events)
 		if (evt.to !== PlayerID)
 			continue;
 		let ent = gameState.getEntityById(evt.entity);
-		if (ent && ent.hasClasses(["Dock", "Shipyard"]))
-			PETRA.setSeaAccess(gameState, ent);
+		if (ent && ent.hasClasses(["Dock", "Shipyard", "Port"]))
+			DELPHI.setSeaAccess(gameState, ent);
 	}
 };
 
 
-PETRA.NavalManager.prototype.getPlan = function(ID)
+DELPHI.NavalManager.prototype.getPlan = function(ID)
 {
 	for (let plan of this.transportPlans)
 		if (plan.ID === ID)
@@ -336,7 +336,7 @@ PETRA.NavalManager.prototype.getPlan = function(ID)
 	return undefined;
 };
 
-PETRA.NavalManager.prototype.addPlan = function(plan)
+DELPHI.NavalManager.prototype.addPlan = function(plan)
 {
 	this.transportPlans.push(plan);
 };
@@ -346,7 +346,7 @@ PETRA.NavalManager.prototype.addPlan = function(plan)
  * (many units can then call this separately and end up in the same plan)
  * TODO  check garrison classes
  */
-PETRA.NavalManager.prototype.requireTransport = function(gameState, ent, startIndex, endIndex, endPos)
+DELPHI.NavalManager.prototype.requireTransport = function(gameState, ent, startIndex, endIndex, endPos)
 {
 	if (!ent.canGarrison())
 		return false;
@@ -354,7 +354,7 @@ PETRA.NavalManager.prototype.requireTransport = function(gameState, ent, startIn
 	if (ent.getMetadata(PlayerID, "transport") !== undefined)
 	{
 		if (this.Config.debug > 0)
-			API3.warn("Petra naval manager error: unit " + ent.id() + " has already required a transport");
+			API3.warn("Delphi naval manager error: unit " + ent.id() + " has already required a transport");
 		return false;
 	}
 
@@ -364,7 +364,7 @@ PETRA.NavalManager.prototype.requireTransport = function(gameState, ent, startIn
 		if (plan.startIndex != startIndex || plan.endIndex != endIndex || plan.state != "boarding")
 			continue;
 		// Limit the number of siege units per transport to avoid problems when ungarrisoning
-		if (PETRA.isSiegeUnit(ent) && plan.units.filter(unit => PETRA.isSiegeUnit(unit)).length > 3)
+		if (DELPHI.isSiegeUnit(ent) && plan.units.filter(unit => DELPHI.isSiegeUnit(unit)).length > 3)
 			continue;
 		plans.push(plan);
 	}
@@ -376,7 +376,7 @@ PETRA.NavalManager.prototype.requireTransport = function(gameState, ent, startIn
 		return true;
 	}
 
-	let plan = new PETRA.TransportPlan(gameState, [ent], startIndex, endIndex, endPos);
+	let plan = new DELPHI.TransportPlan(gameState, [ent], startIndex, endIndex, endPos);
 	if (plan.failed)
 	{
 		if (this.Config.debug > 1)
@@ -389,11 +389,11 @@ PETRA.NavalManager.prototype.requireTransport = function(gameState, ent, startIn
 };
 
 /** split a transport plan in two, moving all entities not yet affected to a ship in the new plan */
-PETRA.NavalManager.prototype.splitTransport = function(gameState, plan)
+DELPHI.NavalManager.prototype.splitTransport = function(gameState, plan)
 {
 	if (this.Config.debug > 1)
 		API3.warn(">>>> split of transport plan started <<<<");
-	let newplan = new PETRA.TransportPlan(gameState, [], plan.startIndex, plan.endIndex, plan.endPos);
+	let newplan = new DELPHI.TransportPlan(gameState, [], plan.startIndex, plan.endIndex, plan.endPos);
 	if (newplan.failed)
 	{
 		if (this.Config.debug > 1)
@@ -419,7 +419,7 @@ PETRA.NavalManager.prototype.splitTransport = function(gameState, plan)
  * create a transport from a garrisoned ship to a land location
  * needed at start game when starting with a garrisoned ship
  */
-PETRA.NavalManager.prototype.createTransportIfNeeded = function(gameState, fromPos, toPos, toAccess)
+DELPHI.NavalManager.prototype.createTransportIfNeeded = function(gameState, fromPos, toPos, toAccess)
 {
 	let fromAccess = gameState.ai.accessibility.getAccessValue(fromPos);
 	if (fromAccess !== 1)
@@ -437,7 +437,7 @@ PETRA.NavalManager.prototype.createTransportIfNeeded = function(gameState, fromP
 		for (let entId of ship.garrisoned())
 			units.push(gameState.getEntityById(entId));
 		// TODO check that the garrisoned units have not another purpose
-		let plan = new PETRA.TransportPlan(gameState, units, fromAccess, toAccess, toPos, ship);
+		let plan = new DELPHI.TransportPlan(gameState, units, fromAccess, toAccess, toPos, ship);
 		if (plan.failed)
 			continue;
 		plan.init(gameState);
@@ -446,7 +446,7 @@ PETRA.NavalManager.prototype.createTransportIfNeeded = function(gameState, fromP
 };
 
 // set minimal number of needed ships when a new event (new base or new attack plan)
-PETRA.NavalManager.prototype.setMinimalTransportShips = function(gameState, sea, number)
+DELPHI.NavalManager.prototype.setMinimalTransportShips = function(gameState, sea, number)
 {
 	if (!sea)
 		return;
@@ -455,7 +455,7 @@ PETRA.NavalManager.prototype.setMinimalTransportShips = function(gameState, sea,
 };
 
 // bumps up the number of ships we want if we need more.
-PETRA.NavalManager.prototype.checkLevels = function(gameState, queues)
+DELPHI.NavalManager.prototype.checkLevels = function(gameState, queues)
 {
 	if (queues.ships.hasQueuedUnits())
 		return;
@@ -484,7 +484,7 @@ PETRA.NavalManager.prototype.checkLevels = function(gameState, queues)
 			++this.wantedTransportShips[sea];
 };
 
-PETRA.NavalManager.prototype.maintainFleet = function(gameState, queues)
+DELPHI.NavalManager.prototype.maintainFleet = function(gameState, queues)
 {
 	if (queues.ships.hasQueuedUnits())
 		return;
@@ -503,7 +503,7 @@ PETRA.NavalManager.prototype.maintainFleet = function(gameState, queues)
 			let template = this.getBestShip(gameState, sea, "transport");
 			if (template)
 			{
-				queues.ships.addPlan(new PETRA.TrainingPlan(gameState, template, { "sea": sea }, 1, 1));
+				queues.ships.addPlan(new DELPHI.TrainingPlan(gameState, template, { "sea": sea }, 1, 1));
 				continue;
 			}
 		}
@@ -514,7 +514,7 @@ PETRA.NavalManager.prototype.maintainFleet = function(gameState, queues)
 			let template = this.getBestShip(gameState, sea, "fishing");
 			if (template)
 			{
-				queues.ships.addPlan(new PETRA.TrainingPlan(gameState, template, { "base": 0, "role": "worker", "sea": sea }, 1, 1));
+				queues.ships.addPlan(new DELPHI.TrainingPlan(gameState, template, { "base": 0, "role": "worker", "sea": sea }, 1, 1));
 				continue;
 			}
 		}
@@ -522,7 +522,7 @@ PETRA.NavalManager.prototype.maintainFleet = function(gameState, queues)
 };
 
 /** assigns free ships to plans that need some */
-PETRA.NavalManager.prototype.assignShipsToPlans = function(gameState)
+DELPHI.NavalManager.prototype.assignShipsToPlans = function(gameState)
 {
 	for (let plan of this.transportPlans)
 		if (plan.needTransportShips)
@@ -530,7 +530,7 @@ PETRA.NavalManager.prototype.assignShipsToPlans = function(gameState)
 };
 
 /** Return true if this ship is likeky (un)garrisoning units */
-PETRA.NavalManager.prototype.isShipBoarding = function(ship)
+DELPHI.NavalManager.prototype.isShipBoarding = function(ship)
 {
 	if (!ship.position())
 		return false;
@@ -544,7 +544,7 @@ PETRA.NavalManager.prototype.isShipBoarding = function(ship)
  * TODO Ships entity collections are currently in two parts as the trader ships are dealt with
  * in the tradeManager. That should be modified to avoid dupplicating all the code here.
  */
-PETRA.NavalManager.prototype.moveApart = function(gameState)
+DELPHI.NavalManager.prototype.moveApart = function(gameState)
 {
 	let blockedShips = [];
 	let blockedIds = [];
@@ -591,13 +591,13 @@ PETRA.NavalManager.prototype.moveApart = function(gameState)
 				continue;
 			ship.setMetadata(PlayerID, "stationnary", true);
 			// Check if there are some treasure around
-			if (PETRA.gatherTreasure(gameState, ship, true))
+			if (DELPHI.gatherTreasure(gameState, ship, true))
 				continue;
 			// Do not stay idle near a dock to not disturb other ships
 			let sea = ship.getMetadata(PlayerID, "sea");
 			for (let dock of gameState.getAllyStructures().filter(API3.Filters.byClass("Dock")).values())
 			{
-				if (PETRA.getSeaAccess(gameState, dock) != sea)
+				if (DELPHI.getSeaAccess(gameState, dock) != sea)
 					continue;
 				if (API3.SquareVectorDistance(shipPosition, dock.position()) > 4900)
 					continue;
@@ -648,13 +648,13 @@ PETRA.NavalManager.prototype.moveApart = function(gameState)
 				continue;
 			ship.setMetadata(PlayerID, "stationnary", true);
 			// Check if there are some treasure around
-			if (PETRA.gatherTreasure(gameState, ship, true))
+			if (DELPHI.gatherTreasure(gameState, ship, true))
 				continue;
 			// Do not stay idle near a dock to not disturb other ships
 			let sea = ship.getMetadata(PlayerID, "sea");
 			for (let dock of gameState.getAllyStructures().filter(API3.Filters.byClass("Dock")).values())
 			{
-				if (PETRA.getSeaAccess(gameState, dock) != sea)
+				if (DELPHI.getSeaAccess(gameState, dock) != sea)
 					continue;
 				if (API3.SquareVectorDistance(shipPosition, dock.position()) > 4900)
 					continue;
@@ -706,7 +706,7 @@ PETRA.NavalManager.prototype.moveApart = function(gameState)
 	}
 };
 
-PETRA.NavalManager.prototype.buildNavalStructures = function(gameState, queues)
+DELPHI.NavalManager.prototype.buildNavalStructures = function(gameState, queues)
 {
 	if (!gameState.ai.HQ.navalMap || !gameState.ai.HQ.baseManagers[1])
 		return;
@@ -731,7 +731,7 @@ PETRA.NavalManager.prototype.buildNavalStructures = function(gameState, queues)
 						continue;
 					let wantedLand = {};
 					wantedLand[base.accessIndex] = true;
-					queues.dock.addPlan(new PETRA.ConstructionPlan(gameState, "structures/{civ}/dock", { "land": wantedLand, "sea": sea }));
+					queues.dock.addPlan(new DELPHI.ConstructionPlan(gameState, "structures/{civ}/dock", { "land": wantedLand, "sea": sea }));
 					dockStarted = true;
 					break;
 				}
@@ -761,11 +761,11 @@ PETRA.NavalManager.prototype.buildNavalStructures = function(gameState, queues)
 		if (base.anchor)
 			wantedLand[base.accessIndex] = true;
 	let sea = this.docks.toEntityArray()[0].getMetadata(PlayerID, "sea");
-	queues.militaryBuilding.addPlan(new PETRA.ConstructionPlan(gameState, template, { "land": wantedLand, "sea": sea }));
+	queues.militaryBuilding.addPlan(new DELPHI.ConstructionPlan(gameState, template, { "land": wantedLand, "sea": sea }));
 };
 
 /** goal can be either attack (choose ship with best arrowCount) or transport (choose ship with best capacity) */
-PETRA.NavalManager.prototype.getBestShip = function(gameState, sea, goal)
+DELPHI.NavalManager.prototype.getBestShip = function(gameState, sea, goal)
 {
 	let civ = gameState.getPlayerCiv();
 	let trainableShips = [];
@@ -822,7 +822,7 @@ PETRA.NavalManager.prototype.getBestShip = function(gameState, sea, goal)
 	return bestShip;
 };
 
-PETRA.NavalManager.prototype.update = function(gameState, queues, events)
+DELPHI.NavalManager.prototype.update = function(gameState, queues, events)
 {
 	Engine.ProfileStart("Naval Manager update");
 
@@ -853,7 +853,7 @@ PETRA.NavalManager.prototype.update = function(gameState, queues, events)
 	Engine.ProfileStop();
 };
 
-PETRA.NavalManager.prototype.Serialize = function()
+DELPHI.NavalManager.prototype.Serialize = function()
 {
 	let properties = {
 		"wantedTransportShips": this.wantedTransportShips,
@@ -871,7 +871,7 @@ PETRA.NavalManager.prototype.Serialize = function()
 	return { "properties": properties, "transports": transports };
 };
 
-PETRA.NavalManager.prototype.Deserialize = function(gameState, data)
+DELPHI.NavalManager.prototype.Deserialize = function(gameState, data)
 {
 	for (let key in data.properties)
 		this[key] = data.properties[key];
@@ -880,7 +880,7 @@ PETRA.NavalManager.prototype.Deserialize = function(gameState, data)
 	for (let i in data.transports)
 	{
 		let dataPlan = data.transports[i];
-		let plan = new PETRA.TransportPlan(gameState, [], dataPlan.startIndex, dataPlan.endIndex, dataPlan.endPos);
+		let plan = new DELPHI.TransportPlan(gameState, [], dataPlan.startIndex, dataPlan.endIndex, dataPlan.endPos);
 		plan.Deserialize(dataPlan);
 		plan.init(gameState);
 		this.transportPlans.push(plan);
diff --git a/binaries/data/mods/public/simulation/ai/delphi/queue.js b/binaries/data/mods/public/simulation/ai/delphi/queue.js
index 70ea8b01c4..062e141e42 100644
--- a/binaries/data/mods/public/simulation/ai/delphi/queue.js
+++ b/binaries/data/mods/public/simulation/ai/delphi/queue.js
@@ -1,19 +1,19 @@
 /**
  * Holds a list of wanted plans to train or construct
  */
-PETRA.Queue = function()
+DELPHI.Queue = function()
 {
 	this.plans = [];
 	this.paused = false;
 	this.switched = 0;
 };
 
-PETRA.Queue.prototype.empty = function()
+DELPHI.Queue.prototype.empty = function()
 {
 	this.plans = [];
 };
 
-PETRA.Queue.prototype.addPlan = function(newPlan)
+DELPHI.Queue.prototype.addPlan = function(newPlan)
 {
 	if (!newPlan)
 		return;
@@ -30,7 +30,7 @@ PETRA.Queue.prototype.addPlan = function(newPlan)
 	this.plans.push(newPlan);
 };
 
-PETRA.Queue.prototype.check= function(gameState)
+DELPHI.Queue.prototype.check= function(gameState)
 {
 	while (this.plans.length > 0)
 	{
@@ -42,14 +42,14 @@ PETRA.Queue.prototype.check= function(gameState)
 	}
 };
 
-PETRA.Queue.prototype.getNext = function()
+DELPHI.Queue.prototype.getNext = function()
 {
 	if (this.plans.length > 0)
 		return this.plans[0];
 	return null;
 };
 
-PETRA.Queue.prototype.startNext = function(gameState)
+DELPHI.Queue.prototype.startNext = function(gameState)
 {
 	if (this.plans.length > 0)
 	{
@@ -63,7 +63,7 @@ PETRA.Queue.prototype.startNext = function(gameState)
  * returns the maximal account we'll accept for this queue.
  * Currently all the cost of the first element and fraction of that of the second
  */
-PETRA.Queue.prototype.maxAccountWanted = function(gameState, fraction)
+DELPHI.Queue.prototype.maxAccountWanted = function(gameState, fraction)
 {
 	let cost = new API3.Resources();
 	if (this.plans.length > 0 && this.plans[0].isGo(gameState))
@@ -77,7 +77,7 @@ PETRA.Queue.prototype.maxAccountWanted = function(gameState, fraction)
 	return cost;
 };
 
-PETRA.Queue.prototype.queueCost = function()
+DELPHI.Queue.prototype.queueCost = function()
 {
 	let cost = new API3.Resources();
 	for (let plan of this.plans)
@@ -85,17 +85,17 @@ PETRA.Queue.prototype.queueCost = function()
 	return cost;
 };
 
-PETRA.Queue.prototype.length = function()
+DELPHI.Queue.prototype.length = function()
 {
 	return this.plans.length;
 };
 
-PETRA.Queue.prototype.hasQueuedUnits = function()
+DELPHI.Queue.prototype.hasQueuedUnits = function()
 {
 	return this.plans.length > 0;
 };
 
-PETRA.Queue.prototype.countQueuedUnits = function()
+DELPHI.Queue.prototype.countQueuedUnits = function()
 {
 	let count = 0;
 	for (let plan of this.plans)
@@ -103,12 +103,12 @@ PETRA.Queue.prototype.countQueuedUnits = function()
 	return count;
 };
 
-PETRA.Queue.prototype.hasQueuedUnitsWithClass = function(classe)
+DELPHI.Queue.prototype.hasQueuedUnitsWithClass = function(classe)
 {
 	return this.plans.some(plan => plan.template && plan.template.hasClass(classe));
 };
 
-PETRA.Queue.prototype.countQueuedUnitsWithClass = function(classe)
+DELPHI.Queue.prototype.countQueuedUnitsWithClass = function(classe)
 {
 	let count = 0;
 	for (let plan of this.plans)
@@ -117,7 +117,7 @@ PETRA.Queue.prototype.countQueuedUnitsWithClass = function(classe)
 	return count;
 };
 
-PETRA.Queue.prototype.countQueuedUnitsWithMetadata = function(data, value)
+DELPHI.Queue.prototype.countQueuedUnitsWithMetadata = function(data, value)
 {
 	let count = 0;
 	for (let plan of this.plans)
@@ -126,7 +126,7 @@ PETRA.Queue.prototype.countQueuedUnitsWithMetadata = function(data, value)
 	return count;
 };
 
-PETRA.Queue.prototype.Serialize = function()
+DELPHI.Queue.prototype.Serialize = function()
 {
 	let plans = [];
 	for (let plan of this.plans)
@@ -135,7 +135,7 @@ PETRA.Queue.prototype.Serialize = function()
 	return { "plans": plans, "paused": this.paused, "switched": this.switched };
 };
 
-PETRA.Queue.prototype.Deserialize = function(gameState, data)
+DELPHI.Queue.prototype.Deserialize = function(gameState, data)
 {
 	this.paused = data.paused;
 	this.switched = data.switched;
@@ -144,14 +144,14 @@ PETRA.Queue.prototype.Deserialize = function(gameState, data)
 	{
 		let plan;
 		if (dataPlan.category == "unit")
-			plan = new PETRA.TrainingPlan(gameState, dataPlan.type);
+			plan = new DELPHI.TrainingPlan(gameState, dataPlan.type);
 		else if (dataPlan.category == "building")
-			plan = new PETRA.ConstructionPlan(gameState, dataPlan.type);
+			plan = new DELPHI.ConstructionPlan(gameState, dataPlan.type);
 		else if (dataPlan.category == "technology")
-			plan = new PETRA.ResearchPlan(gameState, dataPlan.type);
+			plan = new DELPHI.ResearchPlan(gameState, dataPlan.type);
 		else
 		{
-			API3.warn("Petra deserialization error: plan unknown " + uneval(dataPlan));
+			API3.warn("Delphi deserialization error: plan unknown " + uneval(dataPlan));
 			continue;
 		}
 		plan.Deserialize(gameState, dataPlan);
diff --git a/binaries/data/mods/public/simulation/ai/delphi/queueManager.js b/binaries/data/mods/public/simulation/ai/delphi/queueManager.js
index 80b06133bd..6841851766 100644
--- a/binaries/data/mods/public/simulation/ai/delphi/queueManager.js
+++ b/binaries/data/mods/public/simulation/ai/delphi/queueManager.js
@@ -19,7 +19,7 @@
  * This system should be improved. It's probably not flexible enough.
  */
 
-PETRA.QueueManager = function(Config, queues)
+DELPHI.QueueManager = function(Config, queues)
 {
 	this.Config = Config;
 	this.queues = queues;
@@ -39,7 +39,7 @@ PETRA.QueueManager = function(Config, queues)
 	this.queueArrays.sort((a, b) => priorities[b[0]] - priorities[a[0]]);
 };
 
-PETRA.QueueManager.prototype.getAvailableResources = function(gameState)
+DELPHI.QueueManager.prototype.getAvailableResources = function(gameState)
 {
 	let resources = gameState.getResources();
 	for (let key in this.queues)
@@ -47,7 +47,7 @@ PETRA.QueueManager.prototype.getAvailableResources = function(gameState)
 	return resources;
 };
 
-PETRA.QueueManager.prototype.getTotalAccountedResources = function()
+DELPHI.QueueManager.prototype.getTotalAccountedResources = function()
 {
 	let resources = new API3.Resources();
 	for (let key in this.queues)
@@ -55,7 +55,7 @@ PETRA.QueueManager.prototype.getTotalAccountedResources = function()
 	return resources;
 };
 
-PETRA.QueueManager.prototype.currentNeeds = function(gameState)
+DELPHI.QueueManager.prototype.currentNeeds = function(gameState)
 {
 	let needed = new API3.Resources();
 	// queueArrays because it's faster.
@@ -77,7 +77,7 @@ PETRA.QueueManager.prototype.currentNeeds = function(gameState)
 
 // calculate the gather rates we'd want to be able to start all elements in our queues
 // TODO: many things.
-PETRA.QueueManager.prototype.wantedGatherRates = function(gameState)
+DELPHI.QueueManager.prototype.wantedGatherRates = function(gameState)
 {
 	// default values for first turn when we have not yet set our queues.
 	if (gameState.ai.playedTurn === 0)
@@ -154,7 +154,7 @@ PETRA.QueueManager.prototype.wantedGatherRates = function(gameState)
 	return rates;
 };
 
-PETRA.QueueManager.prototype.printQueues = function(gameState)
+DELPHI.QueueManager.prototype.printQueues = function(gameState)
 {
 	let numWorkers = 0;
 	gameState.getOwnUnits().forEach(ent => {
@@ -190,7 +190,7 @@ PETRA.QueueManager.prototype.printQueues = function(gameState)
 	API3.warn("------------------------------------");
 };
 
-PETRA.QueueManager.prototype.clear = function()
+DELPHI.QueueManager.prototype.clear = function()
 {
 	for (let i in this.queues)
 		this.queues[i].empty();
@@ -199,7 +199,7 @@ PETRA.QueueManager.prototype.clear = function()
 /**
  * set accounts of queue i from the unaccounted resources
  */
-PETRA.QueueManager.prototype.setAccounts = function(gameState, cost, i)
+DELPHI.QueueManager.prototype.setAccounts = function(gameState, cost, i)
 {
 	let available = this.getAvailableResources(gameState);
 	for (let res of Resources.GetCodes())
@@ -213,7 +213,7 @@ PETRA.QueueManager.prototype.setAccounts = function(gameState, cost, i)
 /**
  * transfer accounts from queue i to queue j
  */
-PETRA.QueueManager.prototype.transferAccounts = function(cost, i, j)
+DELPHI.QueueManager.prototype.transferAccounts = function(cost, i, j)
 {
 	for (let res of Resources.GetCodes())
 	{
@@ -228,7 +228,7 @@ PETRA.QueueManager.prototype.transferAccounts = function(cost, i, j)
 /**
  * distribute the resources between the different queues according to their priorities
  */
-PETRA.QueueManager.prototype.distributeResources = function(gameState)
+DELPHI.QueueManager.prototype.distributeResources = function(gameState)
 {
 	let availableRes = this.getAvailableResources(gameState);
 	for (let res of Resources.GetCodes())
@@ -313,11 +313,11 @@ PETRA.QueueManager.prototype.distributeResources = function(gameState)
 			}
 		}
 		if (available < 0)
-			API3.warn("Petra: problem with remaining " + res + " in queueManager " + available);
+			API3.warn("Delphi: problem with remaining " + res + " in queueManager " + available);
 	}
 };
 
-PETRA.QueueManager.prototype.switchResource = function(gameState, res)
+DELPHI.QueueManager.prototype.switchResource = function(gameState, res)
 {
 	// We have no available resources, see if we can't "compact" them in one queue.
 	// compare queues 2 by 2, and if one with a higher priority could be completed by our amount, give it.
@@ -354,7 +354,7 @@ PETRA.QueueManager.prototype.switchResource = function(gameState, res)
 };
 
 // Start the next item in the queue if we can afford it.
-PETRA.QueueManager.prototype.startNextItems = function(gameState)
+DELPHI.QueueManager.prototype.startNextItems = function(gameState)
 {
 	for (let q of this.queueArrays)
 	{
@@ -383,7 +383,7 @@ PETRA.QueueManager.prototype.startNextItems = function(gameState)
 	}
 };
 
-PETRA.QueueManager.prototype.update = function(gameState)
+DELPHI.QueueManager.prototype.update = function(gameState)
 {
 	Engine.ProfileStart("Queue Manager");
 
@@ -412,7 +412,7 @@ PETRA.QueueManager.prototype.update = function(gameState)
 };
 
 // Recovery system: if short of workers after an attack, pause (and reset) some queues to favor worker training
-PETRA.QueueManager.prototype.checkPausedQueues = function(gameState)
+DELPHI.QueueManager.prototype.checkPausedQueues = function(gameState)
 {
 	let numWorkers = gameState.countOwnEntitiesAndQueuedWithRole("worker");
 	let workersMin = Math.min(Math.max(12, 24 * this.Config.popScaling), this.Config.Economy.popPhase2);
@@ -466,14 +466,14 @@ PETRA.QueueManager.prototype.checkPausedQueues = function(gameState)
 	}
 };
 
-PETRA.QueueManager.prototype.canAfford = function(queue, cost)
+DELPHI.QueueManager.prototype.canAfford = function(queue, cost)
 {
 	if (!this.accounts[queue])
 		return false;
 	return this.accounts[queue].canAfford(cost);
 };
 
-PETRA.QueueManager.prototype.pauseQueue = function(queue, scrapAccounts)
+DELPHI.QueueManager.prototype.pauseQueue = function(queue, scrapAccounts)
 {
 	if (!this.queues[queue])
 		return;
@@ -482,13 +482,13 @@ PETRA.QueueManager.prototype.pauseQueue = function(queue, scrapAccounts)
 		this.accounts[queue].reset();
 };
 
-PETRA.QueueManager.prototype.unpauseQueue = function(queue)
+DELPHI.QueueManager.prototype.unpauseQueue = function(queue)
 {
 	if (this.queues[queue])
 		this.queues[queue].paused = false;
 };
 
-PETRA.QueueManager.prototype.pauseAll = function(scrapAccounts, but)
+DELPHI.QueueManager.prototype.pauseAll = function(scrapAccounts, but)
 {
 	for (let q in this.queues)
 	{
@@ -500,7 +500,7 @@ PETRA.QueueManager.prototype.pauseAll = function(scrapAccounts, but)
 	}
 };
 
-PETRA.QueueManager.prototype.unpauseAll = function(but)
+DELPHI.QueueManager.prototype.unpauseAll = function(but)
 {
 	for (let q in this.queues)
 		if (q != but)
@@ -508,12 +508,12 @@ PETRA.QueueManager.prototype.unpauseAll = function(but)
 };
 
 
-PETRA.QueueManager.prototype.addQueue = function(queueName, priority)
+DELPHI.QueueManager.prototype.addQueue = function(queueName, priority)
 {
 	if (this.queues[queueName] !== undefined)
 		return;
 
-	this.queues[queueName] = new PETRA.Queue();
+	this.queues[queueName] = new DELPHI.Queue();
 	this.priorities[queueName] = priority;
 	this.accounts[queueName] = new API3.Resources();
 
@@ -524,7 +524,7 @@ PETRA.QueueManager.prototype.addQueue = function(queueName, priority)
 	this.queueArrays.sort((a, b) => priorities[b[0]] - priorities[a[0]]);
 };
 
-PETRA.QueueManager.prototype.removeQueue = function(queueName)
+DELPHI.QueueManager.prototype.removeQueue = function(queueName)
 {
 	if (this.queues[queueName] === undefined)
 		return;
@@ -540,12 +540,12 @@ PETRA.QueueManager.prototype.removeQueue = function(queueName)
 	this.queueArrays.sort((a, b) => priorities[b[0]] - priorities[a[0]]);
 };
 
-PETRA.QueueManager.prototype.getPriority = function(queueName)
+DELPHI.QueueManager.prototype.getPriority = function(queueName)
 {
 	return this.priorities[queueName];
 };
 
-PETRA.QueueManager.prototype.changePriority = function(queueName, newPriority)
+DELPHI.QueueManager.prototype.changePriority = function(queueName, newPriority)
 {
 	if (this.Config.debug > 1)
 		API3.warn(">>> Priority of queue " + queueName + " changed from " + this.priorities[queueName] + " to " + newPriority);
@@ -555,7 +555,7 @@ PETRA.QueueManager.prototype.changePriority = function(queueName, newPriority)
 	this.queueArrays.sort((a, b) => priorities[b[0]] - priorities[a[0]]);
 };
 
-PETRA.QueueManager.prototype.Serialize = function()
+DELPHI.QueueManager.prototype.Serialize = function()
 {
 	let accounts = {};
 	let queues = {};
@@ -575,7 +575,7 @@ PETRA.QueueManager.prototype.Serialize = function()
 	};
 };
 
-PETRA.QueueManager.prototype.Deserialize = function(gameState, data)
+DELPHI.QueueManager.prototype.Deserialize = function(gameState, data)
 {
 	this.priorities = data.priorities;
 	this.queues = {};
@@ -585,7 +585,7 @@ PETRA.QueueManager.prototype.Deserialize = function(gameState, data)
 	this.queueArrays = [];
 	for (let q in data.queues)
 	{
-		this.queues[q] = new PETRA.Queue();
+		this.queues[q] = new DELPHI.Queue();
 		this.queues[q].Deserialize(gameState, data.queues[q]);
 		this.accounts[q] = new API3.Resources();
 		this.accounts[q].Deserialize(data.accounts[q]);
diff --git a/binaries/data/mods/public/simulation/ai/delphi/queueplan.js b/binaries/data/mods/public/simulation/ai/delphi/queueplan.js
index 20d40266df..055497876e 100644
--- a/binaries/data/mods/public/simulation/ai/delphi/queueplan.js
+++ b/binaries/data/mods/public/simulation/ai/delphi/queueplan.js
@@ -2,7 +2,7 @@
  * Common functions and variables to all queue plans.
  */
 
-PETRA.QueuePlan = function(gameState, type, metadata)
+DELPHI.QueuePlan = function(gameState, type, metadata)
 {
 	this.type = gameState.applyCiv(type);
 	this.metadata = metadata;
@@ -10,7 +10,7 @@ PETRA.QueuePlan = function(gameState, type, metadata)
 	this.template = gameState.getTemplate(this.type);
 	if (!this.template)
 	{
-		API3.warn("Tried to add the inexisting template " + this.type + " to Petra.");
+		API3.warn("Tried to add the inexisting template " + this.type + " to Delphi.");
 		return false;
 	}
 	this.ID = gameState.ai.uniqueIDs.plans++;
@@ -22,30 +22,30 @@ PETRA.QueuePlan = function(gameState, type, metadata)
 };
 
 /** Check the content of this queue */
-PETRA.QueuePlan.prototype.isInvalid = function(gameState)
+DELPHI.QueuePlan.prototype.isInvalid = function(gameState)
 {
 	return false;
 };
 
 /** if true, the queue manager will begin increasing this plan's account. */
-PETRA.QueuePlan.prototype.isGo = function(gameState)
+DELPHI.QueuePlan.prototype.isGo = function(gameState)
 {
 	return true;
 };
 
 /** can we start this plan immediately? */
-PETRA.QueuePlan.prototype.canStart = function(gameState)
+DELPHI.QueuePlan.prototype.canStart = function(gameState)
 {
 	return false;
 };
 
 /** process the plan. */
-PETRA.QueuePlan.prototype.start = function(gameState)
+DELPHI.QueuePlan.prototype.start = function(gameState)
 {
 	// should call onStart.
 };
 
-PETRA.QueuePlan.prototype.getCost = function()
+DELPHI.QueuePlan.prototype.getCost = function()
 {
 	let costs = new API3.Resources();
 	costs.add(this.cost);
@@ -60,6 +60,6 @@ PETRA.QueuePlan.prototype.getCost = function()
  * Need to be updated to actually do something if you want them to.
  * this is called by "Start" if it succeeds.
  */
-PETRA.QueuePlan.prototype.onStart = function(gameState)
+DELPHI.QueuePlan.prototype.onStart = function(gameState)
 {
 };
diff --git a/binaries/data/mods/public/simulation/ai/delphi/queueplanBuilding.js b/binaries/data/mods/public/simulation/ai/delphi/queueplanBuilding.js
index 9656c42f24..0714c09ae6 100644
--- a/binaries/data/mods/public/simulation/ai/delphi/queueplanBuilding.js
+++ b/binaries/data/mods/public/simulation/ai/delphi/queueplanBuilding.js
@@ -3,9 +3,9 @@
  * We'll try to fing a good position if non has been provided
  */
 
-PETRA.ConstructionPlan = function(gameState, type, metadata, position)
+DELPHI.ConstructionPlan = function(gameState, type, metadata, position)
 {
-	if (!PETRA.QueuePlan.call(this, gameState, type, metadata))
+	if (!DELPHI.QueuePlan.call(this, gameState, type, metadata))
 		return false;
 
 	this.position = position ? position : 0;
@@ -15,9 +15,9 @@ PETRA.ConstructionPlan = function(gameState, type, metadata, position)
 	return true;
 };
 
-PETRA.ConstructionPlan.prototype = Object.create(PETRA.QueuePlan.prototype);
+DELPHI.ConstructionPlan.prototype = Object.create(DELPHI.QueuePlan.prototype);
 
-PETRA.ConstructionPlan.prototype.canStart = function(gameState)
+DELPHI.ConstructionPlan.prototype.canStart = function(gameState)
 {
 	if (gameState.ai.HQ.turnCache.buildingBuilt)   // do not start another building if already one this turn
 		return false;
@@ -31,7 +31,7 @@ PETRA.ConstructionPlan.prototype.canStart = function(gameState)
 	return gameState.ai.HQ.buildManager.hasBuilder(this.type);
 };
 
-PETRA.ConstructionPlan.prototype.start = function(gameState)
+DELPHI.ConstructionPlan.prototype.start = function(gameState)
 {
 	Engine.ProfileStart("Building construction start");
 
@@ -41,7 +41,7 @@ PETRA.ConstructionPlan.prototype.start = function(gameState)
 	let builder = gameState.findBuilder(this.type);
 	if (!builder)
 	{
-		API3.warn("petra error: builder not found when starting construction.");
+		API3.warn("delphi error: builder not found when starting construction.");
 		Engine.ProfileStop();
 		return;
 	}
@@ -106,11 +106,11 @@ PETRA.ConstructionPlan.prototype.start = function(gameState)
 		gameState.ai.HQ.navalManager.createTransportIfNeeded(gameState, this.metadata.proximity, [pos.x, pos.z], this.metadata.access);
 };
 
-PETRA.ConstructionPlan.prototype.findGoodPosition = function(gameState)
+DELPHI.ConstructionPlan.prototype.findGoodPosition = function(gameState)
 {
 	let template = this.template;
 
-	if (template.buildPlacementType() == "shore")
+	if (template.buildPlacementType() == "shore" && !template.hasClass('Civic'))
 		return this.findDockPosition(gameState);
 
 	let HQ = gameState.ai.HQ;
@@ -118,8 +118,8 @@ PETRA.ConstructionPlan.prototype.findGoodPosition = function(gameState)
 	{
 		// recompute the best dropsite location in case some conditions have changed
 		let base = HQ.getBaseByID(this.metadata.base);
-		let type = this.metadata.type ? this.metadata.type : "wood";
-		const newpos = base.findBestDropsiteLocation(gameState, type, template._templateName);
+		let type = this.metadata && this.metadata.type ? this.metadata.type : "wood";
+		let newpos = base.findBestDropsiteLocation(gameState, type);
 		if (newpos && newpos.quality > 0)
 		{
 			let pos = newpos.pos;
@@ -131,15 +131,7 @@ PETRA.ConstructionPlan.prototype.findGoodPosition = function(gameState)
 	{
 		if (template.hasClass("CivCentre"))
 		{
-			let pos;
-			if (this.metadata && this.metadata.resource)
-			{
-				let proximity = this.metadata.proximity ? this.metadata.proximity : undefined;
-				pos = HQ.findEconomicCCLocation(gameState, template, this.metadata.resource, proximity);
-			}
-			else
-				pos = HQ.findStrategicCCLocation(gameState, template);
-
+			let pos = HQ.findGenericCCLocation(gameState, template);
 			if (pos)
 				return { "x": pos[0], "z": pos[1], "angle": 3*Math.PI/4, "base": 0 };
 			// No possible location, try to build instead a dock in a not-enemy island
@@ -161,18 +153,9 @@ PETRA.ConstructionPlan.prototype.findGoodPosition = function(gameState)
 			if (!template.hasClass("Fortress") || gameState.getOwnEntitiesByClass("Fortress", true).hasEntities())
 				return false;
 		}
-		else if (template.hasClass("Market")) // Docks are done before.
+		else if (template.hasClass("Civic")) // Docks are done before.
 		{
-			let pos = HQ.findMarketLocation(gameState, template);
-			if (pos && pos[2] > 0)
-			{
-				if (!this.metadata)
-					this.metadata = {};
-				this.metadata.expectedGain = pos[3];
-				return { "x": pos[0], "z": pos[1], "angle": 3*Math.PI/4, "base": pos[2] };
-			}
-			else if (!pos)
-				return false;
+			return HQ.findCivicLocation(gameState, template);
 		}
 	}
 
@@ -214,7 +197,7 @@ PETRA.ConstructionPlan.prototype.findGoodPosition = function(gameState)
 				let x = Math.round(pos[0] / cellSize);
 				let z = Math.round(pos[1] / cellSize);
 
-				let struct = PETRA.getBuiltEntity(gameState, ent);
+				let struct = DELPHI.getBuiltEntity(gameState, ent);
 				if (struct.resourceDropsiteTypes() && struct.resourceDropsiteTypes().indexOf("food") != -1)
 				{
 					if (template.hasClasses(["Field", "Corral"]))
@@ -222,6 +205,13 @@ PETRA.ConstructionPlan.prototype.findGoodPosition = function(gameState)
 					else // If this is not a field add a negative influence because we want to leave this area for fields
 						placement.addInfluence(x, z, 80 / cellSize, -20);
 				}
+				// markets and temples built close to civ centres
+				else if (template.hasClass('Civic') &&
+					!template.hasClass('CivCentre') &&
+					ent.hasClass('CivCentre'))
+				{
+					placement.addInfluence(x, z, 40/cellSize, 60);
+				}
 				else if (template.hasClass("House"))
 				{
 					if (ent.hasClass("House"))
@@ -248,7 +238,7 @@ PETRA.ConstructionPlan.prototype.findGoodPosition = function(gameState)
 			for (let j = 0; j < placement.map.length; ++j)
 			{
 				let value = placement.map[j] - gameState.sharedScript.resourceMaps.wood.map[j]/3;
-				if (HQ.borderMap.map[j] & PETRA.fullBorder_Mask)
+				if (HQ.borderMap.map[j] & DELPHI.fullBorder_Mask)
 					value /= 2;	// we need space around farmstead, so disfavor map border
 				placement.set(j, value);
 			}
@@ -270,9 +260,9 @@ PETRA.ConstructionPlan.prototype.findGoodPosition = function(gameState)
 				placement.map[j] = 0;
 			else if (placement.map[j] > 0)
 			{
-				if (favorBorder && HQ.borderMap.map[j] & PETRA.border_Mask)
+				if (favorBorder && HQ.borderMap.map[j] & DELPHI.border_Mask)
 					placement.set(j, placement.map[j] + 50);
-				else if (disfavorBorder && !(HQ.borderMap.map[j] & PETRA.fullBorder_Mask))
+				else if (disfavorBorder && !(HQ.borderMap.map[j] & DELPHI.fullBorder_Mask))
 					placement.set(j, placement.map[j] + 10);
 
 				let x = (j % placement.width + 0.5) * cellSize;
@@ -290,9 +280,9 @@ PETRA.ConstructionPlan.prototype.findGoodPosition = function(gameState)
 				placement.map[j] = 0;
 			else if (placement.map[j] > 0)
 			{
-				if (favorBorder && HQ.borderMap.map[j] & PETRA.border_Mask)
+				if (favorBorder && HQ.borderMap.map[j] & DELPHI.border_Mask)
 					placement.set(j, placement.map[j] + 50);
-				else if (disfavorBorder && !(HQ.borderMap.map[j] & PETRA.fullBorder_Mask))
+				else if (disfavorBorder && !(HQ.borderMap.map[j] & DELPHI.fullBorder_Mask))
 					placement.set(j, placement.map[j] + 10);
 
 				let x = (j % placement.width + 0.5) * cellSize;
@@ -311,7 +301,7 @@ PETRA.ConstructionPlan.prototype.findGoodPosition = function(gameState)
 	// note: not for houses and dropsites who ought to be closer to either each other or a resource.
 	// also not for fields who can be stacked quite a bit
 
-	let obstructions = PETRA.createObstructionMap(gameState, 0, template);
+	let obstructions = DELPHI.createObstructionMap(gameState, 0, template);
 	// obstructions.dumpIm(template.buildPlacementType() + "_obstructions.png");
 
 	let radius = 0;
@@ -346,7 +336,12 @@ PETRA.ConstructionPlan.prototype.findGoodPosition = function(gameState)
 	let territorypos = placement.gamePosToMapPos([x, z]);
 	let territoryIndex = territorypos[0] + territorypos[1]*placement.width;
 	// default angle = 3*Math.PI/4;
-	return { "x": x, "z": z, "angle": 3*Math.PI/4, "base": HQ.basesMap.map[territoryIndex] };
+	let angle = this.metadata && this.metadata.angle ? this.metadata.angle : 3*Math.PI/4;
+	let outputBase = this.metadata && this.metadata.base ? this.metadata.base : HQ.basesMap.map[territoryIndex];
+	let output = { "x": x, "z": z, "angle": angle, "base": outputBase };
+	if (this.metadata && this.metadata.access)
+		output['access'] = this.metadata.access;
+	return output;
 };
 
 /**
@@ -359,12 +354,12 @@ PETRA.ConstructionPlan.prototype.findGoodPosition = function(gameState)
  * => we try not to be too far from our territory
  * In all cases, we add a bonus for nearby resources, and when a large extend of water in front ot it.
  */
-PETRA.ConstructionPlan.prototype.findDockPosition = function(gameState)
+DELPHI.ConstructionPlan.prototype.findDockPosition = function(gameState)
 {
 	let template = this.template;
 	let territoryMap = gameState.ai.HQ.territoryMap;
 
-	let obstructions = PETRA.createObstructionMap(gameState, 0, template);
+	let obstructions = DELPHI.createObstructionMap(gameState, 0, template);
 	// obstructions.dumpIm(template.buildPlacementType() + "_obstructions.png");
 
 	let bestIdx;
@@ -467,7 +462,7 @@ PETRA.ConstructionPlan.prototype.findDockPosition = function(gameState)
 			let dockDist = 0;
 			for (let dock of docks.values())
 			{
-				if (PETRA.getSeaAccess(gameState, dock) != navalPassMap[i])
+				if (DELPHI.getSeaAccess(gameState, dock) != navalPassMap[i])
 					continue;
 				let dist = API3.SquareVectorDistance(pos, dock.position());
 				if (dist > dockDist)
@@ -483,7 +478,7 @@ PETRA.ConstructionPlan.prototype.findDockPosition = function(gameState)
 		}
 
 		// Add a penalty if on the map border as ship movement will be difficult
-		if (gameState.ai.HQ.borderMap.map[j] & PETRA.fullBorder_Mask)
+		if (gameState.ai.HQ.borderMap.map[j] & DELPHI.fullBorder_Mask)
 			score += 20;
 
 		// Do a pre-selection, supposing we will have the best possible water
@@ -501,7 +496,7 @@ PETRA.ConstructionPlan.prototype.findDockPosition = function(gameState)
 		// Final selection now that the checkDockPlacement water is known
 		if (bestIdx !== undefined && score + 5 * (maxWater - ret.water) > bestVal)
 			continue;
-		if (this.metadata.proximity && gameState.ai.accessibility.regionSize[ret.land] < 4000)
+		if (this.metadata && this.metadata.proximity && gameState.ai.accessibility.regionSize[ret.land] < 4000)
 			continue;
 		if (gameState.ai.HQ.isDangerousLocation(gameState, pos, halfSize))
 			continue;
@@ -517,7 +512,7 @@ PETRA.ConstructionPlan.prototype.findDockPosition = function(gameState)
 		return false;
 
 	// if no good place with enough water around and still in first phase, wait for expansion at the next phase
-	if (!this.metadata.proximity && bestWater < 10 && gameState.currentPhase() == 1)
+	if (this.metadata && !this.metadata.proximity && bestWater < 10 && gameState.currentPhase() == 1)
 		return false;
 
 	let x = (bestIdx % obstructions.width + 0.5) * obstructions.cellSize;
@@ -534,7 +529,7 @@ PETRA.ConstructionPlan.prototype.findDockPosition = function(gameState)
 /**
  * Find a good island to build a dock.
  */
-PETRA.ConstructionPlan.prototype.buildOverseaDock = function(gameState, template)
+DELPHI.ConstructionPlan.prototype.buildOverseaDock = function(gameState, template)
 {
 	let docks = gameState.getOwnStructures().filter(API3.Filters.byClass("Dock"));
 	if (!docks.hasEntities())
@@ -554,7 +549,7 @@ PETRA.ConstructionPlan.prototype.buildOverseaDock = function(gameState, template
 		let keep = true;
 		for (let dock of docks.values())
 		{
-			if (PETRA.getLandAccess(gameState, dock) != i)
+			if (DELPHI.getLandAccess(gameState, dock) != i)
 				continue;
 			keep = false;
 			break;
@@ -564,7 +559,7 @@ PETRA.ConstructionPlan.prototype.buildOverseaDock = function(gameState, template
 		let sea;
 		for (let cc of ccEnts.values())
 		{
-			let ccAccess = PETRA.getLandAccess(gameState, cc);
+			let ccAccess = DELPHI.getLandAccess(gameState, cc);
 			if (ccAccess != i)
 			{
 				if (cc.owner() == PlayerID && !sea)
@@ -586,7 +581,7 @@ PETRA.ConstructionPlan.prototype.buildOverseaDock = function(gameState, template
 	if (!found)
 		return;
 	if (!gameState.ai.HQ.navalMap)
-		API3.warn("petra.findOverseaLand on a non-naval map??? we should never go there ");
+		API3.warn("delphi.findOverseaLand on a non-naval map??? we should never go there ");
 
 	let oldTemplate = this.template;
 	let oldMetadata = this.metadata;
@@ -615,7 +610,7 @@ PETRA.ConstructionPlan.prototype.buildOverseaDock = function(gameState, template
 };
 
 /** Algorithm taken from the function GetDockAngle in simulation/helpers/Commands.js */
-PETRA.ConstructionPlan.prototype.getDockAngle = function(gameState, x, z, size)
+DELPHI.ConstructionPlan.prototype.getDockAngle = function(gameState, x, z, size)
 {
 	let pos = gameState.ai.accessibility.gamePosToMapPos([x, z]);
 	let k = pos[0] + pos[1]*gameState.ai.accessibility.width;
@@ -677,7 +672,7 @@ PETRA.ConstructionPlan.prototype.getDockAngle = function(gameState, x, z, size)
  * to determine the special dock requirements
  * returns {"land": land index for this dock, "water": amount of water around this spot}
  */
-PETRA.ConstructionPlan.prototype.checkDockPlacement = function(gameState, x, z, halfDepth, halfWidth, angle)
+DELPHI.ConstructionPlan.prototype.checkDockPlacement = function(gameState, x, z, halfDepth, halfWidth, angle)
 {
 	let sz = halfDepth * Math.sin(angle);
 	let cz = halfDepth * Math.cos(angle);
@@ -742,7 +737,7 @@ PETRA.ConstructionPlan.prototype.checkDockPlacement = function(gameState, x, z,
 const around = [[ 1.0, 0.0], [ 0.87, 0.50], [ 0.50, 0.87], [ 0.0, 1.0], [-0.50, 0.87], [-0.87, 0.50],
 	        [-1.0, 0.0], [-0.87, -0.50], [-0.50, -0.87], [ 0.0, -1.0], [ 0.50, -0.87], [ 0.87, -0.50]];
 
-PETRA.ConstructionPlan.prototype.isDockLocation = function(gameState, j, dimension, wantedLand, wantedSea)
+DELPHI.ConstructionPlan.prototype.isDockLocation = function(gameState, j, dimension, wantedLand, wantedSea)
 {
 	let width = gameState.ai.HQ.territoryMap.width;
 	let cellSize = gameState.ai.HQ.territoryMap.cellSize;
@@ -789,7 +784,7 @@ PETRA.ConstructionPlan.prototype.isDockLocation = function(gameState, j, dimensi
  * return a measure of the proximity to our frontier (including our allies)
  * 0=inside, 1=less than 24m, 2= less than 48m, 3= less than 72m, 4=less than 96m, 5=above 96m
  */
-PETRA.ConstructionPlan.prototype.getFrontierProximity = function(gameState, j)
+DELPHI.ConstructionPlan.prototype.getFrontierProximity = function(gameState, j)
 {
 	let alliedVictory = gameState.getAlliedVictory();
 	let territoryMap = gameState.ai.HQ.territoryMap;
@@ -813,7 +808,7 @@ PETRA.ConstructionPlan.prototype.getFrontierProximity = function(gameState, j)
 			let jz = iz + Math.round(i*step*a[1]);
 			if (jz < 0 || jz >= width)
 				continue;
-			if (borderMap.map[jx+width*jz] & PETRA.outside_Mask)
+			if (borderMap.map[jx+width*jz] & DELPHI.outside_Mask)
 				continue;
 			territoryOwner = territoryMap.getOwnerIndex(jx+width*jz);
 			if (alliedVictory && gameState.isPlayerAlly(territoryOwner) || territoryOwner == PlayerID)
@@ -833,7 +828,7 @@ PETRA.ConstructionPlan.prototype.getFrontierProximity = function(gameState, j)
  * get the sum of the resources (except food) around, inside a given radius
  * resources have a weight (1 if dist=0 and 0 if dist=size) doubled for wood
  */
-PETRA.ConstructionPlan.prototype.getResourcesAround = function(gameState, types, i, radius)
+DELPHI.ConstructionPlan.prototype.getResourcesAround = function(gameState, types, i, radius)
 {
 	let resourceMaps = gameState.sharedScript.resourceMaps;
 	let w = resourceMaps.wood.width;
@@ -886,7 +881,7 @@ PETRA.ConstructionPlan.prototype.getResourcesAround = function(gameState, types,
 	return nbcell ? total / nbcell : 0;
 };
 
-PETRA.ConstructionPlan.prototype.isGo = function(gameState)
+DELPHI.ConstructionPlan.prototype.isGo = function(gameState)
 {
 	if (this.goRequirement && this.goRequirement == "houseNeeded")
 	{
@@ -914,13 +909,13 @@ PETRA.ConstructionPlan.prototype.isGo = function(gameState)
 	return true;
 };
 
-PETRA.ConstructionPlan.prototype.onStart = function(gameState)
+DELPHI.ConstructionPlan.prototype.onStart = function(gameState)
 {
 	if (this.queueToReset)
 		gameState.ai.queueManager.changePriority(this.queueToReset, gameState.ai.Config.priorities[this.queueToReset]);
 };
 
-PETRA.ConstructionPlan.prototype.Serialize = function()
+DELPHI.ConstructionPlan.prototype.Serialize = function()
 {
 	return {
 		"category": this.category,
@@ -935,7 +930,7 @@ PETRA.ConstructionPlan.prototype.Serialize = function()
 	};
 };
 
-PETRA.ConstructionPlan.prototype.Deserialize = function(gameState, data)
+DELPHI.ConstructionPlan.prototype.Deserialize = function(gameState, data)
 {
 	for (let key in data)
 		this[key] = data[key];
diff --git a/binaries/data/mods/public/simulation/ai/delphi/queueplanResearch.js b/binaries/data/mods/public/simulation/ai/delphi/queueplanResearch.js
index e66d7124a0..33f61375be 100644
--- a/binaries/data/mods/public/simulation/ai/delphi/queueplanResearch.js
+++ b/binaries/data/mods/public/simulation/ai/delphi/queueplanResearch.js
@@ -1,6 +1,6 @@
-PETRA.ResearchPlan = function(gameState, type, rush = false)
+DELPHI.ResearchPlan = function(gameState, type, rush = false)
 {
-	if (!PETRA.QueuePlan.call(this, gameState, type, {}))
+	if (!DELPHI.QueuePlan.call(this, gameState, type, {}))
 		return false;
 
 	if (this.template.researchTime === undefined)
@@ -17,9 +17,9 @@ PETRA.ResearchPlan = function(gameState, type, rush = false)
 	return true;
 };
 
-PETRA.ResearchPlan.prototype = Object.create(PETRA.QueuePlan.prototype);
+DELPHI.ResearchPlan.prototype = Object.create(DELPHI.QueuePlan.prototype);
 
-PETRA.ResearchPlan.prototype.canStart = function(gameState)
+DELPHI.ResearchPlan.prototype.canStart = function(gameState)
 {
 	this.researchers = this.getBestResearchers(gameState);
 	if (!this.researchers)
@@ -28,7 +28,7 @@ PETRA.ResearchPlan.prototype.canStart = function(gameState)
 	return true;
 };
 
-PETRA.ResearchPlan.prototype.getBestResearchers = function(gameState, noRequirementCheck = false)
+DELPHI.ResearchPlan.prototype.getBestResearchers = function(gameState, noRequirementCheck = false)
 {
 	let allResearchers = gameState.findResearchers(this.type, noRequirementCheck);
 	if (!allResearchers || !allResearchers.hasEntities())
@@ -51,12 +51,12 @@ PETRA.ResearchPlan.prototype.getBestResearchers = function(gameState, noRequirem
 	return researchers;
 };
 
-PETRA.ResearchPlan.prototype.isInvalid = function(gameState)
+DELPHI.ResearchPlan.prototype.isInvalid = function(gameState)
 {
 	return gameState.isResearched(this.type) || gameState.isResearching(this.type);
 };
 
-PETRA.ResearchPlan.prototype.start = function(gameState)
+DELPHI.ResearchPlan.prototype.start = function(gameState)
 {
 	// Prefer researcher with shortest queues (no need to serialize this.researchers
 	// as the functions canStart and start are always called on the same turn)
@@ -68,7 +68,7 @@ PETRA.ResearchPlan.prototype.start = function(gameState)
 	this.onStart(gameState);
 };
 
-PETRA.ResearchPlan.prototype.onStart = function(gameState)
+DELPHI.ResearchPlan.prototype.onStart = function(gameState)
 {
 	if (this.queueToReset)
 		gameState.ai.queueManager.changePriority(this.queueToReset, gameState.ai.Config.priorities[this.queueToReset]);
@@ -83,7 +83,7 @@ PETRA.ResearchPlan.prototype.onStart = function(gameState)
 	}
 };
 
-PETRA.ResearchPlan.prototype.Serialize = function()
+DELPHI.ResearchPlan.prototype.Serialize = function()
 {
 	return {
 		"category": this.category,
@@ -97,7 +97,7 @@ PETRA.ResearchPlan.prototype.Serialize = function()
 	};
 };
 
-PETRA.ResearchPlan.prototype.Deserialize = function(gameState, data)
+DELPHI.ResearchPlan.prototype.Deserialize = function(gameState, data)
 {
 	for (let key in data)
 		this[key] = data[key];
diff --git a/binaries/data/mods/public/simulation/ai/delphi/queueplanTraining.js b/binaries/data/mods/public/simulation/ai/delphi/queueplanTraining.js
index edcd4f0056..a3ff3c1b3e 100644
--- a/binaries/data/mods/public/simulation/ai/delphi/queueplanTraining.js
+++ b/binaries/data/mods/public/simulation/ai/delphi/queueplanTraining.js
@@ -1,6 +1,6 @@
-PETRA.TrainingPlan = function(gameState, type, metadata, number = 1, maxMerge = 5)
+DELPHI.TrainingPlan = function(gameState, type, metadata, number = 1, maxMerge = 5)
 {
-	if (!PETRA.QueuePlan.call(this, gameState, type, metadata))
+	if (!DELPHI.QueuePlan.call(this, gameState, type, metadata))
 	{
 		API3.warn(" Plan training " + type + " canceled");
 		return false;
@@ -18,9 +18,9 @@ PETRA.TrainingPlan = function(gameState, type, metadata, number = 1, maxMerge =
 	return true;
 };
 
-PETRA.TrainingPlan.prototype = Object.create(PETRA.QueuePlan.prototype);
+DELPHI.TrainingPlan.prototype = Object.create(DELPHI.QueuePlan.prototype);
 
-PETRA.TrainingPlan.prototype.canStart = function(gameState)
+DELPHI.TrainingPlan.prototype.canStart = function(gameState)
 {
 	this.trainers = this.getBestTrainers(gameState);
 	if (!this.trainers)
@@ -29,7 +29,7 @@ PETRA.TrainingPlan.prototype.canStart = function(gameState)
 	return true;
 };
 
-PETRA.TrainingPlan.prototype.getBestTrainers = function(gameState)
+DELPHI.TrainingPlan.prototype.getBestTrainers = function(gameState)
 {
 	if (this.metadata && this.metadata.trainer)
 	{
@@ -63,7 +63,7 @@ PETRA.TrainingPlan.prototype.getBestTrainers = function(gameState)
 	return trainers;
 };
 
-PETRA.TrainingPlan.prototype.start = function(gameState)
+DELPHI.TrainingPlan.prototype.start = function(gameState)
 {
 	if (this.metadata && this.metadata.trainer)
 	{
@@ -129,13 +129,13 @@ PETRA.TrainingPlan.prototype.start = function(gameState)
 	this.onStart(gameState);
 };
 
-PETRA.TrainingPlan.prototype.addItem = function(amount = 1)
+DELPHI.TrainingPlan.prototype.addItem = function(amount = 1)
 {
 	this.number += amount;
 };
 
 /** Find the promoted types corresponding to this.type */
-PETRA.TrainingPlan.prototype.promotedTypes = function(gameState)
+DELPHI.TrainingPlan.prototype.promotedTypes = function(gameState)
 {
 	let types = [];
 	let promotion = this.template.promotion();
@@ -164,7 +164,7 @@ PETRA.TrainingPlan.prototype.promotedTypes = function(gameState)
 	return types;
 };
 
-PETRA.TrainingPlan.prototype.Serialize = function()
+DELPHI.TrainingPlan.prototype.Serialize = function()
 {
 	return {
 		"category": this.category,
@@ -177,7 +177,7 @@ PETRA.TrainingPlan.prototype.Serialize = function()
 	};
 };
 
-PETRA.TrainingPlan.prototype.Deserialize = function(gameState, data)
+DELPHI.TrainingPlan.prototype.Deserialize = function(gameState, data)
 {
 	for (let key in data)
 		this[key] = data[key];
diff --git a/binaries/data/mods/public/simulation/ai/delphi/researchManager.js b/binaries/data/mods/public/simulation/ai/delphi/researchManager.js
index 1dc014ae8e..458ed5c4a5 100644
--- a/binaries/data/mods/public/simulation/ai/delphi/researchManager.js
+++ b/binaries/data/mods/public/simulation/ai/delphi/researchManager.js
@@ -1,7 +1,7 @@
 /**
  * Manage the research
  */
-PETRA.ResearchManager = function(Config)
+DELPHI.ResearchManager = function(Config)
 {
 	this.Config = Config;
 };
@@ -9,7 +9,7 @@ PETRA.ResearchManager = function(Config)
 /**
  * Check if we can go to the next phase
  */
-PETRA.ResearchManager.prototype.checkPhase = function(gameState, queues)
+DELPHI.ResearchManager.prototype.checkPhase = function(gameState, queues)
 {
 	if (queues.majorTech.hasQueuedUnits())
 		return;
@@ -22,20 +22,20 @@ PETRA.ResearchManager.prototype.checkPhase = function(gameState, queues)
 	if (!nextPhaseName)
 		return;
 
-	let petraRequirements =
+	let delphiRequirements =
 		currentPhaseIndex == 1 && gameState.ai.HQ.getAccountedPopulation(gameState) >= this.Config.Economy.popPhase2 ||
 		currentPhaseIndex == 2 && gameState.ai.HQ.getAccountedWorkers(gameState) > this.Config.Economy.workPhase3 ||
 		currentPhaseIndex >= 3 && gameState.ai.HQ.getAccountedWorkers(gameState) > this.Config.Economy.workPhase4;
-	if (petraRequirements && gameState.hasResearchers(nextPhaseName, true))
+	if (delphiRequirements && gameState.hasResearchers(nextPhaseName, true))
 	{
 		gameState.ai.HQ.phasing = currentPhaseIndex + 1;
 		// Reset the queue priority in case it was changed during a previous phase update
 		gameState.ai.queueManager.changePriority("majorTech", gameState.ai.Config.priorities.majorTech);
-		queues.majorTech.addPlan(new PETRA.ResearchPlan(gameState, nextPhaseName, true));
+		queues.majorTech.addPlan(new DELPHI.ResearchPlan(gameState, nextPhaseName, true));
 	}
 };
 
-PETRA.ResearchManager.prototype.researchPopulationBonus = function(gameState, queues)
+DELPHI.ResearchManager.prototype.researchPopulationBonus = function(gameState, queues)
 {
 	if (queues.minorTech.hasQueuedUnits())
 		return;
@@ -48,12 +48,12 @@ PETRA.ResearchManager.prototype.researchPopulationBonus = function(gameState, qu
 		// TODO may-be loop on all modifs and check if the effect if positive ?
 		if (tech[1]._template.modifications[0].value !== "Population/Bonus")
 			continue;
-		queues.minorTech.addPlan(new PETRA.ResearchPlan(gameState, tech[0]));
+		queues.minorTech.addPlan(new DELPHI.ResearchPlan(gameState, tech[0]));
 		break;
 	}
 };
 
-PETRA.ResearchManager.prototype.researchTradeBonus = function(gameState, queues)
+DELPHI.ResearchManager.prototype.researchTradeBonus = function(gameState, queues)
 {
 	if (queues.minorTech.hasQueuedUnits())
 		return;
@@ -69,13 +69,13 @@ PETRA.ResearchManager.prototype.researchTradeBonus = function(gameState, queues)
 		if (tech[1]._template.modifications[0].value !== "UnitMotion/WalkSpeed" &&
                     tech[1]._template.modifications[0].value !== "Trader/GainMultiplier")
 			continue;
-		queues.minorTech.addPlan(new PETRA.ResearchPlan(gameState, tech[0]));
+		queues.minorTech.addPlan(new DELPHI.ResearchPlan(gameState, tech[0]));
 		break;
 	}
 };
 
 /** Techs to be searched for as soon as they are available */
-PETRA.ResearchManager.prototype.researchWantedTechs = function(gameState, techs)
+DELPHI.ResearchManager.prototype.researchWantedTechs = function(gameState, techs)
 {
 	let phase1 = gameState.currentPhase() === 1;
 	let available = phase1 ? gameState.ai.queueManager.getAvailableResources(gameState) : null;
@@ -119,7 +119,7 @@ PETRA.ResearchManager.prototype.researchWantedTechs = function(gameState, techs)
 };
 
 /** Techs to be searched for as soon as they are available, but only after phase 2 */
-PETRA.ResearchManager.prototype.researchPreferredTechs = function(gameState, techs)
+DELPHI.ResearchManager.prototype.researchPreferredTechs = function(gameState, techs)
 {
 	let phase2 = gameState.currentPhase() === 2;
 	let available = phase2 ? gameState.ai.queueManager.getAvailableResources(gameState) : null;
@@ -155,7 +155,7 @@ PETRA.ResearchManager.prototype.researchPreferredTechs = function(gameState, tec
 	return null;
 };
 
-PETRA.ResearchManager.prototype.update = function(gameState, queues)
+DELPHI.ResearchManager.prototype.update = function(gameState, queues)
 {
 	if (queues.minorTech.hasQueuedUnits() || queues.majorTech.hasQueuedUnits())
 		return;
@@ -168,12 +168,12 @@ PETRA.ResearchManager.prototype.update = function(gameState, queues)
 		if (techName.increasePriority)
 		{
 			gameState.ai.queueManager.changePriority("minorTech", 2*this.Config.priorities.minorTech);
-			let plan = new PETRA.ResearchPlan(gameState, techName.name);
+			let plan = new DELPHI.ResearchPlan(gameState, techName.name);
 			plan.queueToReset = "minorTech";
 			queues.minorTech.addPlan(plan);
 		}
 		else
-			queues.minorTech.addPlan(new PETRA.ResearchPlan(gameState, techName.name));
+			queues.minorTech.addPlan(new DELPHI.ResearchPlan(gameState, techName.name));
 		return;
 	}
 
@@ -186,12 +186,12 @@ PETRA.ResearchManager.prototype.update = function(gameState, queues)
 		if (techName.increasePriority)
 		{
 			gameState.ai.queueManager.changePriority("minorTech", 2*this.Config.priorities.minorTech);
-			let plan = new PETRA.ResearchPlan(gameState, techName.name);
+			let plan = new DELPHI.ResearchPlan(gameState, techName.name);
 			plan.queueToReset = "minorTech";
 			queues.minorTech.addPlan(plan);
 		}
 		else
-			queues.minorTech.addPlan(new PETRA.ResearchPlan(gameState, techName.name));
+			queues.minorTech.addPlan(new DELPHI.ResearchPlan(gameState, techName.name));
 		return;
 	}
 
@@ -221,10 +221,10 @@ PETRA.ResearchManager.prototype.update = function(gameState, queues)
 		return;
 
 	// randomly pick one. No worries about pairs in that case.
-	queues.minorTech.addPlan(new PETRA.ResearchPlan(gameState, pickRandom(techs)[0]));
+	queues.minorTech.addPlan(new DELPHI.ResearchPlan(gameState, pickRandom(techs)[0]));
 };
 
-PETRA.ResearchManager.prototype.CostSum = function(cost)
+DELPHI.ResearchManager.prototype.CostSum = function(cost)
 {
 	let costSum = 0;
 	for (let res in cost)
@@ -232,11 +232,11 @@ PETRA.ResearchManager.prototype.CostSum = function(cost)
 	return costSum;
 };
 
-PETRA.ResearchManager.prototype.Serialize = function()
+DELPHI.ResearchManager.prototype.Serialize = function()
 {
 	return {};
 };
 
-PETRA.ResearchManager.prototype.Deserialize = function(data)
+DELPHI.ResearchManager.prototype.Deserialize = function(data)
 {
 };
diff --git a/binaries/data/mods/public/simulation/ai/delphi/startingStrategy.js b/binaries/data/mods/public/simulation/ai/delphi/startingStrategy.js
index 513b0c7501..1ed3c003dd 100644
--- a/binaries/data/mods/public/simulation/ai/delphi/startingStrategy.js
+++ b/binaries/data/mods/public/simulation/ai/delphi/startingStrategy.js
@@ -3,7 +3,7 @@
  * depending on the initial conditions
  */
 
-PETRA.HQ.prototype.gameAnalysis = function(gameState)
+DELPHI.HQ.prototype.gameAnalysis = function(gameState)
 {
 	// Analysis of the terrain and the different access regions
 	if (!this.regionAnalysis(gameState))
@@ -19,7 +19,7 @@ PETRA.HQ.prototype.gameAnalysis = function(gameState)
 	this.structureAnalysis(gameState);
 
 	// Let's get our initial situation here.
-	let nobase = new PETRA.BaseManager(gameState, this.Config);
+	let nobase = new DELPHI.BaseManager(gameState, this.Config);
 	nobase.init(gameState);
 	nobase.accessIndex = 0;
 	this.baseManagers.push(nobase);   // baseManagers[0] will deal with unit/structure without base
@@ -61,7 +61,7 @@ PETRA.HQ.prototype.gameAnalysis = function(gameState)
 /**
  * Assign the starting entities to the different bases
  */
-PETRA.HQ.prototype.assignStartingEntities = function(gameState)
+DELPHI.HQ.prototype.assignStartingEntities = function(gameState)
 {
 	for (let ent of gameState.getOwnEntities().values())
 	{
@@ -74,7 +74,7 @@ PETRA.HQ.prototype.assignStartingEntities = function(gameState)
 		{
 			// TODO should support recursive garrisoning. Make a warning for now
 			if (ent.isGarrisonHolder() && ent.garrisoned().length)
-				API3.warn("Petra warning: support for garrisoned units inside garrisoned holders not yet implemented");
+				API3.warn("Delphi warning: support for garrisoned units inside garrisoned holders not yet implemented");
 			continue;
 		}
 
@@ -112,7 +112,7 @@ PETRA.HQ.prototype.assignStartingEntities = function(gameState)
 			if (ent.hasClass("Structure") && !ent.decaying() && ent.resourceDropsiteTypes())
 				bestbase = this.createBase(gameState, ent, "anchorless");
 			else
-				bestbase = PETRA.getBestBase(gameState, ent) || this.baseManagers[0];
+				bestbase = DELPHI.getBestBase(gameState, ent) || this.baseManagers[0];
 			bestbase.assignEntity(gameState, ent);
 		}
 		// now assign entities garrisoned inside this entity
@@ -136,7 +136,7 @@ PETRA.HQ.prototype.assignStartingEntities = function(gameState)
  * determine the main land Index (or water index if none)
  * as well as the list of allowed (land andf water) regions
  */
-PETRA.HQ.prototype.regionAnalysis = function(gameState)
+DELPHI.HQ.prototype.regionAnalysis = function(gameState)
 {
 	let accessibility = gameState.ai.accessibility;
 	let landIndex;
@@ -171,7 +171,7 @@ PETRA.HQ.prototype.regionAnalysis = function(gameState)
 	}
 	if (!landIndex && !seaIndex)
 	{
-		API3.warn("Petra error: it does not know how to interpret this map");
+		API3.warn("Delphi error: it does not know how to interpret this map");
 		return false;
 	}
 
@@ -230,7 +230,7 @@ PETRA.HQ.prototype.regionAnalysis = function(gameState)
  * load units and buildings from the config files
  * TODO: change that to something dynamic
  */
-PETRA.HQ.prototype.structureAnalysis = function(gameState)
+DELPHI.HQ.prototype.structureAnalysis = function(gameState)
 {
 	let civref = gameState.playerData.civ;
 	let civ = civref in this.Config.buildings ? civref : 'default';
@@ -244,7 +244,7 @@ PETRA.HQ.prototype.structureAnalysis = function(gameState)
  * build our first base
  * if not enough resource, try first to do a dock
  */
-PETRA.HQ.prototype.buildFirstBase = function(gameState)
+DELPHI.HQ.prototype.buildFirstBase = function(gameState)
 {
 	if (gameState.ai.queues.civilCentre.hasQueuedUnits())
 		return;
@@ -266,7 +266,7 @@ PETRA.HQ.prototype.buildFirstBase = function(gameState)
 				continue;
 			// If we can get a treasure around, just do it
 			if (ent.isIdle())
-				PETRA.gatherTreasure(gameState, ent);
+				DELPHI.gatherTreasure(gameState, ent);
 			// Then count the resources from the treasures being collected
 			let treasureId = ent.getMetadata(PlayerID, "treasure");
 			if (!treasureId)
@@ -306,12 +306,12 @@ PETRA.HQ.prototype.buildFirstBase = function(gameState)
 	{
 		if (!ent.hasClass("Worker"))
 			continue;
-		if (PETRA.isFastMoving(ent))
+		if (DELPHI.isFastMoving(ent))
 			continue;
 		let pos = ent.position();
 		if (!pos)
 		{
-			let holder = PETRA.getHolder(gameState, ent);
+			let holder = DELPHI.getHolder(gameState, ent);
 			if (!holder || !holder.position())
 				continue;
 			pos = holder.position();
@@ -345,10 +345,10 @@ PETRA.HQ.prototype.buildFirstBase = function(gameState)
 	if (goal == "dock")
 	{
 		let sea = startingPoint[imax].sea > 1 ? startingPoint[imax].sea : undefined;
-		gameState.ai.queues.dock.addPlan(new PETRA.ConstructionPlan(gameState, "structures/{civ}/dock", { "sea": sea, "proximity": startingPoint[imax].pos }));
+		gameState.ai.queues.dock.addPlan(new DELPHI.ConstructionPlan(gameState, "structures/{civ}/dock", { "sea": sea, "proximity": startingPoint[imax].pos }));
 	}
 	else
-		gameState.ai.queues.civilCentre.addPlan(new PETRA.ConstructionPlan(gameState, "structures/{civ}/civil_centre", { "base": -1, "resource": "wood", "proximity": startingPoint[imax].pos }));
+		gameState.ai.queues.civilCentre.addPlan(new DELPHI.ConstructionPlan(gameState, "structures/{civ}/civil_centre", { "base": -1, "resource": "wood", "proximity": startingPoint[imax].pos }));
 };
 
 /**
@@ -356,7 +356,7 @@ PETRA.HQ.prototype.buildFirstBase = function(gameState)
  *   - if one of our allies has a cc, affect a small fraction of our army for his defense, the rest will attack
  *   - otherwise all units will attack
  */
-PETRA.HQ.prototype.dispatchUnits = function(gameState)
+DELPHI.HQ.prototype.dispatchUnits = function(gameState)
 {
 	let allycc = gameState.getExclusiveAllyEntities().filter(API3.Filters.byClass("CivCentre")).toEntityArray();
 	if (allycc.length)
@@ -373,10 +373,10 @@ PETRA.HQ.prototype.dispatchUnits = function(gameState)
 				return;
 			if (ent.getMetadata(PlayerID, "allied"))
 				return;
-			let access = PETRA.getLandAccess(gameState, ent);
+			let access = DELPHI.getLandAccess(gameState, ent);
 			for (let cc of allycc)
 			{
-				if (!cc.position() || PETRA.getLandAccess(gameState, cc) != access)
+				if (!cc.position() || DELPHI.getLandAccess(gameState, cc) != access)
 					continue;
 				--num;
 				--num1;
@@ -392,10 +392,10 @@ PETRA.HQ.prototype.dispatchUnits = function(gameState)
 				return;
 			if (ent.getMetadata(PlayerID, "allied"))
 				return;
-			let access = PETRA.getLandAccess(gameState, ent);
+			let access = DELPHI.getLandAccess(gameState, ent);
 			for (let cc of allycc)
 			{
-				if (!cc.position() || PETRA.getLandAccess(gameState, cc) != access)
+				if (!cc.position() || DELPHI.getLandAccess(gameState, cc) != access)
 					continue;
 				--num;
 				--num2;
@@ -411,10 +411,10 @@ PETRA.HQ.prototype.dispatchUnits = function(gameState)
 				return;
 			if (ent.getMetadata(PlayerID, "allied"))
 				return;
-			let access = PETRA.getLandAccess(gameState, ent);
+			let access = DELPHI.getLandAccess(gameState, ent);
 			for (let cc of allycc)
 			{
-				if (!cc.position() || PETRA.getLandAccess(gameState, cc) != access)
+				if (!cc.position() || DELPHI.getLandAccess(gameState, cc) != access)
 					continue;
 				if (!ent.hasClass("Support"))
 					--num;
@@ -432,7 +432,7 @@ PETRA.HQ.prototype.dispatchUnits = function(gameState)
  *   - if on a small island, favor fishing
  *   - count the available wood resource, and allow rushes only if enough (we should otherwise favor expansion)
  */
-PETRA.HQ.prototype.configFirstBase = function(gameState)
+DELPHI.HQ.prototype.configFirstBase = function(gameState)
 {
 	if (this.baseManagers.length < 2)
 		return;
@@ -545,10 +545,11 @@ PETRA.HQ.prototype.configFirstBase = function(gameState)
 	}
 
 	// immediatly build a wood dropsite if possible.
-	if (!gameState.getOwnEntitiesByClass("DropsiteWood", true).hasEntities())
+	let template = gameState.applyCiv("structures/{civ}/storehouse");
+	if (!gameState.getOwnEntitiesByClass("Storehouse", true).hasEntities() && this.canBuild(gameState, template))
 	{
-		const newDP = this.baseManagers[1].findBestDropsiteAndLocation(gameState, "wood");
-		if (newDP.quality > 40 && this.canBuild(gameState, newDP.templateName))
+		let newDP = this.baseManagers[1].findBestDropsiteLocation(gameState, "wood");
+		if (newDP.quality > 40)
 		{
 			// if we start with enough workers, put our available resources in this first dropsite
 			// same thing if our pop exceed the allowed one, as we will need several houses
@@ -556,17 +557,17 @@ PETRA.HQ.prototype.configFirstBase = function(gameState)
 			if (numWorkers > 12 && newDP.quality > 60 ||
 				gameState.getPopulation() > gameState.getPopulationLimit() + 20)
 			{
-				const cost = new API3.Resources(gameState.getTemplate(newDP.templateName).cost());
+				let cost = new API3.Resources(gameState.getTemplate(template).cost());
 				gameState.ai.queueManager.setAccounts(gameState, cost, "dropsites");
 			}
-			gameState.ai.queues.dropsites.addPlan(new PETRA.ConstructionPlan(gameState, newDP.templateName, { "base": this.baseManagers[1].ID }, newDP.pos));
+			gameState.ai.queues.dropsites.addPlan(new DELPHI.ConstructionPlan(gameState, template, { "base": this.baseManagers[1].ID }, newDP.pos));
 		}
 	}
 	// and build immediately a corral if needed
 	if (this.needCorral)
 	{
-		const template = gameState.applyCiv("structures/{civ}/corral");
+		template = gameState.applyCiv("structures/{civ}/corral");
 		if (!gameState.getOwnEntitiesByClass("Corral", true).hasEntities() && this.canBuild(gameState, template))
-			gameState.ai.queues.corral.addPlan(new PETRA.ConstructionPlan(gameState, template, { "base": this.baseManagers[1].ID }));
+			gameState.ai.queues.corral.addPlan(new DELPHI.ConstructionPlan(gameState, template, { "base": this.baseManagers[1].ID }));
 	}
 };
diff --git a/binaries/data/mods/public/simulation/ai/delphi/tradeManager.js b/binaries/data/mods/public/simulation/ai/delphi/tradeManager.js
index 3a739aefe3..87338c4bd2 100644
--- a/binaries/data/mods/public/simulation/ai/delphi/tradeManager.js
+++ b/binaries/data/mods/public/simulation/ai/delphi/tradeManager.js
@@ -1,39 +1,40 @@
 /**
  * Manage the trade
  */
-PETRA.TradeManager = function(Config)
+DELPHI.TradeManager = function(Config)
 {
 	this.Config = Config;
 	this.tradeRoute = undefined;
 	this.potentialTradeRoute = undefined;
 	this.routeProspection = false;
-	this.targetNumTraders = this.Config.Economy.targetNumTraders;
+	this.traderRatio = this.Config.Economy.traderRatio;
 	this.warnedAllies = {};
 };
 
-PETRA.TradeManager.prototype.init = function(gameState)
+DELPHI.TradeManager.prototype.init = function(gameState)
 {
 	this.traders = gameState.getOwnUnits().filter(API3.Filters.byMetadata(PlayerID, "role", "trader"));
 	this.traders.registerUpdates();
 	this.minimalGain = gameState.ai.HQ.navalMap ? 3 : 5;
 };
 
-PETRA.TradeManager.prototype.hasTradeRoute = function()
+DELPHI.TradeManager.prototype.hasTradeRoute = function()
 {
 	return this.tradeRoute !== undefined;
 };
 
-PETRA.TradeManager.prototype.assignTrader = function(ent)
+DELPHI.TradeManager.prototype.assignTrader = function(ent)
 {
 	ent.setMetadata(PlayerID, "role", "trader");
 	this.traders.updateEnt(ent);
 };
 
-PETRA.TradeManager.prototype.trainMoreTraders = function(gameState, queues)
+DELPHI.TradeManager.prototype.trainMoreTraders = function(gameState, queues)
 {
 	if (!this.hasTradeRoute() || queues.trader.hasQueuedUnits())
 		return;
 
+	let targetNumTraders = gameState.getPopulationMax() * this.traderRatio;
 	let numTraders = this.traders.length;
 	let numSeaTraders = this.traders.filter(API3.Filters.byClass("Ship")).length;
 	let numLandTraders = numTraders - numSeaTraders;
@@ -50,9 +51,9 @@ PETRA.TradeManager.prototype.trainMoreTraders = function(gameState, queues)
 				numLandTraders += item.count;
 		}
 	});
-	if (numTraders >= this.targetNumTraders &&
-		(!this.tradeRoute.sea && numLandTraders >= Math.floor(this.targetNumTraders/2) ||
-		  this.tradeRoute.sea && numSeaTraders >= Math.floor(this.targetNumTraders/2)))
+	if (numTraders >= targetNumTraders &&
+		(!this.tradeRoute.sea && numLandTraders >= Math.floor(targetNumTraders/2) ||
+		  this.tradeRoute.sea && numSeaTraders >= Math.floor(targetNumTraders/2)))
 		return;
 
 	let template;
@@ -100,18 +101,18 @@ PETRA.TradeManager.prototype.trainMoreTraders = function(gameState, queues)
 	if (!gameState.getTemplate(template))
 	{
 		if (this.Config.debug > 0)
-			API3.warn("Petra error: trying to train " + template + " for civ " +
+			API3.warn("Delphi error: trying to train " + template + " for civ " +
 			          gameState.getPlayerCiv() + " but no template found.");
 		return;
 	}
-	queues.trader.addPlan(new PETRA.TrainingPlan(gameState, template, metadata, 1, 1));
+	queues.trader.addPlan(new DELPHI.TrainingPlan(gameState, template, metadata, 1, 1));
 };
 
-PETRA.TradeManager.prototype.updateTrader = function(gameState, ent)
+DELPHI.TradeManager.prototype.updateTrader = function(gameState, ent)
 {
 	if (ent.hasClass("Ship") && gameState.ai.playedTurn % 5 == 0 &&
 	    !ent.unitAIState().startsWith("INDIVIDUAL.COLLECTTREASURE") &&
-	    PETRA.gatherTreasure(gameState, ent, true))
+	    DELPHI.gatherTreasure(gameState, ent, true))
 		return;
 
 	if (!this.hasTradeRoute() || !ent.isIdle() || !ent.position())
@@ -122,7 +123,7 @@ PETRA.TradeManager.prototype.updateTrader = function(gameState, ent)
 	// TODO if the trader is idle and has workOrders, restore them to avoid losing the current gain
 
 	Engine.ProfileStart("Trade Manager");
-	let access = ent.hasClass("Ship") ? PETRA.getSeaAccess(gameState, ent) : PETRA.getLandAccess(gameState, ent);
+	let access = ent.hasClass("Ship") ? DELPHI.getSeaAccess(gameState, ent) : DELPHI.getLandAccess(gameState, ent);
 	let route = this.checkRoutes(gameState, access);
 	if (!route)
 	{
@@ -155,7 +156,7 @@ PETRA.TradeManager.prototype.updateTrader = function(gameState, ent)
 	Engine.ProfileStop();
 };
 
-PETRA.TradeManager.prototype.setTradingGoods = function(gameState)
+DELPHI.TradeManager.prototype.setTradingGoods = function(gameState)
 {
 	let resTradeCodes = Resources.GetTradableCodes();
 	if (!resTradeCodes.length)
@@ -167,31 +168,37 @@ PETRA.TradeManager.prototype.setTradingGoods = function(gameState)
 	let stocks = gameState.ai.HQ.getTotalResourceLevel(gameState);
 	let mostNeeded = gameState.ai.HQ.pickMostNeededResources(gameState, resTradeCodes);
 	let wantedRates = gameState.ai.HQ.GetWantedGatherRates(gameState);
+	let actualWantedRates = new Map();
+	for (let res in wantedRates) {
+		if (resTradeCodes.indexOf(res) !== -1) {
+			actualWantedRates[res] = wantedRates[res];
+		}// end if !resTradeCodes.indexOf(res)
+	}// end for res in wantedRates
+	wantedRates = actualWantedRates;
 	let remaining = 100;
-	let targetNum = this.Config.Economy.targetNumTraders;
+	let targetNum = gameState.getPopulationMax() * this.traderRatio;
 	for (let res of resTradeCodes)
 	{
 		if (res == "food")
 			continue;
 		let wantedRate = wantedRates[res];
-		if (stocks[res] < 200)
+		if (stocks.hasOwnProperty(res))
 		{
-			tradingGoods[res] = wantedRate > 0 ? 20 : 10;
-			targetNum += Math.min(5, 3 + Math.ceil(wantedRate/30));
-		}
-		else if (stocks[res] < 500)
-		{
-			tradingGoods[res] = wantedRate > 0 ? 15 : 10;
-			targetNum += 2;
-		}
-		else if (stocks[res] < 1000)
-		{
-			tradingGoods[res] = 10;
-			targetNum += 1;
+			if (stocks[res] < 200)
+			{
+				tradingGoods[res] = wantedRate > 0 ? 20 : 10;
+			}
+			else if (stocks[res] < 500)
+			{
+				tradingGoods[res] = wantedRate > 0 ? 15 : 10;
+			}
+			else if (stocks[res] < 1000)
+			{
+				tradingGoods[res] = 10;
+			}
 		}
 		remaining -= tradingGoods[res];
-	}
-	this.targetNumTraders = Math.round(this.Config.popScaling * targetNum);
+	}// end for res
 
 
 	// then add what is needed now
@@ -212,7 +219,7 @@ PETRA.TradeManager.prototype.setTradingGoods = function(gameState)
  * Try to barter unneeded resources for needed resources.
  * only once per turn because the info is not updated within a turn
  */
-PETRA.TradeManager.prototype.performBarter = function(gameState)
+DELPHI.TradeManager.prototype.performBarter = function(gameState)
 {
 	let barterers = gameState.getOwnEntitiesByClass("Barter", true).filter(API3.Filters.isBuilt()).toEntityArray();
 	if (barterers.length == 0)
@@ -329,7 +336,7 @@ PETRA.TradeManager.prototype.performBarter = function(gameState)
 	return false;
 };
 
-PETRA.TradeManager.prototype.checkEvents = function(gameState, events)
+DELPHI.TradeManager.prototype.checkEvents = function(gameState, events)
 {
 	// check if one market from a traderoute is renamed, change the route accordingly
 	for (let evt of events.EntityRenamed)
@@ -398,18 +405,18 @@ PETRA.TradeManager.prototype.checkEvents = function(gameState, events)
 	return false;
 };
 
-PETRA.TradeManager.prototype.activateProspection = function(gameState)
+DELPHI.TradeManager.prototype.activateProspection = function(gameState)
 {
 	this.routeProspection = true;
 	gameState.ai.HQ.buildManager.setBuildable(gameState.applyCiv("structures/{civ}/market"));
-	gameState.ai.HQ.buildManager.setBuildable(gameState.applyCiv("structures/{civ}/dock"));
+	gameState.ai.HQ.buildManager.setBuildable(gameState.applyCiv("structures/{civ}/port"));
 };
 
 /**
  * fills the best trade route in this.tradeRoute and the best potential route in this.potentialTradeRoute
  * If an index is given, it returns the best route with this index or the best land route if index is a land index
  */
-PETRA.TradeManager.prototype.checkRoutes = function(gameState, accessIndex)
+DELPHI.TradeManager.prototype.checkRoutes = function(gameState, accessIndex)
 {
 	// If we cannot trade, do not bother checking routes.
 	if (!Resources.GetTradableCodes().length)
@@ -443,21 +450,21 @@ PETRA.TradeManager.prototype.checkRoutes = function(gameState, accessIndex)
 	{
 		if (!m1.position())
 			continue;
-		let access1 = PETRA.getLandAccess(gameState, m1);
-		let sea1 = m1.hasClass("Naval") ? PETRA.getSeaAccess(gameState, m1) : undefined;
+		let access1 = DELPHI.getLandAccess(gameState, m1);
+		let sea1 = m1.hasClass("Naval") ? DELPHI.getSeaAccess(gameState, m1) : undefined;
 		for (let m2 of market2.values())
 		{
 			if (onlyOurs && m1.id() >= m2.id())
 				continue;
 			if (!m2.position())
 				continue;
-			let access2 = PETRA.getLandAccess(gameState, m2);
-			let sea2 = m2.hasClass("Naval") ? PETRA.getSeaAccess(gameState, m2) : undefined;
+			let access2 = DELPHI.getLandAccess(gameState, m2);
+			let sea2 = m2.hasClass("Naval") ? DELPHI.getSeaAccess(gameState, m2) : undefined;
 			let land = access1 == access2 ? access1 : undefined;
 			let sea = sea1 && sea1 == sea2 ? sea1 : undefined;
 			if (!land && !sea)
 				continue;
-			if (land && PETRA.isLineInsideEnemyTerritory(gameState, m1.position(), m2.position()))
+			if (land && DELPHI.isLineInsideEnemyTerritory(gameState, m1.position(), m2.position()))
 				continue;
 			let gainMultiplier;
 			if (land && traderTemplatesGains.landGainMultiplier)
@@ -531,7 +538,7 @@ PETRA.TradeManager.prototype.checkRoutes = function(gameState, accessIndex)
 			owner = this.tradeRoute.target.owner();
 		if (owner != PlayerID && !this.warnedAllies[owner])
 		{	// Warn an ally that we have a trade route with him
-			PETRA.chatNewTradeRoute(gameState, owner);
+			DELPHI.chatNewTradeRoute(gameState, owner);
 			this.warnedAllies[owner] = true;
 		}
 	}
@@ -548,7 +555,7 @@ PETRA.TradeManager.prototype.checkRoutes = function(gameState, accessIndex)
 };
 
 /** Called when a market was built or destroyed, and checks if trader orders should be changed */
-PETRA.TradeManager.prototype.checkTrader = function(gameState, ent)
+DELPHI.TradeManager.prototype.checkTrader = function(gameState, ent)
 {
 	let presentRoute = ent.getMetadata(PlayerID, "route");
 	if (!presentRoute)
@@ -561,7 +568,7 @@ PETRA.TradeManager.prototype.checkTrader = function(gameState, ent)
 		return;
 	}
 
-	let access = ent.hasClass("Ship") ? PETRA.getSeaAccess(gameState, ent) : PETRA.getLandAccess(gameState, ent);
+	let access = ent.hasClass("Ship") ? DELPHI.getSeaAccess(gameState, ent) : DELPHI.getLandAccess(gameState, ent);
 	let possibleRoute = this.checkRoutes(gameState, access);
 	// Warning:  presentRoute is from metadata, so contains entity ids
 	if (!possibleRoute ||
@@ -572,7 +579,7 @@ PETRA.TradeManager.prototype.checkTrader = function(gameState, ent)
 		ent.setMetadata(PlayerID, "route", undefined);
 		if (!possibleRoute && !ent.hasClass("Ship"))
 		{
-			let closestBase = PETRA.getBestBase(gameState, ent, true);
+			let closestBase = DELPHI.getBestBase(gameState, ent, true);
 			if (closestBase.accessIndex == access)
 			{
 				let closestBasePos = closestBase.anchor.position();
@@ -584,7 +591,7 @@ PETRA.TradeManager.prototype.checkTrader = function(gameState, ent)
 	}
 };
 
-PETRA.TradeManager.prototype.prospectForNewMarket = function(gameState, queues)
+DELPHI.TradeManager.prototype.prospectForNewMarket = function(gameState, queues)
 {
 	if (queues.economicBuilding.hasQueuedUnitsWithClass("Trade") || queues.dock.hasQueuedUnitsWithClass("Trade"))
 		return;
@@ -622,13 +629,13 @@ PETRA.TradeManager.prototype.prospectForNewMarket = function(gameState, queues)
 
 	if (!this.tradeRoute)
 		gameState.ai.queueManager.changePriority("economicBuilding", 2 * this.Config.priorities.economicBuilding);
-	let plan = new PETRA.ConstructionPlan(gameState, "structures/{civ}/market");
+	let plan = new DELPHI.ConstructionPlan(gameState, "structures/{civ}/market");
 	if (!this.tradeRoute)
 		plan.queueToReset = "economicBuilding";
 	queues.economicBuilding.addPlan(plan);
 };
 
-PETRA.TradeManager.prototype.isNewMarketWorth = function(expectedGain)
+DELPHI.TradeManager.prototype.isNewMarketWorth = function(expectedGain)
 {
 	if (!Resources.GetTradableCodes().length)
 		return false;
@@ -640,7 +647,7 @@ PETRA.TradeManager.prototype.isNewMarketWorth = function(expectedGain)
 	return true;
 };
 
-PETRA.TradeManager.prototype.update = function(gameState, events, queues)
+DELPHI.TradeManager.prototype.update = function(gameState, events, queues)
 {
 	if (gameState.ai.HQ.canBarter && Resources.GetBarterableCodes().length)
 		this.performBarter(gameState);
@@ -657,19 +664,16 @@ PETRA.TradeManager.prototype.update = function(gameState, events, queues)
 	if (this.tradeRoute)
 	{
 		this.traders.forEach(ent => { this.updateTrader(gameState, ent); });
-		if (gameState.ai.playedTurn % 5 == 0)
+		if (gameState.ai.playedTurn % 3 == 0)
 			this.trainMoreTraders(gameState, queues);
 		if (gameState.ai.playedTurn % 20 == 0 && this.traders.length >= 2)
 			gameState.ai.HQ.researchManager.researchTradeBonus(gameState, queues);
 		if (gameState.ai.playedTurn % 60 == 0)
 			this.setTradingGoods(gameState);
 	}
-
-	if (this.routeProspection)
-		this.prospectForNewMarket(gameState, queues);
 };
 
-PETRA.TradeManager.prototype.routeEntToId = function(route)
+DELPHI.TradeManager.prototype.routeEntToId = function(route)
 {
 	if (!route)
 		return undefined;
@@ -689,7 +693,7 @@ PETRA.TradeManager.prototype.routeEntToId = function(route)
 	return ret;
 };
 
-PETRA.TradeManager.prototype.routeIdToEnt = function(gameState, route)
+DELPHI.TradeManager.prototype.routeIdToEnt = function(gameState, route)
 {
 	if (!route)
 		return undefined;
@@ -709,18 +713,18 @@ PETRA.TradeManager.prototype.routeIdToEnt = function(gameState, route)
 	return ret;
 };
 
-PETRA.TradeManager.prototype.Serialize = function()
+DELPHI.TradeManager.prototype.Serialize = function()
 {
 	return {
 		"tradeRoute": this.routeEntToId(this.tradeRoute),
 		"potentialTradeRoute": this.routeEntToId(this.potentialTradeRoute),
 		"routeProspection": this.routeProspection,
-		"targetNumTraders": this.targetNumTraders,
+		"traderRatio": this.traderRatio,
 		"warnedAllies": this.warnedAllies
 	};
 };
 
-PETRA.TradeManager.prototype.Deserialize = function(gameState, data)
+DELPHI.TradeManager.prototype.Deserialize = function(gameState, data)
 {
 	for (let key in data)
 	{
diff --git a/binaries/data/mods/public/simulation/ai/delphi/transportPlan.js b/binaries/data/mods/public/simulation/ai/delphi/transportPlan.js
index 70f26881ca..9877aceacc 100644
--- a/binaries/data/mods/public/simulation/ai/delphi/transportPlan.js
+++ b/binaries/data/mods/public/simulation/ai/delphi/transportPlan.js
@@ -20,7 +20,7 @@
  *   transporter = this.ID
  */
 
-PETRA.TransportPlan = function(gameState, units, startIndex, endIndex, endPos, ship)
+DELPHI.TransportPlan = function(gameState, units, startIndex, endIndex, endPos, ship)
 {
 	this.ID = gameState.ai.uniqueIDs.transports++;
 	this.debug = gameState.ai.Config.debug;
@@ -74,7 +74,7 @@ PETRA.TransportPlan = function(gameState, units, startIndex, endIndex, endPos, s
 	return true;
 };
 
-PETRA.TransportPlan.prototype.init = function(gameState)
+DELPHI.TransportPlan.prototype.init = function(gameState)
 {
 	this.units = gameState.getOwnUnits().filter(API3.Filters.byMetadata(PlayerID, "transport", this.ID));
 	this.ships = gameState.ai.HQ.navalManager.ships.filter(API3.Filters.byMetadata(PlayerID, "transporter", this.ID));
@@ -88,7 +88,7 @@ PETRA.TransportPlan.prototype.init = function(gameState)
 };
 
 /** count available slots */
-PETRA.TransportPlan.prototype.countFreeSlots = function()
+DELPHI.TransportPlan.prototype.countFreeSlots = function()
 {
 	let slots = 0;
 	for (let ship of this.transportShips.values())
@@ -96,7 +96,7 @@ PETRA.TransportPlan.prototype.countFreeSlots = function()
 	return slots;
 };
 
-PETRA.TransportPlan.prototype.countFreeSlotsOnShip = function(ship)
+DELPHI.TransportPlan.prototype.countFreeSlotsOnShip = function(ship)
 {
 	if (ship.hitpoints() < ship.garrisonEjectHealth() * ship.maxHitpoints())
 		return 0;
@@ -105,7 +105,7 @@ PETRA.TransportPlan.prototype.countFreeSlotsOnShip = function(ship)
 	return Math.max(ship.garrisonMax() - occupied, 0);
 };
 
-PETRA.TransportPlan.prototype.assignUnitToShip = function(gameState, ent)
+DELPHI.TransportPlan.prototype.assignUnitToShip = function(gameState, ent)
 {
 	if (this.needTransportShips)
 		return;
@@ -137,7 +137,7 @@ PETRA.TransportPlan.prototype.assignUnitToShip = function(gameState, ent)
 		this.needSplit.push(ent);
 };
 
-PETRA.TransportPlan.prototype.assignShip = function(gameState)
+DELPHI.TransportPlan.prototype.assignShip = function(gameState)
 {
 	let pos;
 	// choose a unit of this plan not yet assigned to a ship
@@ -177,7 +177,7 @@ PETRA.TransportPlan.prototype.assignShip = function(gameState)
 };
 
 /** add a unit to this plan */
-PETRA.TransportPlan.prototype.addUnit = function(unit, endPos)
+DELPHI.TransportPlan.prototype.addUnit = function(unit, endPos)
 {
 	unit.setMetadata(PlayerID, "transport", this.ID);
 	unit.setMetadata(PlayerID, "endPos", endPos);
@@ -185,7 +185,7 @@ PETRA.TransportPlan.prototype.addUnit = function(unit, endPos)
 };
 
 /** remove a unit from this plan, if not yet on board */
-PETRA.TransportPlan.prototype.removeUnit = function(gameState, unit)
+DELPHI.TransportPlan.prototype.removeUnit = function(gameState, unit)
 {
 	let shipId = unit.getMetadata(PlayerID, "onBoard");
 	if (shipId == "onBoard")
@@ -209,11 +209,11 @@ PETRA.TransportPlan.prototype.removeUnit = function(gameState, unit)
 	}
 };
 
-PETRA.TransportPlan.prototype.releaseShip = function(ship)
+DELPHI.TransportPlan.prototype.releaseShip = function(ship)
 {
 	if (ship.getMetadata(PlayerID, "transporter") != this.ID)
 	{
-		API3.warn(" Petra: try removing a transporter ship with " + ship.getMetadata(PlayerID, "transporter") +
+		API3.warn(" Delphi: try removing a transporter ship with " + ship.getMetadata(PlayerID, "transporter") +
 		          " from " + this.ID + " and stance " + ship.getStance());
 		return;
 	}
@@ -227,7 +227,7 @@ PETRA.TransportPlan.prototype.releaseShip = function(ship)
 		ship.setMetadata(PlayerID, "role", "trader");
 };
 
-PETRA.TransportPlan.prototype.releaseAll = function()
+DELPHI.TransportPlan.prototype.releaseAll = function()
 {
 	for (let ship of this.ships.values())
 		this.releaseShip(ship);
@@ -247,7 +247,7 @@ PETRA.TransportPlan.prototype.releaseAll = function()
 };
 
 /** TODO not currently used ... to be fixed */
-PETRA.TransportPlan.prototype.cancelTransport = function(gameState)
+DELPHI.TransportPlan.prototype.cancelTransport = function(gameState)
 {
 	let ent = this.units.toEntityArray()[0];
 	let base = gameState.ai.HQ.getBaseByID(ent.getMetadata(PlayerID, "base"));
@@ -279,7 +279,7 @@ PETRA.TransportPlan.prototype.cancelTransport = function(gameState)
  * - then the plan is cleared
  */
 
-PETRA.TransportPlan.prototype.update = function(gameState)
+DELPHI.TransportPlan.prototype.update = function(gameState)
 {
 	if (this.state == "boarding")
 		this.onBoarding(gameState);
@@ -289,7 +289,7 @@ PETRA.TransportPlan.prototype.update = function(gameState)
 	return this.units.length;
 };
 
-PETRA.TransportPlan.prototype.onBoarding = function(gameState)
+DELPHI.TransportPlan.prototype.onBoarding = function(gameState)
 {
 	let ready = true;
 	let time = gameState.ai.elapsedTime;
@@ -429,7 +429,7 @@ PETRA.TransportPlan.prototype.onBoarding = function(gameState)
 };
 
 /** tell if a unit is garrisoned in one of the ships of this plan, and update its metadata if yes */
-PETRA.TransportPlan.prototype.isOnBoard = function(ent)
+DELPHI.TransportPlan.prototype.isOnBoard = function(ent)
 {
 	for (let ship of this.transportShips.values())
 	{
@@ -442,7 +442,7 @@ PETRA.TransportPlan.prototype.isOnBoard = function(ent)
 };
 
 /** when avoidEnnemy is true, we try to not board/unboard in ennemy territory */
-PETRA.TransportPlan.prototype.getBoardingPos = function(gameState, ship, landIndex, seaIndex, destination, avoidEnnemy)
+DELPHI.TransportPlan.prototype.getBoardingPos = function(gameState, ship, landIndex, seaIndex, destination, avoidEnnemy)
 {
 	if (!gameState.ai.HQ.navalManager.landingZones[landIndex])
 	{
@@ -505,7 +505,7 @@ PETRA.TransportPlan.prototype.getBoardingPos = function(gameState, ship, landInd
 	return posmin;
 };
 
-PETRA.TransportPlan.prototype.onSailing = function(gameState)
+DELPHI.TransportPlan.prototype.onSailing = function(gameState)
 {
 	// Check that the units recovered on the previous turn have been reloaded
 	for (let recov of this.recovered)
@@ -523,7 +523,7 @@ PETRA.TransportPlan.prototype.onSailing = function(gameState)
 		if (this.debug > 1)
 			API3.warn(">>> transport " + this.ID + " reloading failed ... <<<");
 		// destroy the unit if inaccessible otherwise leave it there
-		let index = PETRA.getLandAccess(gameState, ent);
+		let index = DELPHI.getLandAccess(gameState, ent);
 		if (gameState.ai.HQ.landRegions[index])
 		{
 			if (this.debug > 1)
@@ -559,19 +559,19 @@ PETRA.TransportPlan.prototype.onSailing = function(gameState)
 					ent.setMetadata(PlayerID, "onBoard", "onBoard");
 				else
 				{
-					API3.warn("Petra transportPlan problem: unit not on ship without position ???");
+					API3.warn("Delphi transportPlan problem: unit not on ship without position ???");
 					this.resetUnit(gameState, ent);
 					ent.destroy();
 				}
 			}
 			else
 			{
-				API3.warn("Petra transportPlan problem: unit on ship, but no ship ???");
+				API3.warn("Delphi transportPlan problem: unit on ship, but no ship ???");
 				this.resetUnit(gameState, ent);
 				ent.destroy();
 			}
 		}
-		else if (PETRA.getLandAccess(gameState, ent) != this.endIndex)
+		else if (DELPHI.getLandAccess(gameState, ent) != this.endIndex)
 		{
 			// unit unloaded on a wrong region - try to regarrison it and move a bit the ship
 			if (this.debug > 1)
@@ -675,7 +675,7 @@ PETRA.TransportPlan.prototype.onSailing = function(gameState)
 	}
 };
 
-PETRA.TransportPlan.prototype.resetUnit = function(gameState, ent)
+DELPHI.TransportPlan.prototype.resetUnit = function(gameState, ent)
 {
 	ent.setMetadata(PlayerID, "transport", undefined);
 	ent.setMetadata(PlayerID, "onBoard", undefined);
@@ -695,7 +695,7 @@ PETRA.TransportPlan.prototype.resetUnit = function(gameState, ent)
 	}
 };
 
-PETRA.TransportPlan.prototype.Serialize = function()
+DELPHI.TransportPlan.prototype.Serialize = function()
 {
 	return {
 		"ID": this.ID,
@@ -714,7 +714,7 @@ PETRA.TransportPlan.prototype.Serialize = function()
 	};
 };
 
-PETRA.TransportPlan.prototype.Deserialize = function(data)
+DELPHI.TransportPlan.prototype.Deserialize = function(data)
 {
 	for (let key in data)
 		this[key] = data[key];
diff --git a/binaries/data/mods/public/simulation/ai/delphi/victoryManager.js b/binaries/data/mods/public/simulation/ai/delphi/victoryManager.js
index 13f8181cff..e02acbd334 100644
--- a/binaries/data/mods/public/simulation/ai/delphi/victoryManager.js
+++ b/binaries/data/mods/public/simulation/ai/delphi/victoryManager.js
@@ -5,7 +5,7 @@
  *   in wonder, train military guards.
  */
 
-PETRA.VictoryManager = function(Config)
+DELPHI.VictoryManager = function(Config)
 {
 	this.Config = Config;
 	this.criticalEnts = new Map();
@@ -21,7 +21,7 @@ PETRA.VictoryManager = function(Config)
 /**
  * Cache the ids of any inital victory-critical entities.
  */
-PETRA.VictoryManager.prototype.init = function(gameState)
+DELPHI.VictoryManager.prototype.init = function(gameState)
 {
 	if (gameState.getVictoryConditions().has("wonder"))
 	{
@@ -60,7 +60,7 @@ PETRA.VictoryManager.prototype.init = function(gameState)
  * If it is less than 40%, try to garrison in the closest possible structure
  * If the hero cannot garrison, retreat it to the closest base
  */
-PETRA.VictoryManager.prototype.checkEvents = function(gameState, events)
+DELPHI.VictoryManager.prototype.checkEvents = function(gameState, events)
 {
 	if (gameState.getVictoryConditions().has("wonder"))
 	{
@@ -304,7 +304,7 @@ PETRA.VictoryManager.prototype.checkEvents = function(gameState, events)
 	}
 };
 
-PETRA.VictoryManager.prototype.removeCriticalEnt = function(gameState, criticalEntId)
+DELPHI.VictoryManager.prototype.removeCriticalEnt = function(gameState, criticalEntId)
 {
 	for (let [guardId, role] of this.criticalEnts.get(criticalEntId).guards)
 	{
@@ -330,7 +330,7 @@ PETRA.VictoryManager.prototype.removeCriticalEnt = function(gameState, criticalE
 /**
  * Train more healers to be later affected to critical entities if needed
  */
-PETRA.VictoryManager.prototype.manageCriticalEntHealers = function(gameState, queues)
+DELPHI.VictoryManager.prototype.manageCriticalEntHealers = function(gameState, queues)
 {
 	if (gameState.ai.HQ.saveResources || queues.healer.hasQueuedUnits() ||
 	    !gameState.getOwnEntitiesByClass("Temple", true).hasEntities() ||
@@ -342,7 +342,7 @@ PETRA.VictoryManager.prototype.manageCriticalEntHealers = function(gameState, qu
 		if (data.healersAssigned === undefined || data.healersAssigned >= this.healersPerCriticalEnt)
 			continue;
 		let template = gameState.applyCiv("units/{civ}/support_healer_b");
-		queues.healer.addPlan(new PETRA.TrainingPlan(gameState, template, { "role": "criticalEntHealer", "base": 0 }, 1, 1));
+		queues.healer.addPlan(new DELPHI.TrainingPlan(gameState, template, { "role": "criticalEntHealer", "base": 0 }, 1, 1));
 		return;
 	}
 };
@@ -352,7 +352,7 @@ PETRA.VictoryManager.prototype.manageCriticalEntHealers = function(gameState, qu
  * If we have too low a population and require units for other needs, remove guards so they can be reassigned.
  * TODO: Swap citizen soldier guards with champions if they become available.
  */
-PETRA.VictoryManager.prototype.manageCriticalEntGuards = function(gameState)
+DELPHI.VictoryManager.prototype.manageCriticalEntGuards = function(gameState)
 {
 	let numWorkers = gameState.getOwnEntitiesByRole("worker", true).length;
 	if (numWorkers < 20)
@@ -439,12 +439,12 @@ PETRA.VictoryManager.prototype.manageCriticalEntGuards = function(gameState)
 	}
 };
 
-PETRA.VictoryManager.prototype.tryAssignMilitaryGuard = function(gameState, guardEnt, criticalEnt, checkForSameAccess)
+DELPHI.VictoryManager.prototype.tryAssignMilitaryGuard = function(gameState, guardEnt, criticalEnt, checkForSameAccess)
 {
 	if (guardEnt.getMetadata(PlayerID, "plan") !== undefined ||
 	    guardEnt.getMetadata(PlayerID, "transport") !== undefined || this.criticalEnts.has(guardEnt.id()) ||
 	    checkForSameAccess && (!guardEnt.position() || !criticalEnt.position() ||
-	    PETRA.getLandAccess(gameState, criticalEnt) != PETRA.getLandAccess(gameState, guardEnt)))
+	    DELPHI.getLandAccess(gameState, criticalEnt) != DELPHI.getLandAccess(gameState, guardEnt)))
 		return false;
 
 	if (!this.assignGuardToCriticalEnt(gameState, guardEnt, criticalEnt.id()))
@@ -455,7 +455,7 @@ PETRA.VictoryManager.prototype.tryAssignMilitaryGuard = function(gameState, guar
 	return true;
 };
 
-PETRA.VictoryManager.prototype.pickCriticalEntRetreatLocation = function(gameState, criticalEnt, emergency)
+DELPHI.VictoryManager.prototype.pickCriticalEntRetreatLocation = function(gameState, criticalEnt, emergency)
 {
 	gameState.ai.HQ.defenseManager.garrisonAttackedUnit(gameState, criticalEnt, emergency);
 	let plan = criticalEnt.getMetadata(PlayerID, "plan");
@@ -469,8 +469,8 @@ PETRA.VictoryManager.prototype.pickCriticalEntRetreatLocation = function(gameSta
 	// Couldn't find a place to garrison, so the ent will flee from attacks
 	if (!criticalEnt.hasClass("Relic") && criticalEnt.getStance() != "passive")
 		criticalEnt.setStance("passive");
-	let accessIndex = PETRA.getLandAccess(gameState, criticalEnt);
-	let bestBase = PETRA.getBestBase(gameState, criticalEnt, true);
+	let accessIndex = DELPHI.getLandAccess(gameState, criticalEnt);
+	let bestBase = DELPHI.getBestBase(gameState, criticalEnt, true);
 	if (bestBase.accessIndex == accessIndex)
 	{
 		let bestBasePos = bestBase.anchor.position();
@@ -486,7 +486,7 @@ PETRA.VictoryManager.prototype.pickCriticalEntRetreatLocation = function(gameSta
  * which will be used once its transport has finished.
  * Return false if the guardEnt is not a valid guard unit (i.e. cannot guard or is being transported).
  */
-PETRA.VictoryManager.prototype.assignGuardToCriticalEnt = function(gameState, guardEnt, criticalEntId)
+DELPHI.VictoryManager.prototype.assignGuardToCriticalEnt = function(gameState, guardEnt, criticalEntId)
 {
 	if (guardEnt.getMetadata(PlayerID, "transport") !== undefined || !guardEnt.canGuard())
 		return false;
@@ -541,11 +541,11 @@ PETRA.VictoryManager.prototype.assignGuardToCriticalEnt = function(gameState, gu
 	if (guardEnt.getMetadata(PlayerID, "guardedEnt") != criticalEntId)
 		guardEnt.setMetadata(PlayerID, "guardedEnt", criticalEntId);
 
-	let guardEntAccess = PETRA.getLandAccess(gameState, guardEnt);
-	let criticalEntAccess = PETRA.getLandAccess(gameState, criticalEnt);
+	let guardEntAccess = DELPHI.getLandAccess(gameState, guardEnt);
+	let criticalEntAccess = DELPHI.getLandAccess(gameState, criticalEnt);
 	if (guardEntAccess == criticalEntAccess)
 	{
-		let queued = PETRA.returnResources(gameState, guardEnt);
+		let queued = DELPHI.returnResources(gameState, guardEnt);
 		guardEnt.guard(criticalEnt, queued);
 		let guardRole = guardEnt.getMetadata(PlayerID, "role") == "criticalEntHealer" ? "healer" : "guard";
 		this.criticalEnts.get(criticalEntId).guards.set(guardEnt.id(), guardRole);
@@ -561,14 +561,14 @@ PETRA.VictoryManager.prototype.assignGuardToCriticalEnt = function(gameState, gu
 	return true;
 };
 
-PETRA.VictoryManager.prototype.resetCaptureGaiaRelic = function(gameState)
+DELPHI.VictoryManager.prototype.resetCaptureGaiaRelic = function(gameState)
 {
 	// Do not capture gaia relics too frequently as the ai has access to the entire map
 	this.tryCaptureGaiaRelicLapseTime = gameState.ai.elapsedTime + 240 - 30 * (this.Config.difficulty - 3);
 	this.tryCaptureGaiaRelic = false;
 };
 
-PETRA.VictoryManager.prototype.update = function(gameState, events, queues)
+DELPHI.VictoryManager.prototype.update = function(gameState, events, queues)
 {
 	// Wait a turn for trigger scripts to spawn any critical ents (i.e. in regicide)
 	if (gameState.ai.playedTurn == 1)
@@ -648,7 +648,7 @@ PETRA.VictoryManager.prototype.update = function(gameState, events, queues)
 /**
  * Send an expedition to capture a gaia relic, or reinforce an existing one.
  */
-PETRA.VictoryManager.prototype.captureGaiaRelic = function(gameState, relic)
+DELPHI.VictoryManager.prototype.captureGaiaRelic = function(gameState, relic)
 {
 	let capture = -relic.defaultRegenRate();
 	let sumCapturePoints = relic.capturePoints().reduce((a, b) => a + b);
@@ -659,13 +659,13 @@ PETRA.VictoryManager.prototype.captureGaiaRelic = function(gameState, relic)
 		if (!attack)
 			continue;
 		for (let ent of attack.unitCollection.values())
-			capture += ent.captureStrength() * PETRA.getAttackBonus(ent, relic, "Capture");
+			capture += ent.captureStrength() * DELPHI.getAttackBonus(ent, relic, "Capture");
 	}
 	// No need to make a new attack if already enough units
 	if (capture > sumCapturePoints / 50)
 		return;
 	let relicPosition = relic.position();
-	let access = PETRA.getLandAccess(gameState, relic);
+	let access = DELPHI.getLandAccess(gameState, relic);
 	let units = gameState.getOwnUnits().filter(ent => {
 		if (!ent.position() || !ent.canCapture(relic))
 			return false;
@@ -682,14 +682,14 @@ PETRA.VictoryManager.prototype.captureGaiaRelic = function(gameState, relic)
 			if (attack && (attack.state != "unexecuted" || attack.type == "Raid"))
 				return false;
 		}
-		if (PETRA.getLandAccess(gameState, ent) != access)
+		if (DELPHI.getLandAccess(gameState, ent) != access)
 			return false;
 		return true;
 	}).filterNearest(relicPosition);
 	let expedition = [];
 	for (let ent of units.values())
 	{
-		capture += ent.captureStrength() * PETRA.getAttackBonus(ent, relic, "Capture");
+		capture += ent.captureStrength() * DELPHI.getAttackBonus(ent, relic, "Capture");
 		expedition.push(ent);
 		if (capture > sumCapturePoints / 25)
 			break;
@@ -712,7 +712,7 @@ PETRA.VictoryManager.prototype.captureGaiaRelic = function(gameState, relic)
 	this.targetedGaiaRelics.get(relic.id()).push(plan);
 };
 
-PETRA.VictoryManager.prototype.abortCaptureGaiaRelic = function(gameState, relicId)
+DELPHI.VictoryManager.prototype.abortCaptureGaiaRelic = function(gameState, relicId)
 {
 	for (let plan of this.targetedGaiaRelics.get(relicId))
 	{
@@ -723,7 +723,7 @@ PETRA.VictoryManager.prototype.abortCaptureGaiaRelic = function(gameState, relic
 	this.targetedGaiaRelics.delete(relicId);
 };
 
-PETRA.VictoryManager.prototype.Serialize = function()
+DELPHI.VictoryManager.prototype.Serialize = function()
 {
 	return {
 		"criticalEnts": this.criticalEnts,
@@ -735,7 +735,7 @@ PETRA.VictoryManager.prototype.Serialize = function()
 	};
 };
 
-PETRA.VictoryManager.prototype.Deserialize = function(data)
+DELPHI.VictoryManager.prototype.Deserialize = function(data)
 {
 	for (let key in data)
 		this[key] = data[key];
diff --git a/binaries/data/mods/public/simulation/ai/delphi/worker.js b/binaries/data/mods/public/simulation/ai/delphi/worker.js
index 507e6ccaa1..e7a3cdcc78 100644
--- a/binaries/data/mods/public/simulation/ai/delphi/worker.js
+++ b/binaries/data/mods/public/simulation/ai/delphi/worker.js
@@ -1,14 +1,14 @@
 /**
  * This class makes a worker do as instructed by the economy manager
  */
-PETRA.Worker = function(base)
+DELPHI.Worker = function(base)
 {
 	this.ent = undefined;
 	this.base = base;
 	this.baseID = base.ID;
 };
 
-PETRA.Worker.prototype.update = function(gameState, ent)
+DELPHI.Worker.prototype.update = function(gameState, ent)
 {
 	if (!ent.position() || ent.getMetadata(PlayerID, "plan") == -2 || ent.getMetadata(PlayerID, "plan") == -3)
 		return;
@@ -36,9 +36,9 @@ PETRA.Worker.prototype.update = function(gameState, ent)
 				let gatherType = ent.getMetadata(PlayerID, "gather-type") || "food";
 				for (let structure of gameState.getOwnStructures().values())
 				{
-					if (PETRA.getLandAccess(gameState, structure) != plan.endIndex)
+					if (DELPHI.getLandAccess(gameState, structure) != plan.endIndex)
 						continue;
-					let resourceDropsiteTypes = PETRA.getBuiltEntity(gameState, structure).resourceDropsiteTypes();
+					let resourceDropsiteTypes = DELPHI.getBuiltEntity(gameState, structure).resourceDropsiteTypes();
 					if (!resourceDropsiteTypes || resourceDropsiteTypes.indexOf(gatherType) == -1)
 						continue;
 					hasDropsite = true;
@@ -48,7 +48,7 @@ PETRA.Worker.prototype.update = function(gameState, ent)
 				{
 					for (let unit of gameState.getOwnUnits().filter(API3.Filters.byClass("Support")).values())
 					{
-						if (!unit.position() || PETRA.getLandAccess(gameState, unit) != plan.endIndex)
+						if (!unit.position() || DELPHI.getLandAccess(gameState, unit) != plan.endIndex)
 							continue;
 						let resourceDropsiteTypes = unit.resourceDropsiteTypes();
 						if (!resourceDropsiteTypes || resourceDropsiteTypes.indexOf(gatherType) == -1)
@@ -65,7 +65,7 @@ PETRA.Worker.prototype.update = function(gameState, ent)
 			return;
 	}
 
-	this.entAccess = PETRA.getLandAccess(gameState, ent);
+	this.entAccess = DELPHI.getLandAccess(gameState, ent);
 	// base 0 for unassigned entities has no accessIndex, so take the one from the entity
 	if (this.baseID == gameState.ai.HQ.baseManagers[0].ID)
 		this.baseAccess = this.entAccess;
@@ -112,8 +112,8 @@ PETRA.Worker.prototype.update = function(gameState, ent)
 					}
 					else if (!gameState.isPlayerAlly(territoryOwner))
 					{
-						let distanceSquare = PETRA.isFastMoving(ent) ? 90000 : 30000;
-						let targetAccess = PETRA.getLandAccess(gameState, target);
+						let distanceSquare = DELPHI.isFastMoving(ent) ? 90000 : 30000;
+						let targetAccess = DELPHI.getLandAccess(gameState, target);
 						let foodDropsites = gameState.playerData.hasSharedDropsites ?
 						                    gameState.getAnyDropsites("food") : gameState.getOwnDropsites("food");
 						let hasFoodDropsiteWithinDistance = false;
@@ -125,7 +125,7 @@ PETRA.Worker.prototype.update = function(gameState, ent)
 							// owner != PlayerID can only happen when hasSharedDropsites == true, so no need to test it again
 							if (owner != PlayerID && (!dropsite.isSharedDropsite() || !gameState.isPlayerMutualAlly(owner)))
 								continue;
-							if (targetAccess != PETRA.getLandAccess(gameState, dropsite))
+							if (targetAccess != DELPHI.getLandAccess(gameState, dropsite))
 								continue;
 							if (API3.SquareVectorDistance(target.position(), dropsite.position()) < distanceSquare)
 							{
@@ -165,7 +165,7 @@ PETRA.Worker.prototype.update = function(gameState, ent)
 			if (orderData && orderData.target)
 			{
 				let target = gameState.getEntityById(orderData.target);
-				if (target && (!target.position() || PETRA.getLandAccess(gameState, target) != this.entAccess))
+				if (target && (!target.position() || DELPHI.getLandAccess(gameState, target) != this.entAccess))
 				{
 					if (this.retryWorking(gameState, subrole))
 						return;
@@ -183,7 +183,7 @@ PETRA.Worker.prototype.update = function(gameState, ent)
 				// and UnitAI sent it fight back with allowCapture=true
 				let target = gameState.getEntityById(orderData.target);
 				if (target && target.owner() > 0 && !gameState.isPlayerAlly(target.owner()))
-					ent.attack(orderData.target, PETRA.allowCapture(gameState, ent, target));
+					ent.attack(orderData.target, DELPHI.allowCapture(gameState, ent, target));
 			}
 		}
 		return;
@@ -205,7 +205,7 @@ PETRA.Worker.prototype.update = function(gameState, ent)
 			{
 				this.startGathering(gameState);
 			}
-			else if (!PETRA.returnResources(gameState, ent))     // try to deposit resources
+			else if (!DELPHI.returnResources(gameState, ent))     // try to deposit resources
 			{
 				// no dropsite, abandon old resources and start gathering new ones
 				this.startGathering(gameState);
@@ -259,8 +259,8 @@ PETRA.Worker.prototype.update = function(gameState, ent)
 				{
 					// Check from time to time that UnitAI does not send us to an inaccessible dropsite
 					let dropsite = gameState.getEntityById(ent.unitAIOrderData()[0].target);
-					if (dropsite && dropsite.position() && this.entAccess != PETRA.getLandAccess(gameState, dropsite))
-						PETRA.returnResources(gameState, this.ent);
+					if (dropsite && dropsite.position() && this.entAccess != DELPHI.getLandAccess(gameState, dropsite))
+						DELPHI.returnResources(gameState, this.ent);
 				}
 
 				// If gathering a sparse resource, we may have been sent to a faraway resource if the one nearby was full.
@@ -340,8 +340,8 @@ PETRA.Worker.prototype.update = function(gameState, ent)
 		}
 		else
 		{
-			let goalAccess = PETRA.getLandAccess(gameState, target);
-			let queued = PETRA.returnResources(gameState, ent);
+			let goalAccess = DELPHI.getLandAccess(gameState, target);
+			let queued = DELPHI.returnResources(gameState, ent);
 			if (this.entAccess == goalAccess)
 				ent.repair(target, target.hasClass("House"), queued);  // autocontinue=true for houses
 			else
@@ -389,8 +389,8 @@ PETRA.Worker.prototype.update = function(gameState, ent)
 				{
 					// Check that UnitAI does not send us to an inaccessible dropsite
 					let dropsite = gameState.getEntityById(ent.unitAIOrderData()[0].target);
-					if (dropsite && dropsite.position() && this.entAccess != PETRA.getLandAccess(gameState, dropsite))
-						PETRA.returnResources(gameState, ent);
+					if (dropsite && dropsite.position() && this.entAccess != DELPHI.getLandAccess(gameState, dropsite))
+						DELPHI.returnResources(gameState, ent);
 				}
 			}
 		}
@@ -408,7 +408,7 @@ PETRA.Worker.prototype.update = function(gameState, ent)
 	}
 };
 
-PETRA.Worker.prototype.retryWorking = function(gameState, subrole)
+DELPHI.Worker.prototype.retryWorking = function(gameState, subrole)
 {
 	switch (subrole)
 	{
@@ -425,21 +425,21 @@ PETRA.Worker.prototype.retryWorking = function(gameState, subrole)
 	}
 };
 
-PETRA.Worker.prototype.startBuilding = function(gameState)
+DELPHI.Worker.prototype.startBuilding = function(gameState)
 {
 	let target = gameState.getEntityById(this.ent.getMetadata(PlayerID, "target-foundation"));
 	if (!target || target.foundationProgress() === undefined && target.needsRepair() == false)
 		return false;
-	if (PETRA.getLandAccess(gameState, target) != this.entAccess)
+	if (DELPHI.getLandAccess(gameState, target) != this.entAccess)
 		return false;
 	this.ent.repair(target, target.hasClass("House"));  // autocontinue=true for houses
 	return true;
 };
 
-PETRA.Worker.prototype.startGathering = function(gameState)
+DELPHI.Worker.prototype.startGathering = function(gameState)
 {
 	// First look for possible treasure if any
-	if (PETRA.gatherTreasure(gameState, this.ent))
+	if (DELPHI.gatherTreasure(gameState, this.ent))
 		return true;
 
 	let resource = this.ent.getMetadata(PlayerID, "gather-type");
@@ -459,7 +459,7 @@ PETRA.Worker.prototype.startGathering = function(gameState)
 				supplies.splice(i--, 1);
 				continue;
 			}
-			if (PETRA.IsSupplyFull(gameState, supplies[i].ent))
+			if (DELPHI.IsSupplyFull(gameState, supplies[i].ent))
 				continue;
 			let inaccessibleTime = supplies[i].ent.getMetadata(PlayerID, "inaccessibleTime");
 			if (inaccessibleTime && gameState.ai.elapsedTime < inaccessibleTime)
@@ -578,7 +578,7 @@ PETRA.Worker.prototype.startGathering = function(gameState)
 	// Try to help building one if any accessible foundation available
 	let foundations = gameState.getOwnFoundations().toEntityArray();
 	let shouldBuild = this.ent.isBuilder() && foundations.some(function(foundation) {
-		if (!foundation || PETRA.getLandAccess(gameState, foundation) != this.entAccess)
+		if (!foundation || DELPHI.getLandAccess(gameState, foundation) != this.entAccess)
 			return false;
 		let structure = gameState.getBuiltTemplate(foundation.templateName());
 		if (structure.resourceDropsiteTypes() && structure.resourceDropsiteTypes().indexOf(resource) != -1)
@@ -645,12 +645,12 @@ PETRA.Worker.prototype.startGathering = function(gameState)
 	// Okay so we haven't found any appropriate dropsite anywhere.
 	// Try to help building one if any non-accessible foundation available
 	shouldBuild = this.ent.isBuilder() && foundations.some(function(foundation) {
-		if (!foundation || PETRA.getLandAccess(gameState, foundation) == this.entAccess)
+		if (!foundation || DELPHI.getLandAccess(gameState, foundation) == this.entAccess)
 			return false;
 		let structure = gameState.getBuiltTemplate(foundation.templateName());
 		if (structure.resourceDropsiteTypes() && structure.resourceDropsiteTypes().indexOf(resource) != -1)
 		{
-			let foundationAccess = PETRA.getLandAccess(gameState, foundation);
+			let foundationAccess = DELPHI.getLandAccess(gameState, foundation);
 			if (navalManager.requireTransport(gameState, this.ent, this.entAccess, foundationAccess, foundation.position()))
 			{
 				if (foundation.getMetadata(PlayerID, "base") != this.baseID)
@@ -727,10 +727,10 @@ PETRA.Worker.prototype.startGathering = function(gameState)
  * if position is given, we only check if we could hunt from this position but do nothing
  * otherwise the position of the entity is taken, and if something is found, we directly start the hunt
  */
-PETRA.Worker.prototype.startHunting = function(gameState, position)
+DELPHI.Worker.prototype.startHunting = function(gameState, position)
 {
 	// First look for possible treasure if any
-	if (!position && PETRA.gatherTreasure(gameState, this.ent))
+	if (!position && DELPHI.gatherTreasure(gameState, this.ent))
 		return true;
 
 	let resources = gameState.getHuntableSupplies();
@@ -740,7 +740,7 @@ PETRA.Worker.prototype.startHunting = function(gameState, position)
 	let nearestSupplyDist = Math.min();
 	let nearestSupply;
 
-	let isFastMoving = PETRA.isFastMoving(this.ent);
+	let isFastMoving = DELPHI.isFastMoving(this.ent);
 	let isRanged = this.ent.hasClass("Ranged");
 	let entPosition = position ? position : this.ent.position();
 	let foodDropsites = gameState.playerData.hasSharedDropsites ?
@@ -756,7 +756,7 @@ PETRA.Worker.prototype.startHunting = function(gameState, position)
 			// owner != PlayerID can only happen when hasSharedDropsites == true, so no need to test it again
 			if (owner != PlayerID && (!dropsite.isSharedDropsite() || !gameState.isPlayerMutualAlly(owner)))
 				continue;
-			if (supplyAccess != PETRA.getLandAccess(gameState, dropsite))
+			if (supplyAccess != DELPHI.getLandAccess(gameState, dropsite))
 				continue;
 			if (API3.SquareVectorDistance(supplyPosition, dropsite.position()) < distSquare)
 				return true;
@@ -778,7 +778,7 @@ PETRA.Worker.prototype.startHunting = function(gameState, position)
 		if (!gatherRates[supplyType])
 			continue;
 
-		if (PETRA.IsSupplyFull(gameState, supply))
+		if (DELPHI.IsSupplyFull(gameState, supply))
 			continue;
 		// Check if available resource is worth one additionnal gatherer (except for farms).
 		let nbGatherers = supply.resourceSupplyNumGatherers() + gameState.ai.HQ.GetTCGatherer(supply.id());
@@ -790,7 +790,7 @@ PETRA.Worker.prototype.startHunting = function(gameState, position)
 		if (canFlee && !isFastMoving && !isRanged)
 			continue;
 
-		let supplyAccess = PETRA.getLandAccess(gameState, supply);
+		let supplyAccess = DELPHI.getLandAccess(gameState, supply);
 		if (supplyAccess != this.entAccess)
 			continue;
 
@@ -835,7 +835,7 @@ PETRA.Worker.prototype.startHunting = function(gameState, position)
 	return false;
 };
 
-PETRA.Worker.prototype.startFishing = function(gameState)
+DELPHI.Worker.prototype.startFishing = function(gameState)
 {
 	if (!this.ent.position())
 		return false;
@@ -851,7 +851,7 @@ PETRA.Worker.prototype.startFishing = function(gameState)
 	let nearestSupplyDist = Math.min();
 	let nearestSupply;
 
-	let fisherSea = PETRA.getSeaAccess(gameState, this.ent);
+	let fisherSea = DELPHI.getSeaAccess(gameState, this.ent);
 	let fishDropsites = (gameState.playerData.hasSharedDropsites ? gameState.getAnyDropsites("food") : gameState.getOwnDropsites("food")).
 	                    filter(API3.Filters.byClass("Dock")).toEntityArray();
 
@@ -866,7 +866,7 @@ PETRA.Worker.prototype.startFishing = function(gameState)
 			// owner != PlayerID can only happen when hasSharedDropsites == true, so no need to test it again
 			if (owner != PlayerID && (!dropsite.isSharedDropsite() || !gameState.isPlayerMutualAlly(owner)))
 				continue;
-			if (fisherSea != PETRA.getSeaAccess(gameState, dropsite))
+			if (fisherSea != DELPHI.getSeaAccess(gameState, dropsite))
 				continue;
 			distMin = Math.min(distMin, API3.SquareVectorDistance(pos, dropsite.position()));
 		}
@@ -890,7 +890,7 @@ PETRA.Worker.prototype.startFishing = function(gameState)
 		if (!gatherRates[supplyType])
 			return;
 
-		if (PETRA.IsSupplyFull(gameState, supply))
+		if (DELPHI.IsSupplyFull(gameState, supply))
 			return;
 		// check if available resource is worth one additionnal gatherer (except for farms)
 		let nbGatherers = supply.resourceSupplyNumGatherers() + gameState.ai.HQ.GetTCGatherer(supply.id());
@@ -930,7 +930,7 @@ PETRA.Worker.prototype.startFishing = function(gameState)
 	return false;
 };
 
-PETRA.Worker.prototype.gatherNearestField = function(gameState, baseID)
+DELPHI.Worker.prototype.gatherNearestField = function(gameState, baseID)
 {
 	let ownFields = gameState.getOwnEntitiesByClass("Field", true).filter(API3.Filters.isBuilt()).filter(API3.Filters.byMetadata(PlayerID, "base", baseID));
 	let bestFarm;
@@ -938,7 +938,7 @@ PETRA.Worker.prototype.gatherNearestField = function(gameState, baseID)
 	let gatherRates = this.ent.resourceGatherRates();
 	for (let field of ownFields.values())
 	{
-		if (PETRA.IsSupplyFull(gameState, field))
+		if (DELPHI.IsSupplyFull(gameState, field))
 			continue;
 		let supplyType = field.get("ResourceSupply/Type");
 		if (!gatherRates[supplyType])
@@ -970,7 +970,7 @@ PETRA.Worker.prototype.gatherNearestField = function(gameState, baseID)
  * WARNING with the present options of AI orders, the unit will not gather after building the farm.
  * This is done by calling the gatherNearestField function when construction is completed.
  */
-PETRA.Worker.prototype.buildAnyField = function(gameState, baseID)
+DELPHI.Worker.prototype.buildAnyField = function(gameState, baseID)
 {
 	if (!this.ent.isBuilder())
 		return false;
@@ -999,7 +999,7 @@ PETRA.Worker.prototype.buildAnyField = function(gameState, baseID)
  * For the time being, we move towards the nearest gatherer (providing him a dropsite).
  * BaseManager does also use that function to deal with its mobile dropsites.
  */
-PETRA.Worker.prototype.moveToGatherer = function(gameState, ent, forced)
+DELPHI.Worker.prototype.moveToGatherer = function(gameState, ent, forced)
 {
 	let pos = ent.position();
 	if (!pos || ent.getMetadata(PlayerID, "target-foundation") !== undefined)
@@ -1009,7 +1009,7 @@ PETRA.Worker.prototype.moveToGatherer = function(gameState, ent, forced)
 	let gatherers = this.base.workersBySubrole(gameState, "gatherer");
 	let dist = Math.min();
 	let destination;
-	let access = PETRA.getLandAccess(gameState, ent);
+	let access = DELPHI.getLandAccess(gameState, ent);
 	let types = ent.resourceDropsiteTypes();
 	for (let gatherer of gatherers.values())
 	{
@@ -1017,7 +1017,7 @@ PETRA.Worker.prototype.moveToGatherer = function(gameState, ent, forced)
 		if (!gathererType || types.indexOf(gathererType) == -1)
 			continue;
 		if (!gatherer.position() || gatherer.getMetadata(PlayerID, "transport") !== undefined ||
-		    PETRA.getLandAccess(gameState, gatherer) != access || gatherer.isIdle())
+		    DELPHI.getLandAccess(gameState, gatherer) != access || gatherer.isIdle())
 			continue;
 		let distance = API3.SquareVectorDistance(pos, gatherer.position());
 		if (distance > dist)
@@ -1035,7 +1035,7 @@ PETRA.Worker.prototype.moveToGatherer = function(gameState, ent, forced)
  * inside obstruction of other entities). The resource will be flagged as inaccessible during 10 mn (in case
  * it will be cleared later).
  */
-PETRA.Worker.prototype.isInaccessibleSupply = function(gameState)
+DELPHI.Worker.prototype.isInaccessibleSupply = function(gameState)
 {
 	if (!this.ent.unitAIOrderData()[0] || !this.ent.unitAIOrderData()[0].target)
 		return false;
-- 
2.25.1

