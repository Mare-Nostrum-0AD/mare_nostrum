From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: hopeless-ponderer <hopelessponderer1123@gmail.com>
Date: Sat, 31 Jul 2021 18:40:43 -0700
Subject: [PATCH] created A* pathfinder in simulation/ai/common-api/utils.js

makes use of PriorityQueue.js and NDimensionalSet.js in globalscripts/

Delphi trade manager uses pathfinder when a trade route has enemy territory in the middle

improved performance of Delphi:headquarters.js:getShorePlacementMap

fixed simulation/ai/common-api/entitycollection.js:getCentrePosition to use garrison holder's position when an entity is garrisoned (fixes bug in attackPlan.js where a central position for attackers could not be found)
---
 .../public/globalscripts/NDimensionalSet.js   |  69 ++++++++++++
 .../public/globalscripts/PriorityQueue.js     |  53 +++++++++
 .../data/mods/public/globalscripts/utility.js |  10 ++
 .../public/simulation/ai/common-api/entity.js |   4 +-
 .../ai/common-api/entitycollection.js         |  17 ++-
 .../public/simulation/ai/common-api/utils.js  |  54 ++++++++++
 .../public/simulation/ai/delphi/attackPlan.js |   4 +-
 .../simulation/ai/delphi/headquarters.js      | 101 +++++++++---------
 .../public/simulation/ai/delphi/mapModule.js  |   2 +-
 .../simulation/ai/delphi/tradeManager.js      |  67 ++++++++++--
 10 files changed, 315 insertions(+), 66 deletions(-)
 create mode 100644 binaries/data/mods/public/globalscripts/NDimensionalSet.js
 create mode 100644 binaries/data/mods/public/globalscripts/PriorityQueue.js

diff --git a/binaries/data/mods/public/globalscripts/NDimensionalSet.js b/binaries/data/mods/public/globalscripts/NDimensionalSet.js
new file mode 100644
index 0000000000..f6bfe8b562
--- /dev/null
+++ b/binaries/data/mods/public/globalscripts/NDimensionalSet.js
@@ -0,0 +1,69 @@
+// creates a set that checks for inclusion of values determined by N comparable keys
+
+// @param size			Integer			number N comparable keys to use
+// @param initEntires	[[Comparable]]	initial comparable values to enter
+function NSet(depth, initEntries) {
+	if (depth < 1)
+		throw new Error(sprintf("Depth must be greater than or equal to 1 (got %d)", depth));
+	this.depth = depth;
+	this.values = {};
+	this.size = 0;
+	if (!initEntries)
+		return;
+	for (const entry of initEntries)
+		this.add(...entry);
+}
+
+NSet.prototype.add = function(...values)
+{
+	if (!values || values.length !== this.depth)
+		throw new Error(sprintf("Expected %d values; got %d", this.depth, values ? values.length : 0));
+	if (this.depth === 1)
+		this.values[values[0]] = true;
+	else if (this.values[values[0]])
+		this.values[values[0]].add(values.slice(1));
+	else
+		this.values[values[0]] = new NSet(this.depth - 1, [values.slice(1)]);
+	this.size++;
+	return this;
+};
+
+NSet.prototype.clear = function()
+{
+	this.values = {};
+	this.size = 0;
+};
+
+NSet.prototype.delete = function(...values)
+{
+	if (!values || values.length !== this.depth)
+		throw new Error(sprintf("Expected %d values; got %d", this.depth, values ? values.length : 0));
+	if (this.depth === 1)
+	{
+		const ret = this.values.hasOwnProperty(values[0]);
+		delete(this.values[values[0]]);
+		if (ret)
+			this.size--;
+		return ret;
+	}
+	if (this.values[values[0]])
+	{
+		const ret = this.values[values[0]].delete(values.slice(1));
+		if (ret)
+			this.size--;
+		return ret;
+	}
+	return false;
+};
+
+NSet.prototype.has = function(...values)
+{
+	if (!values || values.length !== this.depth)
+		throw new Error(sprintf("Expected %d values; got %d", this.depth, values ? values.length : 0));
+	if (this.depth === 1)
+		return this.values.hasOwnProperty(values[0]);
+	if (this.values[values[0]])
+		return this.values[values[0]].has(values.slice(1));
+	return false;
+};
+
diff --git a/binaries/data/mods/public/globalscripts/PriorityQueue.js b/binaries/data/mods/public/globalscripts/PriorityQueue.js
new file mode 100644
index 0000000000..b2e53ae173
--- /dev/null
+++ b/binaries/data/mods/public/globalscripts/PriorityQueue.js
@@ -0,0 +1,53 @@
+// implementation of a heap consistings of entries in the format [item, priority]
+// item being the relevant data and priority being the number used to rank each entry
+// can be implemented as either a min heap or max heap (defaults to min heap)
+
+// @param isMinHeap		boolean			whether should be implemented as a min heap or max heap
+function PriorityQueue(compare = (a, b) => a < b) {
+	this.compare = compare;
+	this.values = [null];
+}
+
+PriorityQueue.prototype.push = function(item, priority) {
+	this.values.push([item, priority]);
+	// percolate the value upward
+	for (let i = this.values.length - 1; i >> 1; i >>= 1) {
+		if (this.compare(this.values[i][1], this.values[i >> 1][1])) {
+			const tmp = this.values[i >> 1];
+			this.values[i >> 1] = this.values[i];
+			this.values[i] = tmp;
+		}
+	}
+}
+
+PriorityQueue.prototype.peek = function() {
+	if (this.values.length < 2)
+		return undefined;
+	return this.values[1][0];
+}
+
+PriorityQueue.prototype.pop = function() {
+	if (this.values.length < 2)
+		return undefined;
+	const ret = this.values[1][0];
+	this.values[1] = this.values[this.values.length - 1];
+	this.values.length--;
+	// percolate top item downward
+	const getPrefChild = (i) => {
+		if ((i << 1) + 1 > this.values.length - 1)
+			return i << 1;
+		return this.compare(this.values[i << 1][1], this.values[(i << 1) + 1][1]) ?
+			i << 1 :
+			(i << 1) + 1;
+	};
+	for (let i = 1; i << 1 <= this.values.length - 1;) {
+		const prefChild = getPrefChild(i);
+		if (!this.compare(this.values[i][1], this.values[prefChild][1])) {
+			const tmp = this.values[i];
+			this.values[i] = this.values[prefChild];
+			this.values[prefChild] = tmp;
+		}
+		i = prefChild;
+	}
+	return ret;
+}
diff --git a/binaries/data/mods/public/globalscripts/utility.js b/binaries/data/mods/public/globalscripts/utility.js
index 36b94babf2..8da83a315e 100644
--- a/binaries/data/mods/public/globalscripts/utility.js
+++ b/binaries/data/mods/public/globalscripts/utility.js
@@ -230,3 +230,13 @@ function pickRandomWeighted(weightedItems)
 	}
 	return weightedItems[weightedItems.length - 1][0];
 }
+
+function formatObject(obj)
+{
+	if (typeof obj === "object") {
+		if (Array.isArray(obj))
+			return "[" + obj.map(v => formatObject(v)).join(", ") + "]";
+		return "{" + Object.entries(obj).map(([k, v]) => k + ": " + formatObject(v)).join(", ") + "}";
+	}
+	return obj.toString();
+}
diff --git a/binaries/data/mods/public/simulation/ai/common-api/entity.js b/binaries/data/mods/public/simulation/ai/common-api/entity.js
index 67fe80b2f5..5634f579c3 100644
--- a/binaries/data/mods/public/simulation/ai/common-api/entity.js
+++ b/binaries/data/mods/public/simulation/ai/common-api/entity.js
@@ -924,8 +924,8 @@ m.Entity = m.Class({
 		return this;
 	},
 
-	"tradeRoute": function(target, source) {
-		Engine.PostCommand(PlayerID, { "type": "setup-trade-route", "entities": [this.id()], "target": target.id(), "source": source.id(), "route": undefined, "queued": false, "pushFront": false });
+	"tradeRoute": function(target, source, route) {
+		Engine.PostCommand(PlayerID, { "type": "setup-trade-route", "entities": [this.id()], "target": target.id(), "source": source.id(), "route": route, "queued": false, "pushFront": false });
 		return this;
 	},
 
diff --git a/binaries/data/mods/public/simulation/ai/common-api/entitycollection.js b/binaries/data/mods/public/simulation/ai/common-api/entitycollection.js
index e4251579c1..3d3c81c0f2 100644
--- a/binaries/data/mods/public/simulation/ai/common-api/entitycollection.js
+++ b/binaries/data/mods/public/simulation/ai/common-api/entitycollection.js
@@ -201,16 +201,23 @@ m.EntityCollection.prototype.setStance = function(stance)
 };
 
 /** Returns the average position of all units */
-m.EntityCollection.prototype.getCentrePosition = function()
+m.EntityCollection.prototype.getCentrePosition = function(gameState)
 {
 	let sumPos = [0, 0];
 	let count = 0;
 	for (let ent of this._entities.values())
 	{
-		if (!ent.position())
-			continue;
-		sumPos[0] += ent.position()[0];
-		sumPos[1] += ent.position()[1];
+		let pos = ent.position();
+		if (!pos)
+		{
+			const holder = gameState.getEntityById(ent.garrisonHolderID());
+			if (holder)
+				pos = holder.position();
+			if (!holder || !pos)
+				continue;
+		}
+		sumPos[0] += pos[0];
+		sumPos[1] += pos[1];
 		count++;
 	}
 
diff --git a/binaries/data/mods/public/simulation/ai/common-api/utils.js b/binaries/data/mods/public/simulation/ai/common-api/utils.js
index fc27a7b5f1..366ddf3d3e 100644
--- a/binaries/data/mods/public/simulation/ai/common-api/utils.js
+++ b/binaries/data/mods/public/simulation/ai/common-api/utils.js
@@ -83,6 +83,60 @@ m.getMapPoints = function(i, map1, map2)
 	return ret;
 };
 
+// a "lazy pathfinder" implementing the A* pathfinding algorithm
+// generates an array of points from game position <start> to game position <dest> at <stride> distance from each other
+// each point is validated using <validator>, which takes the x and z coordinates as its two arguments
+// returns undefined if cannot find a path less than or equal to <maxDist> in length
+// @return		[{"x": Number, "z": Number}...]		an array of game points, which can be used as route data for setup-trade-route, for example
+m.findPath = function(validator, start, dest, maxDist, stride=8)
+{
+	const pq = new PriorityQueue();
+	const visited = new NSet(2);
+	const endDistSq = Math.pow(stride, 2);
+	const distDiag = Math.pow(Math.pow(stride, 2) * 2, 0.5);
+	const offsets = [
+		[-stride, -stride, distDiag], [0, -stride, stride], [stride, -stride, distDiag],
+		[-stride, 0, stride], [stride, 0, stride],
+		[-stride, stride, distDiag], [0, stride, stride], [stride, stride, distDiag]];
+	let currentNode = { "position": start, "dist": 0 };
+	for (; currentNode; currentNode = pq.pop())
+	{
+		const { position, dist } = currentNode;
+		const [x, z] = position;
+		if (visited.has(x, z))
+			continue;
+		visited.add(x, z);
+		if (m.SquareVectorDistance(position, dest) <= endDistSq)
+			break;
+		if (dist >= maxDist)
+			continue;
+		for (const [offsetX, offsetZ, offsetDist] of offsets)
+		{
+			const nextPos = [x + offsetX, z + offsetZ];
+			const [isValid, bias] = validator(...nextPos);
+			if (!isValid)
+				continue;
+			const nextNode = {
+				"position": nextPos,
+				"dist": dist + offsetDist,
+				"prev": currentNode
+			};
+			const heuristic = m.SquareVectorDistance(nextPos, dest) + Math.pow(nextNode.dist, 2) - bias;
+			pq.push(nextNode, heuristic);
+		}
+	}
+	if (!currentNode)
+		return [undefined, -1];
+	const { dist } = currentNode;
+	const points = [];
+	for (; currentNode.prev; currentNode = currentNode.prev)
+		points.unshift({
+			"x": currentNode.position[0],
+			"z": currentNode.position[1]
+		});
+	return [points, dist];
+};
+
 return m;
 
 }(API3);
diff --git a/binaries/data/mods/public/simulation/ai/delphi/attackPlan.js b/binaries/data/mods/public/simulation/ai/delphi/attackPlan.js
index 5a6ff8ff55..918e13191d 100644
--- a/binaries/data/mods/public/simulation/ai/delphi/attackPlan.js
+++ b/binaries/data/mods/public/simulation/ai/delphi/attackPlan.js
@@ -998,7 +998,7 @@ DELPHI.AttackPlan.prototype.rushTargetFinder = function(gameState, playerEnemy)
 	if (!buildings.length)
 		return targets;
 
-	this.position = this.unitCollection.getCentrePosition();
+	this.position = this.unitCollection.getCentrePosition(gameState);
 	if (!this.position)
 		this.position = this.rallyPoint;
 
@@ -1274,7 +1274,7 @@ DELPHI.AttackPlan.prototype.update = function(gameState, events)
 
 	Engine.ProfileStart("Update Attack");
 
-	this.position = this.unitCollection.getCentrePosition();
+	this.position = this.unitCollection.getCentrePosition(gameState);
 	
 	if (!this.position)
 	{
diff --git a/binaries/data/mods/public/simulation/ai/delphi/headquarters.js b/binaries/data/mods/public/simulation/ai/delphi/headquarters.js
index fb55e3e196..d9f20f3337 100644
--- a/binaries/data/mods/public/simulation/ai/delphi/headquarters.js
+++ b/binaries/data/mods/public/simulation/ai/delphi/headquarters.js
@@ -60,8 +60,8 @@ DELPHI.HQ.prototype.init = function(gameState, queues)
 	// then this map will be completed with our frontier in updateTerritories
 	this.borderMap = DELPHI.createBorderMap(gameState);
 	// settings for base expansion
-	this.lastBaseTurn = 0;
-	this.baseExpansionWait = randIntInclusive(3, 6);
+	this.lastBaseTime = 0;
+	this.baseExpansionWait = randIntInclusive(4, 7);
 	if (this.Config.personality.aggressive)
 		this.baseExpansionWait--;
 	// list of allowed regions
@@ -1026,16 +1026,17 @@ DELPHI.HQ.prototype.findGenericCCLocation = function(gameState, template)
 		})();
 		placement.addInfluence(avgPos[0], avgPos[1], Math.floor(mapWidthHalf / 2), defaultTileVal * 2, 'constant');
 		const accessVal = gameState.ai.accessibility.getAccessValue([avgPos[0] * cellSize, avgPos[1] * cellSize]);
-		for (let i in placement.map) {
+		for (const i in placement.map) {
 			const tileAccessVal = gameState.ai.accessibility.getAccessValue([(i % mapWidth) * cellSize, Math.floor(i / mapWidth) * cellSize]);
 			if (tileAccessVal !== accessVal)
 				placement.map[i] = 0;
 		}// end for i in placement.map
 		// favor shorelines
 		const shoreMapBasic = this.getShorePlacementMap(gameState, structRadiusMeters * shoreDistCoeff, undefined, new Set([accessVal]));
-		shoreMapBasic.dumpIm(sprintf("shoreMapBasic_p%02d_%s_%08d.png", PlayerID, template.templateName(), gameState.ai.playedTurn), Math.max(...shoreMapBasic.map) || shoreMapBasic.maxVal);
+		if (this.Config.debug > 1)
+			shoreMapBasic.dumpIm(sprintf("shoreMapBasic_p%02d_%s_%08d.png", PlayerID, template.templateName(), gameState.ai.playedTurn), Math.max(...shoreMapBasic.map) || shoreMapBasic.maxVal);
 		const shoreMapBasicValueCache = {};
-		for (let i in placement.map)
+		for (const i in placement.map)
 		{
 			const shoreVal = shoreMapBasic.map[i];
 			const shoreMultiplier = shoreMapBasicValueCache[shoreVal] || (1 + (shoreCoeff * shoreVal / shoreMapBasic.maxVal));
@@ -1060,12 +1061,15 @@ DELPHI.HQ.prototype.findGenericCCLocation = function(gameState, template)
 		// shore of land regions where we already have CCs
 		const shoreMapBasic = this.getShorePlacementMap(gameState, structRadiusMeters * shoreDistCoeff, undefined, allowedLandIndices);
 		const shoreMapConditional = this.getShorePlacementMap(gameState, structRadiusMeters * shoreDistCoeff, allowedWaterIndices, conditionalLandIndices);
-		shoreMapBasic.dumpIm(sprintf("shoreMapBasic_p%02d_%s_%08d.png", PlayerID, template.templateName(), gameState.ai.playedTurn), Math.max(...shoreMapBasic.map) || shoreMapBasic.maxVal);
-		shoreMapConditional.dumpIm(sprintf("shoreMapConditional_p%02d_%s_%08d.png", PlayerID, template.templateName(), gameState.ai.playedTurn), Math.max(...shoreMapConditional.map) || shoreMapConditional.maxVal);
+		if (this.Config.debug > 1)
+		{
+			shoreMapBasic.dumpIm(sprintf("shoreMapBasic_p%02d_%s_%08d.png", PlayerID, template.templateName(), gameState.ai.playedTurn), Math.max(...shoreMapBasic.map) || shoreMapBasic.maxVal);
+			shoreMapConditional.dumpIm(sprintf("shoreMapConditional_p%02d_%s_%08d.png", PlayerID, template.templateName(), gameState.ai.playedTurn), Math.max(...shoreMapConditional.map) || shoreMapConditional.maxVal);
+		}
 		const shoreMapBasicValueCache = {};
 		const shoreMapConditionalValueCache = {};
 		// add influence around allowed shorelines
-		for (let i in placement.map)
+		for (const i in placement.map)
 		{
 			const shoreBasicVal = shoreMapBasic.map[i];
 			const shoreBasicMultiplier = shoreMapBasicValueCache[shoreBasicVal] || (1 + (shoreCoeff * shoreBasicVal / shoreMapBasic.maxVal));
@@ -1104,14 +1108,15 @@ DELPHI.HQ.prototype.findGenericCCLocation = function(gameState, template)
 		const resourceValue = 4 * defaultTileVal / ents.length;
 		if (resourceValue < 1)
 			continue;
-		for (let [x, z] of ents.map(ent => ent.position()).filter(pos => pos).map(pos => placement.gamePosToMapPos(pos))) {
+		for (const [x, z] of ents.map(ent => ent.position()).filter(pos => pos).map(pos => placement.gamePosToMapPos(pos))) {
 			desirabilityPlacement.addInfluence(x, z, structRadius * 2, resourceValue);
 		}// end for ent of ents
 	}// end for res of Resources.GetCodes()
 	placement.map = placement.map.map((val, i) => Math.min(val && desirabilityPlacement.map[i] ? val + desirabilityPlacement.map[i] : 0, placement.maxVal));
 	this.applyBuildRestrictions(placement, gameState, template);
 	this.applyDefensiveRestrictions(placement, gameState);
-	placement.dumpIm(sprintf("placement_p%02d_%s_%08d.png", PlayerID, template.templateName(), gameState.ai.playedTurn), Math.max(...placement.map) || placement.maxVal);
+	if (this.Config.debug > 1)
+		placement.dumpIm(sprintf("placement_p%02d_%s_%08d.png", PlayerID, template.templateName(), gameState.ai.playedTurn), Math.max(...placement.map) || placement.maxVal);
 	const tileChoices = [];
 	// if not the first cc, make sure there is an unbroken line to another cc (no enemy territory in between)
 	const avoidRange = Math.floor(100 / placement.cellSize);
@@ -1149,12 +1154,12 @@ DELPHI.HQ.prototype.findGenericCCLocation = function(gameState, template)
 	Engine.ProfileStop();
 
 	// Define a minimal number of wanted ships in the seas reaching this new base
-	let indexIdx = gameState.ai.accessibility.landPassMap[bestTile.idx];
-	for (let base of this.baseManagers)
+	const indexIdx = gameState.ai.accessibility.landPassMap[bestTile.idx];
+	for (const base of this.baseManagers)
 	{
 		if (!base || !base.anchor || base.accessIndex == indexIdx)
 			continue;
-		let sea = this.getSeaBetweenIndices(gameState, base.accessIndex, indexIdx);
+		const sea = this.getSeaBetweenIndices(gameState, base.accessIndex, indexIdx);
 		if (sea !== undefined)
 			this.navalManager.setMinimalTransportShips(gameState, sea, 1);
 	}
@@ -1527,11 +1532,11 @@ DELPHI.HQ.prototype.applyBuildRestrictions = function(placement, gameState, temp
 	const hasMaxDistances = (distancesExclusive && Object.keys(distancesExclusive).some(k => distancesExclusive[k].MaxDistance)) ||
 		(distancesInclusive && Object.keys(distancesInclusive).every(k => distancesInclusive[k].MaxDistance));
 	if (!hasMaxDistances)
-		for (let i in buildRestrictionsPlacement.map)
+		for (const i in buildRestrictionsPlacement.map)
 			buildRestrictionsPlacement.map[i] = 1;
 	if (distancesInclusive)
 	{
-		for (let d in distancesInclusive)
+		for (const d in distancesInclusive)
 		{
 			const dist = distancesInclusive[d];
 			if (!dist.MaxDistance)
@@ -1539,7 +1544,7 @@ DELPHI.HQ.prototype.applyBuildRestrictions = function(placement, gameState, temp
 			const maxDist = Math.floor(+dist.MaxDistance);
 			const distClass = dist.FromClass;
 			const classStructs = gameState.getOwnStructures().filter(API3.Filters.byClass(distClass)).toEntityArray();
-			for (let ent of classStructs)
+			for (const ent of classStructs)
 			{
 				const entPos = ent.position();
 				if (!entPos)
@@ -1550,7 +1555,7 @@ DELPHI.HQ.prototype.applyBuildRestrictions = function(placement, gameState, temp
 	}
 	if (distancesExclusive)
 	{
-		for (let d in distancesExclusive)
+		for (const d in distancesExclusive)
 		{
 			const dist = distancesExclusive[d];
 			if (!dist.MinDistance)
@@ -1558,7 +1563,7 @@ DELPHI.HQ.prototype.applyBuildRestrictions = function(placement, gameState, temp
 			const minDist = Math.floor(+dist.MinDistance);
 			const distClass = dist.FromClass;
 			const classStructs = gameState.getOwnStructures().filter(API3.Filters.byClass(distClass)).toEntityArray();
-			for (let ent of classStructs)
+			for (const ent of classStructs)
 			{
 				const entPos = ent.position();
 				if (!entPos)
@@ -1567,9 +1572,10 @@ DELPHI.HQ.prototype.applyBuildRestrictions = function(placement, gameState, temp
 			}// end for ent
 		}// end for dist
 	}
-	for (let i in placement.map)
+	for (const i in placement.map)
 		placement.map[i] = placement.map[i] * buildRestrictionsPlacement.map[i];
-	buildRestrictionsPlacement.dumpIm(sprintf("buildres_p%02d_%s_%08d.png", PlayerID, template.templateName(), gameState.ai.playedTurn), Math.max(...buildRestrictionsPlacement.map) || buildRestrictionsPlacement.maxVal);
+	if (this.Config.debug > 1)
+		buildRestrictionsPlacement.dumpIm(sprintf("buildres_p%02d_%s_%08d.png", PlayerID, template.templateName(), gameState.ai.playedTurn), Math.max(...buildRestrictionsPlacement.map) || buildRestrictionsPlacement.maxVal);
 };//end DELPHI.HQ.prototype.applyBuildRestrictions
 
 DELPHI.HQ.prototype.applyDefensiveRestrictions = function(placement, gameState)
@@ -1610,11 +1616,11 @@ DELPHI.HQ.prototype.getShorePlacementMap = function(gameState, distance, seaRegi
 	);
 	if (this.shorePlacementMapCache[mapID])
 		return new API3.Map(gameState.sharedScript, "territory", this.shorePlacementMapCache[mapID], true);
-	const shorePlacementMaster = new API3.Map(gameState.sharedScript, "territory");
-	const mapDistance = Math.floor(distance / shorePlacementMaster.cellSize);
+	const shorePlacement = new API3.Map(gameState.sharedScript, "territory");
+	const mapDistance = Math.floor(distance / shorePlacement.cellSize);
 	const maxWaterValue = Math.max(...Object.values(this.waterValues));
-	const waterValueNormalization = maxWaterValue > shorePlacementMaster.maxVal ?
-		shorePlacementMaster.maxVal / maxWaterValue :
+	const waterValueNormalization = maxWaterValue > shorePlacement.maxVal ?
+		shorePlacement.maxVal / maxWaterValue :
 		1.0;
 	const stride = 1;
 	// API3.warnf("Max water value: %s; Water value normalization: %s",
@@ -1624,32 +1630,25 @@ DELPHI.HQ.prototype.getShorePlacementMap = function(gameState, distance, seaRegi
 	// API3.warnf("Sea regions: [%s]", [...seaRegions.keys()].map(k => String(k)).join(", "));
 	// if (landRegions)
 	// 	API3.warnf("Land regions: [%s]", [...landRegions.keys()].map(k => String(k)).join(", "));
-	const shoreMaps = {};
-	for (let seaRegion of seaRegions.keys())
+	const seaRegionsSorted = [...seaRegions.keys()].sort((a, b) => this.waterValues[a] > this.waterValues[b]);
+	for (const seaRegion of seaRegionsSorted)
 	{
-		const shorePlacement = new API3.Map(gameState.sharedScript, "territory");
-		shorePlacement.setMaxVal(1);
+		const maxVal = Math.floor(this.waterValues[seaRegion] * waterValueNormalization);
+		if (!maxVal)
+			continue;
+		shorePlacement.setMaxVal(maxVal);
 		const validTiles = (landRegions ?
 			this.shoreTilesBySeaRegion[seaRegion].filter(tile => landRegions.has(tile.land)) :
 			this.shoreTilesBySeaRegion[seaRegion]).filter((_, i) => !(i % stride));
-		// API3.warnf("No. valid shore tiles: %d", validTiles.length);
-		for (let tile of validTiles)
+		// API3.warnf("No. valid shore tiles for sea region %d: %d", seaRegion, validTiles.length);
+		for (const tile of validTiles)
 		{
 			// API3.warnf("Tile Pos: [%d, %d]; Radius: %d", tile.x, tile.x, mapDistance);
-			shorePlacement.addInfluence(...[tile.x, tile.z].map(v => Math.floor(v / shorePlacement.cellSize)), mapDistance, 1, 'constant');
+			shorePlacement.addInfluence(...shorePlacement.gamePosToMapPos([tile.x, tile.z]), mapDistance, maxVal, 'constant');
 		}
-		// API3.warnf("No. highlighted tiles: %d", shorePlacement.map.filter(val => val).length);
-		shoreMaps[seaRegion] = shorePlacement;
-	}
-	for (let i in shorePlacementMaster.map)
-	{
-		const tileValues = Object.entries(shoreMaps).map(([seaRegion, placement]) =>
-			Math.round(placement.map[i] * (this.waterValues[seaRegion] || 0) * waterValueNormalization));
-		// API3.warnf("Tile values at %d: [%s]", i, tileValues.map(val => String(val)).join(", "));
-		shorePlacementMaster.map[i] = Math.max(...tileValues);
 	}
-	this.shorePlacementMapCache[mapID] = shorePlacementMaster.map;
-	return new API3.Map(gameState.sharedScript, "territory", shorePlacementMaster.map, true);
+	this.shorePlacementMapCache[mapID] = shorePlacement.map;
+	return new API3.Map(gameState.sharedScript, "territory", shorePlacement.map, true);
 };
 
 /**
@@ -1860,7 +1859,7 @@ DELPHI.HQ.prototype.findCivicLocation = function(gameState, template)
 			}
 			placement.map[i] = Math.ceil(this.waterValues[seaRegion] * waterValueNormalization);
 			if (preferredWaterRegions.has(seaRegion))
-				placement.map[i] *= 2;
+				placement.map[i] <<= 1;
 			placement.map[i] = Math.min(placement.map[i], placement.maxVal);
 		}
 	}
@@ -1875,7 +1874,8 @@ DELPHI.HQ.prototype.findCivicLocation = function(gameState, template)
 	}
 	this.applyBuildRestrictions(placement, gameState, template);
 	this.applyDefensiveRestrictions(placement, gameState);
-	placement.dumpIm(sprintf("placement_p%02d_%s_%08d.png", PlayerID, template.templateName(), gameState.ai.playedTurn), Math.max(...placement.map) || placement.maxVal);
+	if (this.Config.debug > 1)
+		placement.dumpIm(sprintf("placement_p%02d_%s_%08d.png", PlayerID, template.templateName(), gameState.ai.playedTurn), Math.max(...placement.map) || placement.maxVal);
 	const radius = Math.ceil((template.obstructionRadius().max * obstructionRatio / obstructions.cellSize));
 	const validPositions = [];
 	for (let i = 0; i < maxRetries; i++)
@@ -2402,12 +2402,12 @@ DELPHI.HQ.prototype.checkBaseExpansion = function(gameState, queues)
 		return;
 	}
 	// only proceed if we have reached the expected turn to build a new base
-	const expectedNewBaseTurn = this.lastBaseTurn + Math.pow(this.baseExpansionWait + ccEnts.length, 3);
-	if (gameState.ai.playedTurn < expectedNewBaseTurn)
+	const expectedNewBaseTime = this.lastBaseTime + Math.pow(this.baseExpansionWait + ccEnts.length, 3);
+	if (gameState.ai.elapsedTime < expectedNewBaseTime)
 		return;
 	if (this.Config.debug > 2)
-		API3.warnf("building new base because we have exceeded expected new base turn (current turn: %d; current no. CCs: %d)",
-			gameState.ai.playedTurn, ccEnts.length);
+		API3.warnf("building new base because we have exceeded expected new base time (current elapsed time: %d; current no. CCs: %d)",
+			gameState.ai.elapsedTime, ccEnts.length);
 	this.buildNewBase(gameState, queues);
 };
 
@@ -2418,7 +2418,10 @@ DELPHI.HQ.prototype.buildNewBase = function(gameState, queues, resource)
 	if (gameState.getOwnFoundations().filter(API3.Filters.byClass("CivCentre")).hasEntities() || queues.civilCentre.hasQueuedUnits())
 		return false;
 
-	this.lastBaseTurn = gameState.ai.playedTurn;
+	this.lastBaseTime = gameState.ai.elapsedTime;
+	this.baseExpansionWait = randIntInclusive(4, 7);
+	if (this.Config.personality.aggressive)
+		this.baseExpansionWait--;
 	let template;
 	// We require at least one of this civ civCentre as they may allow specific units or techs
 	let hasOwnCC = false;
diff --git a/binaries/data/mods/public/simulation/ai/delphi/mapModule.js b/binaries/data/mods/public/simulation/ai/delphi/mapModule.js
index aa07cb5f39..ff1993024d 100644
--- a/binaries/data/mods/public/simulation/ai/delphi/mapModule.js
+++ b/binaries/data/mods/public/simulation/ai/delphi/mapModule.js
@@ -79,7 +79,7 @@ DELPHI.createObstructionMap = function(gameState, accessIndex, template)
 		}
 	}
 
-	// contrain using BuildRestrictions/Distances*
+	// constrain using BuildRestrictions/Distances*
 	let map = new API3.Map(gameState.sharedScript, "passability", obstructionTiles);
 	map.setMaxVal(255);
 	const penalty = -255;
diff --git a/binaries/data/mods/public/simulation/ai/delphi/tradeManager.js b/binaries/data/mods/public/simulation/ai/delphi/tradeManager.js
index 0bfda25436..41eb28ad19 100644
--- a/binaries/data/mods/public/simulation/ai/delphi/tradeManager.js
+++ b/binaries/data/mods/public/simulation/ai/delphi/tradeManager.js
@@ -142,7 +142,6 @@ DELPHI.TradeManager.prototype.setTradingGoods = function(gameState)
 	}// end for res in wantedRates
 	wantedRates = actualWantedRates;
 	let remaining = 100;
-	let targetNum = gameState.getPopulationMax() * this.traderRatio;
 	for (let res of resTradeCodes)
 	{
 		if (res == "food")
@@ -394,12 +393,23 @@ DELPHI.TradeManager.prototype.updateRoutes = function(gameState)
 
 	const ownMarketEntities = ownMarkets.toEntityArray().filter(ent => ent.position());
 	const friendlyMarketEntities = new Set(ownMarketEntities.concat(exclusiveAllyMarkets.toEntityArray().filter(ent => ent.position())));
-	for (let market of ownMarketEntities)
+	// for API3.findPath (finding safe waypoints)
+	const enemyDefenses = gameState.updatingCollection("diplo-EnemyDefensiveStructures", API3.Filters.hasDefensiveFire(), gameState.getEnemyStructures());
+	const obstructions = new API3.Map(gameState.sharedScript, "territory");
+	obstructions.setMaxVal(1);
+	enemyDefenses.forEach(defense => {
+		const defensePos = defense.position();
+		if (!defensePos)
+			return;
+		const avoidRange = Math.round((defense.attackRange("Ranged")?.max || 0) * 1.5 / obstructions.cellSize);
+		obstructions.addInfluence(...obstructions.gamePosToMapPos(defensePos), avoidRange, 1, 'constant');
+	});
+	for (const market of ownMarketEntities)
 	{
 		friendlyMarketEntities.delete(market);
-		for (let otherMarket of friendlyMarketEntities.keys())
+		for (const otherMarket of friendlyMarketEntities.keys())
 		{
-			let route = {
+			const route = {
 				"markets": [market, otherMarket],
 				"id": sprintf("%d:%d", ...[market, otherMarket].map(ent => ent.id()).sort())
 			};
@@ -420,14 +430,54 @@ DELPHI.TradeManager.prototype.updateRoutes = function(gameState)
 			{
 				const marketLandAccess = DELPHI.getLandAccess(gameState, market);
 				const otherMarketLandAccess = DELPHI.getLandAccess(gameState, otherMarket);
-				if (marketLandAccess === otherMarketLandAccess && !DELPHI.isLineInsideEnemyTerritory(gameState, marketPos, otherMarketPos, 50, 3))
+				if (marketLandAccess === otherMarketLandAccess && !DELPHI.isLineInsideEnemyTerritory(gameState, marketPos, otherMarketPos, 50, 5))
 				{
 					route.landAccess = marketLandAccess;
 					route.gain = Math.round(traderTemplatesGains.landGainMultiplier * TradeGain(vectorDistance, mapSize));
 				}
 			}
 			if (route.seaAccess || route.landAccess)
+			{
 				this.tradeRoutes.push(route);
+				// provide waypoints if part of route would otherwise cross enemy territory
+				if (DELPHI.isLineInsideEnemyTerritory(gameState, ...route.markets.map(ent => ent.position())))
+				{
+					const access = route.seaAccess || route.landAccess;
+					const accessMap = new API3.Map(gameState.sharedScript, "passability", route.seaAccess ?
+						gameState.ai.accessibility.navalPassMap : gameState.ai.accessibility.landPassMap);
+					const validator = (x, z) => {
+						const [obsX, obsZ] = obstructions.gamePosToMapPos([x, z]);
+						if (obsX < 0 || obsX >= obstructions.width || obsZ < 0 || obsZ >= obstructions.height)
+							return [false, 0];
+						return [
+							accessMap.point([x, z]) === access && !obstructions.point([x, z]),
+							0
+						];
+					};
+					const marketPositions = route.markets.map(ent => ent.position());
+					const [waypoints] = API3.findPath(validator, ...marketPositions, vectorDistance * 3, 32);
+					if (waypoints)
+						route.waypoints = waypoints.filter((_, i) => !(i % 2));
+					if (this.Config.debug > 1)
+					{
+						if (!waypoints)
+							API3.warnf("No waypoints found for route %s", route.id);
+						else {
+							API3.warnf("Route %s waypoints: %s", route.id, formatObject(waypoints));
+							if (this.Config.debug > 2)
+							{
+								const visualizer = new API3.Map(gameState.sharedScript, "passability", accessMap.map, true);
+								visualizer.setMaxVal(Math.max(...Object.keys(gameState.ai.HQ.waterValues)) * 3);
+								for (const { x, z } of waypoints) {
+									const [mapX, mapZ] = visualizer.gamePosToMapPos([x, z]);
+									visualizer.addInfluence(mapX, mapZ, 2, visualizer.maxVal, 'constant');
+								}
+								visualizer.dumpIm(sprintf("waypoints_p%02d_%s_%08d.png", PlayerID, route.id, gameState.ai.playedTurn));
+							}
+						}
+					}
+				}
+			}
 		}
 	}
 	this.tradeRoutes = this.tradeRoutes.sort((a, b) => a.gain < b.gain);
@@ -685,7 +735,10 @@ DELPHI.TradeManager.prototype.assignRouteToTrader = function(gameState, trader,
 			return;
 		}
 	}
-	trader.tradeRoute(nearerMarket, furtherMarket);
+	let waypoints;
+	if (route.waypoints)
+		waypoints = nearerMarket === route.markets[1] ? route.waypoints.slice().reverse() : route.waypoints;
+	trader.tradeRoute(nearerMarket, furtherMarket, waypoints);
 };
 
 DELPHI.TradeManager.prototype.assignTradeRoutes = function(gameState)
@@ -743,7 +796,7 @@ DELPHI.TradeManager.prototype.update = function(gameState, events, queues)
 	if (this.tradeRoutes && this.tradeRoutes.length)
 	{
 		this.traders.forEach(ent => this.updateTrader(gameState, ent));
-		if (gameState.ai.playedTurn % 3 == 0)
+		if (gameState.ai.playedTurn % 3 === 0)
 			this.trainMoreTraders(gameState, queues);
 		if (gameState.ai.playedTurn % 20 == 0 && this.traders.length >= 2)
 			gameState.ai.HQ.researchManager.researchTradeBonus(gameState, queues);
-- 
2.25.1

